<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
  <title>Project: Zoomies</title>
  <style>
    :root {
      --bg: #0a0d12;
      --sky: #1a2940;
      --ink: #ecf3ff;
      --red: #ef4f6c;
      --mint: #69f0c9;
      --gold: #ffd56d;
      --line: #2f4868
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      color: var(--ink);
      font-family: Trebuchet MS, Avenir Next, Segoe UI, sans-serif
    }

    body {
      touch-action: none
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <script src="leaderboard-config.js"></script>
  <script>
    (() => {
      const c = document.getElementById('c'), x = c.getContext('2d');
      let W = 360, H = 740, DPR = 1, last = 0;

      const MAP_W = 2600, MAP_H = 1800;
      const MID_X = MAP_W * .5, MID_Y = MAP_H * .5;
      const HOME = { x: 260, y: MAP_H * .5, r: 170 };
      const SAFE_BUILDINGS = [
        { id: 'home', n: 'Cohon Centre', x: HOME.x, y: HOME.y, r: HOME.r, c: '#8ec0ff' },
        { id: 'nsh', n: 'NSH', x: 980, y: 460, r: 170, c: '#79d7ff' },
        { id: 'mel', n: 'Mellon Inst', x: 1880, y: 1260, r: 185, c: '#ffd58f' },
        { id: 'bak', n: 'Baker Hall', x: 2280, y: 640, r: 170, c: '#9ec8ff' }
      ];
      function randomizeBuildings() {
        // Cohon Centre stays fixed at HOME. Randomize NSH, Mellon, and Baker.
        const pad = 220, minSep = 520, minFromHome = 560;
        const nsh = school('nsh'), mel = school('mel'), bak = school('bak');
        // pick NSH position: right half of map, anywhere vertically
        for (let tries = 0; tries < 80; tries++) {
          const nx = rnd(pad + 500, MAP_W - pad), ny = rnd(pad, MAP_H - pad);
          const dh = Math.hypot(nx - HOME.x, ny - HOME.y);
          if (dh < minFromHome) continue;
          nsh.x = nx; nsh.y = ny; break;
        }
        // pick Mellon position: must be far from both Cohon and NSH
        for (let tries = 0; tries < 80; tries++) {
          const mx = rnd(pad + 400, MAP_W - pad), my = rnd(pad, MAP_H - pad);
          const dh = Math.hypot(mx - HOME.x, my - HOME.y);
          const dn = Math.hypot(mx - nsh.x, my - nsh.y);
          if (dh < minFromHome || dn < minSep) continue;
          mel.x = mx; mel.y = my; break;
        }
        // pick Baker position: far from home, NSH, and Mellon
        for (let tries = 0; tries < 100; tries++) {
          const bx = rnd(pad + 450, MAP_W - pad), by = rnd(pad, MAP_H - pad);
          const dh = Math.hypot(bx - HOME.x, by - HOME.y);
          const dn = Math.hypot(bx - nsh.x, by - nsh.y);
          const dm = Math.hypot(bx - mel.x, by - mel.y);
          if (dh < minFromHome || dn < minSep || dm < minSep * .92) continue;
          bak.x = bx; bak.y = by; break;
        }
      }
      const WHO = ['i need to go out', 'these things are scary', 'may lord help us', 'can we ever go out?'];
      const WHI = ['a dog?', 'scotty??', 'what the dog doing?'];
      const JOY_CENTER_SNAP = 10;
      const JOY_INPUT_DEAD = .12;
      const JOY_EDGE_PAD = 16;
      const JOY_SMOOTH = 22;
      const JOY_VIS_SMOOTH = 16;
      const LEVEL_UI_ZOOMIES_GRACE = 1;
      const MAX_Z = 160, MAX_FOOD = 260, MAX_FX = 420, MAX_PUDD = 18, MAX_B = 260, MAX_REACT = 14;
      const FIRST_BOSS_MIN_KILLS = 600;
      const FIRST_BOSS_TRIGGER_KILLS = 800;
      const FIRST_BOSS_TRIGGER_TIME = 999;
      const LAB_REFRESH_KILLS = 160;
      const NSH_SECOND_BOT_INTEL_COST = 2;
      const NSH_THIRD_BOT_INTEL_COST = 3;
      const MEL_SECOND_PUDDLE_INTEL_COST = 1;
      const MEL_THIRD_PUDDLE_INTEL_COST = 2;
      const BAK_SECOND_BARK_KILLS = 320;
      const BAK_THIRD_BARK_KILLS = 1000;
      const PSY_AUTO_INTERVAL = .32;
      const PSY_MARK_TIME = 1.55;
      const PSY_COMBO_CD = .9;
      const PSY_DECOY_TIME = 2.2;
      const PSY_DECOY_RADIUS = 160;
      const MAX_PSYFX = 8;
      const SHELTER_GRACE = 24;
      const SHELTER_WARN = 6;
      const SHELTER_PULSE = .9;
      const SHELTER_THREAT_RADIUS = 230;
      const SHELTER_MIN_THREAT = 6;
      const BOSS1_EAT_CD = .14;
      const BOSS1_GROW_R = 1.6;
      const BOSS1_GROW_HP = 35;
      const BOSS1_GROW_DMG = 2.0;
      const BOSS1_GROW_SPD = 2.4;
      const SLINGSHOT_CHARGE_TRIGGER = .25;
      const SLINGSHOT_DASH_MIN = .34;
      const SLINGSHOT_DASH_MAX = .72;
      const SLINGSHOT_DASH_SPEED = 620;
      const SLINGSHOT_RECALL_TIME = .42;
      const SLINGSHOT_RECALL_HOME_RATE = 7.2;
      const SLINGSHOT_RECALL_BURST_RADIUS = 132;
      const SLINGSHOT_PERFECT_WINDOW = .24;
      const SLINGSHOT_AIM_DOT = .82;
      const SLINGSHOT_TRIPLE_BURST_RADIUS = 165;
      const SLINGSHOT_LINK_HOLD = 1.08;
      const SLINGSHOT_LINK_MIN = .22;
      const SLINGSHOT_LINK_REST = 92;
      const SLINGSHOT_LINK_SWING = 34;
      const SLINGSHOT_LINK_SPRING = 13.2;
      const SLINGSHOT_LINK_DAMP = .58;
      const SLINGSHOT_LINK_TANGENT = .32;
      const SLINGSHOT_LINK_DOG_SHARE = .62;
      const SLINGSHOT_THROW_STEER = 860;
      const SLINGSHOT_THROW_DRAG = 2.35;
      const SLINGSHOT_ROPE_START = 176;
      const SLINGSHOT_ROPE_DEFAULT = 44;
      const SLINGSHOT_ROPE_SHRINK = 142;
      const SL_DUO_SCALE = .62;
      const BOT_MELEE_DMG = 8;
      const BOT_MELEE_CD = .3;
      const BOT_MELEE_RANGE = 22;
      const BOT_MELEE_KB = 140;
      const KILL_CAP = 9999;
      const PREDATOR_TRIGGER = 1690;
      const MOTHER_TRIGGER = 3000;
      const MINI_BOSS_MIN_KILLS = 200;
      const EXPLODER_INTRO_KILLS = 100;
      const SHIELDED_INTRO_KILLS = 400;
      const HEALER_INTRO_KILLS = 800;
      const ENDLESS_SPAWN_ACCEL = .014;
      const APEX_ARRIVAL_DELAY = 12;
      const APEX_WARN_ONE = 8.5;
      const APEX_WARN_TWO = 3.6;
      const APEX_STORM_PULL_BASE = 32;
      const APEX_STORM_PULL_GROW = 20;
      const APEX_STORM_ZOOMIES_RESIST = .28;
      const APEX_STORM_TICK_DMG = 3.6;
      const APEX_STORM_TICK_CD = .34;
      const ZOOMIES_SHIELD_DURATION = 3;
      const ZOOMIES_SHIELD_REDUCTION = .8;
      const SAFE_ZONE_EDGE_BUFFER = 25;
      const SAFE_ZONE_DAMAGE_REDUCTION = .93;

      const imgs = {};
      function load(n) { const i = new Image(); i.src = 'black_scottish_terrier_dog_with_red_scarf/rotations/' + n + '.png'; return i }
      imgs.e = load('east'); imgs.w = load('west'); imgs.ne = load('north-east'); imgs.nw = load('north-west'); imgs.se = load('south-east'); imgs.sw = load('south-west');

      let audio = 0;
      function beep(f, d, t, v) { if (!audio) return; const o = audio.createOscillator(), g = audio.createGain(); o.type = t || 'triangle'; o.frequency.value = f; g.gain.value = v || .02; g.gain.exponentialRampToValueAtTime(.0001, audio.currentTime + d); o.connect(g).connect(audio.destination); o.start(); o.stop(audio.currentTime + d) }
      let memeT = 0;
      function playMeme() {
        if (!g.start) return;
        const now = performance.now();
        if (now - memeT < 1200) return;
        memeT = now;
        beep(392, .07, 'square', .02);
        beep(523, .08, 'triangle', .014);
      }
      let bgMusic = new Audio('sound/music.mp3');
      bgMusic.loop = true;
      bgMusic.volume = 0.33;

      const g = {
        start: 0, dead: 0, lvup: 0, t: 0, time: 0, kills: 0,
        spawnT: 0, nextSpawn: .8,
        msg: '', msgT: 0,
        level: 1, xp: 0, nextXp: 24,
        stop: 0, shake: 0, xpPulse: 0, cardT: 0,
        best: +localStorage.ss_best || 0,
        choices: [],
        homeNeed: 3, homeGot: 0,
        musicStarted: 0,
        sch: { nsh: 0, mel: 0, bak: 0 }, // 0 not started, 1 active, 2 done
        pz: 0,
        uq: [],
        inB: '', mb: 0, mbd: 0, bs: 0, bd: 0, bs2: 0, bd2: 0, b2At: 0,
        pred: 0, predDead: 0, moth: 0, mothDead: 0,
        bossDownT: 0, won: 0,
        endWave: 0, endT: 0, endSpawnT: 0,
        apWarn1: 0, apWarn2: 0, apStormHitCd: 0,
        botMask: 0, chemMask: 0, psyMask: 0,
        labStep: 0, labBank: 0, labFlip: 0,
        labNsh: 0, labMel: 0, labBak: 0,
        labNshRuns: 0, labMelRuns: 0,
        stormCd: 0,
        labCd: 0,
        safeCampT: 0,
        safeBreachCd: 0,
        safeThreat: 0,
        lvPend: 0,
        lvGrace: 0,
        lbSent: 0,
        lbTop: [],
        lbTopErr: '',
        lbFetchT: 0,
        lbRankText: '',
        lbRankErr: '',
        lbRankFetchT: 0,
        lbRetryAt: 0,
        lbBtnX: 0,
        lbBtnY: 0,
        lbBtnW: 0,
        lbBtnH: 0,
        paused: 0,
        pauseBtnX: 0,
        pauseBtnY: 0,
        pauseBtnW: 0,
        pauseBtnH: 0
      };

      const lbCfg = window.LEADERBOARD_CONFIG || {};
      const LB_URL = (String(lbCfg.supabaseUrl || '')).replace(/\/+$/, '');
      const LB_KEY = String(lbCfg.supabaseAnonKey || '');
      const LB_TABLE = String(lbCfg.table || 'leaderboard_entries');
      const LB_ENTRY_KEY = 'zoomies_last_entry';
      const LB_NAME_KEY = 'zoomies_lb_name';
      const LB_OPTIN_KEY = 'zoomies_lb_optin';
      const LB_GUEST_ID_KEY = 'zoomies_lb_guest_id';
      const LB_PREVIEW_LIMIT = 5;
      const LB_BEST_SCORE_KEY = 'zoomies_lb_best_score';
      const LB_PENDING_ENTRY_KEY = 'zoomies_lb_pending_entry';
      const LB_LAST_SYNCED_SCORE_KEY = 'zoomies_lb_last_synced_score';
      function lsGet(k) { try { return localStorage.getItem(k) || '' } catch { return '' } }
      function lsSet(k, v) { try { localStorage.setItem(k, v) } catch { } }
      function lsGetJson(k) { try { const raw = localStorage.getItem(k); return raw ? JSON.parse(raw) : 0 } catch { return 0 } }
      function validLbName(v) { return typeof v === 'string' && v.length > 0 && v.length <= 24 && /^[A-Za-z0-9 _.-]+$/.test(v) }
      function openLeaderboardPage() { location.href = 'leaderboard.html' }
      function parseCount(h) { const m = String(h || '').match(/\/(\d+)$/); return m ? +m[1] : 0 }
      function compareLeaderboardRows(a, b) {
        const ak = Number(a.kills) || 0;
        const bk = Number(b.kills) || 0;
        if (bk !== ak) return bk - ak;

        const at = Number(a.time_seconds);
        const bt = Number(b.time_seconds);
        if (at !== bt) return at - bt;

        const ac = Date.parse(a.created_at || '') || 0;
        const bc = Date.parse(b.created_at || '') || 0;
        if (bc !== ac) return bc - ac;

        return (Number(b.id) || 0) - (Number(a.id) || 0);
      }
      function normalizeScore(v) {
        if (!v || typeof v !== 'object') return 0;
        const kills = Number(v.kills) | 0;
        const timeSeconds = +Number(v.time_seconds).toFixed(1);
        if (kills < 0 || !Number.isFinite(timeSeconds) || timeSeconds < 0) return 0;
        return { kills, time_seconds: timeSeconds };
      }
      function isBetterScore(a, b) {
        if (!a) return 0;
        if (!b) return 1;
        if (a.kills !== b.kills) return a.kills > b.kills;
        return a.time_seconds < b.time_seconds;
      }
      function sameScore(a, b) {
        return !!(a && b && a.kills === b.kills && a.time_seconds === b.time_seconds);
      }
      function getSavedScore(k) {
        const v = lsGetJson(k);
        return normalizeScore(v);
      }
      function setSavedScore(k, v) {
        if (!v) return;
        lsSet(k, JSON.stringify(v));
      }
      function clearSavedScore(k) { try { localStorage.removeItem(k) } catch { } }
      function makeGuestName() {
        let id = lsGet(LB_GUEST_ID_KEY).trim().toLowerCase();
        if (!/^[a-z0-9]{4,12}$/.test(id)) {
          id = Math.random().toString(36).slice(2, 8);
          lsSet(LB_GUEST_ID_KEY, id);
        }
        return 'player-' + id;
      }
      function recordBestLocalScore() {
        const run = normalizeScore({ kills: g.kills | 0, time_seconds: +g.time.toFixed(1) });
        if (!run) return 0;
        const saved = getSavedScore(LB_BEST_SCORE_KEY);
        if (!saved || isBetterScore(run, saved)) setSavedScore(LB_BEST_SCORE_KEY, run);
        return run;
      }
      function getLbName() {
        let n = lsGet(LB_NAME_KEY).trim();
        if (validLbName(n)) return n;
        const raw = prompt('Enter a name for global leaderboard (1-24 chars).');
        if (raw != null) {
          n = raw.trim();
          if (validLbName(n)) {
            lsSet(LB_NAME_KEY, n);
            return n;
          }
          alert('Name must be 1-24 chars and only letters, numbers, spaces, _, ., or -. Using a guest name for now.');
        }
        n = makeGuestName();
        lsSet(LB_NAME_KEY, n);
        return n;
      }
      function wantsLb() {
        if (!LB_URL || !LB_KEY || !LB_TABLE) return 0;
        if (lsGet(LB_OPTIN_KEY) !== 'yes') lsSet(LB_OPTIN_KEY, 'yes');
        return 1;
      }
      async function fetchLeaderboardPreview(force) {
        if (!LB_URL || !LB_KEY || !LB_TABLE) return;
        const now = Date.now();
        if (!force && now - g.lbFetchT < 8000) return;
        g.lbFetchT = now;
        g.lbTopErr = '';
        try {
          // Fetch more rows to allow for deduplication
          const q = '?select=id,name,kills,time_seconds,created_at&order=kills.desc,time_seconds.asc,created_at.desc,id.desc&limit=100';
          const res = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE) + q, {
            headers: {
              apikey: LB_KEY,
              Authorization: 'Bearer ' + LB_KEY
            }
          });
          if (!res.ok) { g.lbTopErr = 'leaderboard unavailable'; return; }
          const rows = await res.json();

          const sorted = Array.isArray(rows) ? rows.slice().sort(compareLeaderboardRows) : [];
          g.lbTop = sorted.slice(0, LB_PREVIEW_LIMIT);
        } catch {
          g.lbTopErr = 'leaderboard unavailable';
        }
      }
      async function fetchOwnRankPreview(force) {
        if (!LB_URL || !LB_KEY || !LB_TABLE) return;
        const now = Date.now();
        if (!force && now - g.lbRankFetchT < 8000) return;
        g.lbRankFetchT = now;
        g.lbRankErr = '';
        const last = lsGetJson(LB_ENTRY_KEY);
        if (!last || !last.id) { g.lbRankText = 'submit once to track your rank'; return; }
        try {
          const ownRes = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE) + '?select=id,name,kills,time_seconds&id=eq.' + last.id + '&limit=1', {
            headers: { apikey: LB_KEY, Authorization: 'Bearer ' + LB_KEY }
          });
          if (!ownRes.ok) { g.lbRankErr = 'rank unavailable'; return; }
          const ownRows = await ownRes.json();
          if (!Array.isArray(ownRows) || !ownRows.length) { g.lbRankText = 'score syncing...'; return; }
          const own = ownRows[0];
          async function countWhere(q) {
            const res = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE) + '?select=id&' + q, {
              method: 'HEAD',
              headers: { apikey: LB_KEY, Authorization: 'Bearer ' + LB_KEY, Prefer: 'count=exact' }
            });
            if (!res.ok) throw new Error('count failed');
            return parseCount(res.headers.get('content-range'));
          }
          const a = await countWhere('kills=gt.' + own.kills);
          const b = await countWhere('kills=eq.' + own.kills + '&time_seconds=lt.' + own.time_seconds);
          const c = await countWhere('kills=eq.' + own.kills + '&time_seconds=eq.' + own.time_seconds + '&id=lt.' + own.id);
          const rank = a + b + c + 1;
          g.lbRankText = 'your rank #' + rank + ' (' + own.kills + ' / ' + Number(own.time_seconds).toFixed(1) + 's)';
        } catch {
          g.lbRankErr = 'rank unavailable';
        }
      }
      async function submitLeaderboardScore() {
        if (g.lbSent) return;
        const now = Date.now();
        if (now < g.lbRetryAt) return;
        if (!wantsLb()) return;
        const name = getLbName();
        if (!name) return;
        const run = recordBestLocalScore() || normalizeScore({ kills: g.kills | 0, time_seconds: +g.time.toFixed(1) });
        if (!run) return;
        const savedBest = getSavedScore(LB_BEST_SCORE_KEY);
        const pending = getSavedScore(LB_PENDING_ENTRY_KEY);
        let best = savedBest && isBetterScore(savedBest, run) ? savedBest : run;
        if (pending && isBetterScore(pending, best)) best = pending;
        const lastSynced = getSavedScore(LB_LAST_SYNCED_SCORE_KEY);
        if (!pending && sameScore(lastSynced, best)) return;
        setSavedScore(LB_PENDING_ENTRY_KEY, best);
        const payload = { name, kills: best.kills, time_seconds: best.time_seconds };
        g.lbSent = 1;
        try {
          let res = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              apikey: LB_KEY,
              Authorization: 'Bearer ' + LB_KEY,
              Prefer: 'return=representation'
            },
            body: JSON.stringify([payload])
          });
          if (res.ok) {
            const rows = await res.json(), row = Array.isArray(rows) ? rows[0] : 0;
            if (row && row.id) lsSet(LB_ENTRY_KEY, JSON.stringify({ id: row.id, name: row.name, kills: row.kills, time_seconds: row.time_seconds }));
            setSavedScore(LB_LAST_SYNCED_SCORE_KEY, best);
            clearSavedScore(LB_PENDING_ENTRY_KEY);
            g.lbRetryAt = 0;
            void fetchLeaderboardPreview(1);
            void fetchOwnRankPreview(1);
            return;
          }

          // Fallback: some Supabase policies allow insert but disallow returning row payload.
          // Retry with return=minimal so score still gets submitted.
          res = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE), {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              apikey: LB_KEY,
              Authorization: 'Bearer ' + LB_KEY,
              Prefer: 'return=minimal'
            },
            body: JSON.stringify([payload])
          });
          if (!res.ok) {
            g.lbSent = 0;
            g.lbRetryAt = Date.now() + 5000;
            return;
          }
          try {
            const q = '?select=id,name,kills,time_seconds&name=eq.' + encodeURIComponent(name)
              + '&kills=eq.' + best.kills
              + '&time_seconds=eq.' + best.time_seconds
              + '&order=id.desc&limit=1';
            const rowRes = await fetch(LB_URL + '/rest/v1/' + encodeURIComponent(LB_TABLE) + q, {
              headers: { apikey: LB_KEY, Authorization: 'Bearer ' + LB_KEY }
            });
            if (rowRes.ok) {
              const rows = await rowRes.json(), row = Array.isArray(rows) ? rows[0] : 0;
              if (row && row.id) lsSet(LB_ENTRY_KEY, JSON.stringify({ id: row.id, name: row.name, kills: row.kills, time_seconds: row.time_seconds }));
            }
          } catch { }
          setSavedScore(LB_LAST_SYNCED_SCORE_KEY, best);
          clearSavedScore(LB_PENDING_ENTRY_KEY);
          g.lbRetryAt = 0;
          g.lbRankText = 'score submitted; rank syncing...';
          void fetchLeaderboardPreview(1);
          void fetchOwnRankPreview(1);
        } catch {
          g.lbSent = 0;
          g.lbRetryAt = Date.now() + 5000;
        }
      }

      const p = { x: 260, y: MAP_H * .5, vx: 0, vy: 0, r: 15, hp: 100, maxHp: 100, speed: 192, fireCd: 0, fireRate: .46, dmg: 12, range: 400, shots: 1, magnet: 88, face: 1, rx: 0, ry: 0, flash: 0, gx: 1, gy: 0, zc: 0, zr: 0, zt: 0, zx: 1, zy: 0, zcd: 0, zDur: 1, zSpd: 2.1, zLoad: 1.5, zCool: 5.5, zDmg: 24, zDr: .55, zb: 0, zp: 0, mkOn: 0, mkT: 0, mkI: 8.8, mkS: 0, mkD: 14, mkR: 54, mkSl: .54, chDo: 14, chBurst: 10, chHeal: 8, chHealCd: 0, chHealI: .85, cat: 0, catM: 0, catType: 0, fb: 0, fbT: 0, fbI: 8.6, fbR: 210, fbFear: 2.3, fbKn: 320, fbFx: 0, fbTier: 0, fbMode: 1, fbAiT: 0, bot: 0, botCount: 0, botSlots: 0, bType: 0, bAtk: 1, bAuraR: 0, bAuraSl: 0, bHealCd: 0, bHealI: 10, bHealAmt: 10, bHealFx: 0, triA: 0, triFx: 0, slCharge: 0, slFocus: 0, slT: 0, slRecallT: 0, slLinkT: 0, slRecallPulse: 0, slCarryVx: 0, slCarryVy: 0, slPow: 0, slWave: 0, slComboFx: 0, slHitMask: 0, slPerfect: 0, slScale: 1, slDx: 1, slDy: 0, zoomShield: 0, bx: 0, by: 0, ba: 0, bcd: 0, bRate: 1.9, bDmg: 1.15, bRange: 480, bFetch: 95, bPull: 195, bCarry: 0, bCarryMax: 2, bGrabCd: 0, bGrabI: .38, bPier: 4, bSize: 6 };
      const keys = { l: 0, r: 0, u: 0, d: 0, gr: 0 };
      let touchId = -1, touchMove = 0;
      const joy = { x: 78, y: 0, r: 42, kr: 16, tx: 0, ty: 0, ax: 0, ay: 0, ttx: 0, tty: 0, tax: 0, tay: 0, show: 0, act: 0 };

      const z = [];      // zombies
      const b = [];      // bullets
      const food = [];   // xp drops and static mints
      const pudd = [];   // territory puddles
      const fx = [];     // particles/text dots
      const bots = [];   // companion bot states
      const react = [];  // fused reaction puddles
      const psyFx = [];  // psych combo effects
      const decoy = { on: 0, x: 0, y: 0, t: 0, d: 0, pop: 0 };

      function rnd(a, b) { return a + Math.random() * (b - a) }
      function clamp(v, a, b) { return v < a ? a : v > b ? b : v }
      function segDist2(px, py, ax, ay, bx, by) {
        const dx = bx - ax, dy = by - ay, den = dx * dx + dy * dy || 1;
        let t = ((px - ax) * dx + (py - ay) * dy) / den;
        t = clamp(t, 0, 1);
        const cx = ax + dx * t, cy = ay + dy * t, ex = px - cx, ey = py - cy;
        return ex * ex + ey * ey;
      }
      function eob(t) { const c1 = 1.70158, c3 = c1 + 1, u = t - 1; return 1 + c3 * u * u * u + c1 * u * u }
      function rr(px, py, pw, ph, pr) {
        const r = Math.max(0, Math.min(pr, Math.min(pw, ph) * .5));
        x.beginPath();
        x.moveTo(px + r, py);
        x.lineTo(px + pw - r, py);
        x.quadraticCurveTo(px + pw, py, px + pw, py + r);
        x.lineTo(px + pw, py + ph - r);
        x.quadraticCurveTo(px + pw, py + ph, px + pw - r, py + ph);
        x.lineTo(px + r, py + ph);
        x.quadraticCurveTo(px, py + ph, px, py + ph - r);
        x.lineTo(px, py + r);
        x.quadraticCurveTo(px, py, px + r, py);
        x.closePath();
      }
      function getChoiceLayout() {
        const mobile = W < 560;
        const bw = mobile ? W - 14 : Math.min(W - 20, 620);
        const bh = mobile ? clamp(H * .48, 296, 390) : clamp(H * .4, 268, 340);
        const bx = (W - bw) * .5, by = H - bh - 12;
        const rects = [];
        if (mobile) {
          const gap = 8, cw = bw - 22, ch = Math.max(74, Math.min(100, (bh - 84 - gap * 2) / 3));
          const sy = by + 50;
          for (let i = 0; i < 3; i++)rects.push({ x: bx + 14, y: sy + i * (ch + gap), w: cw, h: ch });
        } else {
          const gap = 10, cw = (bw - 32 - gap * 2) / 3, ch = Math.max(102, Math.min(130, bh - 82));
          const sy = by + 52;
          for (let i = 0; i < 3; i++)rects.push({ x: bx + 16 + i * (cw + gap), y: sy, w: cw, h: ch });
        }
        return { mobile, bx, by, bw, bh, rects };
      }
      function drawWrap(txt, px, py, maxW, lineH, maxLines) {
        const ws = txt.split(' ');
        let line = '', row = 0;
        for (let i = 0; i < ws.length; i++) {
          const test = line ? line + ' ' + ws[i] : ws[i];
          if (x.measureText(test).width <= maxW) { line = test; continue; }
          x.fillText(line, px, py + row * lineH);
          row++;
          if (row >= maxLines) return;
          line = ws[i];
        }
        if (row < maxLines && line) x.fillText(line, px, py + row * lineH);
      }
      function fitText(txt, maxW) {
        let out = String(txt ?? '');
        if (maxW <= 0) return '';
        if (x.measureText(out).width <= maxW) return out;
        while (out.length > 1 && x.measureText(out + '...').width > maxW) out = out.slice(0, -1);
        return out + '...';
      }
      function upIcon(n) {
        if (n.includes('Buddy') || n.includes('Bot')) return 'ü§ñ';
        if (n.includes('Catalyst') || n.includes('Chemical') || n.includes('Acidic')) return 'üß™';
        if (n.includes('Heal') || n.includes('Tough')) return '‚ù§Ô∏è';
        if (n.includes('Shock') || n.includes('Zoomies') || n.includes('Rapid') || n.includes('Speed')) return '‚ö°';
        if (n.includes('Magnet')) return 'üß≤';
        if (n.includes('Shot')) return 'üéØ';
        if (n.includes('Territory') || n.includes('Puddle') || n.includes('Gravity')) return 'üíß';
        if (n.includes('Bite')) return 'ü¶¥';
        return 'üõ†Ô∏è';
      }
      function school(id) { for (let i = 0; i < SAFE_BUILDINGS.length; i++)if (SAFE_BUILDINGS[i].id === id) return SAFE_BUILDINGS[i]; return 0 }
      function safeBuildingAt(px, py, pad) {
        const extra = pad || 0;
        for (let i = 0; i < SAFE_BUILDINGS.length; i++) {
          const b = SAFE_BUILDINGS[i], dx = px - b.x, dy = py - b.y;
          if (dx * dx + dy * dy < (b.r + extra) * (b.r + extra)) return b;
        }
        return 0;
      }
      function pushOutsideSafe(o, pad) {
        const extra = pad || 0;
        let hit = 0;
        for (let i = 0; i < SAFE_BUILDINGS.length; i++) {
          const b = SAFE_BUILDINGS[i];
          let dx = o.x - b.x, dy = o.y - b.y, ln = Math.hypot(dx, dy) || 1;
          const rr = b.r + extra;
          if (ln < rr) {
            if (ln < .001) { const a = Math.random() * Math.PI * 2; dx = Math.cos(a); dy = Math.sin(a); ln = 1; }
            o.x = b.x + dx / ln * rr;
            o.y = b.y + dy / ln * rr;
            hit = 1;
          }
        }
        return hit;
      }
      function puzzleLayout() {
        const bw = Math.min(W - 24, 420), bh = Math.min(H - 130, 260);
        const bx = (W - bw) * .5, by = (H - bh) * .5 + 24;
        const gap = 10, bw3 = (bw - 36 - gap * 2) / 3, by2 = by + bh - 72;
        return {
          bx, by, bw, bh,
          btn: [
            { x: bx + 18, y: by2, w: bw3, h: 46 },
            { x: bx + 18 + bw3 + gap, y: by2, w: bw3, h: 46 },
            { x: bx + 18 + (bw3 + gap) * 2, y: by2, w: bw3, h: 46 }
          ]
        };
      }
      function puzzleSeq(len) {
        const seq = [];
        let prev = -1;
        for (let i = 0; i < len; i++) {
          let n = (Math.random() * 3) | 0;
          if (n === prev) n = (n + 1 + ((Math.random() * 2) | 0)) % 3;
          seq.push(n);
          prev = n;
        }
        return seq;
      }
      function startPuzzle(id, mode) {
        if (g.pz) return;
        if (mode === 'lab' && id === 'nsh') {
          const tier = ((g.labNshRuns / 2) | 0) + 1;
          const len = 4 + Math.min(2, tier - 1);
          g.pz = { id: 'nsh', seq: puzzleSeq(len), step: 0, lab: 1, trial: g.labNshRuns + 1, tier };
          g.msg = 'research'; g.msgT = 1.2;
        } else if (mode === 'lab' && id === 'mel') {
          const tier = ((g.labMelRuns / 2) | 0) + 1;
          const len = 5 + Math.min(2, tier - 1);
          g.pz = { id: 'mel', seq: puzzleSeq(len), step: 0, lab: 1, trial: g.labMelRuns + 1, tier };
          g.msg = 'research'; g.msgT = 1.2;
        } else if (id === 'nsh') {
          g.pz = { id: 'nsh', seq: puzzleSeq(3), step: 0 };
          g.msg = 'research'; g.msgT = 1.2;
        } else if (id === 'mel') {
          g.pz = { id: 'mel', seq: puzzleSeq(4), step: 0 };
          g.msg = 'research'; g.msgT = 1.2;
        } else if (id === 'bak') {
          g.pz = { id: 'bak', lane: -1, wT: 1, wMax: 1, hit: 0, need: 7, miss: 0, maxMiss: 3 };
          resetBakerPuzzle(g.pz);
          g.msg = 'calm panic waves'; g.msgT = 1.25;
        }
      }
      function nextBakerWave(z2) {
        const prev = (z2.lane | 0);
        let lane = (Math.random() * 3) | 0;
        if (prev >= 0 && lane === prev) lane = (lane + 1 + ((Math.random() * 2) | 0)) % 3;
        z2.lane = lane;
        const speed = 1.16 - Math.min(.42, (z2.hit || 0) * .043);
        z2.wMax = Math.max(.55, speed);
        z2.wT = z2.wMax;
      }
      function resetBakerPuzzle(z2) {
        z2.hit = 0;
        z2.miss = 0;
        nextBakerWave(z2);
      }
      function stepBakerPuzzle(dt) {
        if (!g.pz || g.pz.id !== 'bak') return;
        const z2 = g.pz;
        z2.wT -= dt;
        if (z2.wT > 0) return;
        z2.miss++;
        trauma(.03);
        beep(170, .05, 'sawtooth', .016);
        if (z2.miss >= z2.maxMiss) {
          g.msg = 'panic spike: reset';
          g.msgT = .9;
          resetBakerPuzzle(z2);
          return;
        }
        g.msg = 'panic rising';
        g.msgT = .6;
        nextBakerWave(z2);
      }
      function puzzleInput(n) {
        if (!g.pz) return;
        const z2 = g.pz;
        if (z2.id === 'bak') {
          if (n === z2.lane) {
            const phase = 1 - z2.wT / Math.max(.001, z2.wMax);
            z2.hit++;
            const perfect = phase > .42 && phase < .72;
            if (perfect) {
              burst(p.x, p.y, '#9ed9ff', 7, 56);
              beep(920, .04, 'triangle', .02);
            } else {
              beep(640, .04, 'triangle', .016);
            }
            if (z2.hit >= z2.need) {
              g.pz = 0;
              unlockSchool('bak');
              return;
            }
            nextBakerWave(z2);
          } else {
            z2.miss++;
            trauma(.03);
            beep(180, .05, 'square', .019);
            if (z2.miss >= z2.maxMiss) {
              g.msg = 'panic spike: reset';
              g.msgT = .9;
              resetBakerPuzzle(z2);
            } else {
              g.msg = 'wrong door';
              g.msgT = .5;
              nextBakerWave(z2);
            }
          }
          return;
        }
        const ok = n === z2.seq[z2.step];
        if (ok) {
          z2.step++;
          beep(620 + z2.step * 70, .04, 'triangle', .018);
          if (z2.step >= z2.seq.length) {
            const id = z2.id;
            g.pz = 0;
            unlockSchool(id);
            if (z2.lab) {
              if (id === 'nsh') g.labNshRuns++;
              else if (id === 'mel') g.labMelRuns++;
            }
          }
        } else {
          z2.step = 0;
          trauma(.03);
          beep(180, .06, 'square', .02);
          g.msg = 'retry'; g.msgT = .55;
        }
      }
      let dogAudio = new Audio('sound/whatthedogdoing.mp3');
      function beginSchool(id) {
        if (Math.random() < 0.55) {
          dogAudio.volume = 0.33;
          dogAudio.play().catch(() => { });
        }
        if (id === 'nsh' && g.sch.nsh === 0) {
          g.sch.nsh = 1; playMeme(); startPuzzle('nsh');
          g.msg = 'help'; g.msgT = 1.4; beep(640, .05, 'triangle', .02);
        } else if (id === 'mel' && g.sch.mel === 0) {
          g.sch.mel = 1; playMeme(); startPuzzle('mel');
          g.msg = 'help'; g.msgT = 1.4; beep(680, .05, 'triangle', .02);
        } else if (id === 'bak' && g.sch.bak === 0) {
          g.sch.bak = 1; playMeme(); startPuzzle('bak');
          g.msg = 'baker needs calming support'; g.msgT = 1.5; beep(700, .05, 'triangle', .02);
        }
      }
      function unlockSchool(id) {
        if (id === 'nsh' && g.sch.nsh !== 2) {
          g.sch.nsh = 2; queueUnlock('nsh');
          g.msg = 'nsh'; g.msgT = 2.1; trauma(.12); burst(p.x, p.y, '#79d7ff', 16, 95); beep(760, .07, 'square', .024);
        } else if (id === 'nsh' && g.labNsh > 0) {
          g.labNsh--;
          queueUnlock('nsh');
          g.msg = 'nsh prototype ready';
          g.msgT = 1.8;
          trauma(.12);
          burst(p.x, p.y, '#9de6ff', 12, 72);
          beep(740, .06, 'triangle', .022);
        } else if (id === 'mel' && g.sch.mel !== 2) {
          g.sch.mel = 2; queueUnlock('mel');
          g.msg = 'mel'; g.msgT = 2.1; trauma(.12); burst(p.x, p.y, '#ffd58f', 16, 95); beep(720, .07, 'square', .024);
        } else if (id === 'mel' && g.labMel > 0) {
          g.labMel--;
          queueUnlock('mel');
          g.msg = 'mellon prototype ready';
          g.msgT = 1.8;
          trauma(.12);
          burst(p.x, p.y, '#b6ef9d', 12, 72);
          beep(720, .06, 'triangle', .022);
        } else if (id === 'bak' && g.sch.bak !== 2) {
          g.sch.bak = 2; queueUnlock('bak');
          g.msg = 'baker'; g.msgT = 2.1; trauma(.14); burst(p.x, p.y, '#9ec8ff', 18, 106); beep(780, .07, 'square', .024);
        } else if (id === 'bak' && g.labBak > 0) {
          g.labBak--;
          queueUnlock('bak');
          g.msg = 'baker psych prototype ready';
          g.msgT = 1.8;
          trauma(.12);
          burst(p.x, p.y, '#b7d6ff', 12, 76);
          beep(760, .06, 'triangle', .022);
        }
        queueLabMilestoneRewards();
        queueBakerPsychUnlocks();
        g.labCd = 3;
      }
      function chemLabel() {
        const n = knownVariants(g.chemMask);
        if (n >= 3) return 'triple burst';
        if (n === 2) return 'dual burst';
        if (g.chemMask & 1) return 'acid';
        if (g.chemMask & 2) return 'heal';
        if (g.chemMask & 4) return 'grav';
        return 'chem';
      }
      function chemColor() {
        const n = knownVariants(g.chemMask);
        if (n >= 3) return '#5ccba0';
        if (n === 2) return '#7ae88a';
        if (g.chemMask & 1) return '#8fdd73';
        if (g.chemMask & 2) return '#7ad8cd';
        if (g.chemMask & 4) return '#8fb6ff';
        return '#f4d96e';
      }
      function unlockFocusBark() {
        p.fb = 1;
        p.fbT = 0;
        p.fbFx = 0;
        p.fbMode = 1;
        p.fbAiT = 0;
        decoy.on = 0;
        decoy.t = 0;
        decoy.pop = 0;
      }
      function isBossType(k) {
        return k === 3 || k === 4 || k === 5 || k === 9 || k === 11;
      }
      function psychName(t) {
        return t === 3 ? 'cognitive freeze' : t === 2 ? 'decoy scotty' : 'command bark';
      }
      function psychHudTag(t) {
        return t === 3 ? 'freeze' : t === 2 ? 'mirror' : 'bark';
      }
      function psychVariantCap() {
        if (g.sch.bak !== 2) return 0;
        let cap = 1;
        if (g.kills >= BAK_SECOND_BARK_KILLS || g.mbd || g.bs || g.bd || g.bs2 || g.bd2) cap = 2;
        if (g.kills >= BAK_THIRD_BARK_KILLS || g.bs2 || g.bd2) cap = 3;
        return cap;
      }
      function queueBakerPsychUnlocks() {
        if (g.sch.bak !== 2) return;
        const cap = psychVariantCap();
        if (cap <= 0) return;
        const queued = g.uq.indexOf('bak') >= 0 ? 1 : 0;
        const known = knownVariants(g.psyMask);
        let prog = known + queued + g.labBak;
        while (prog < cap) {
          g.labBak++;
          prog++;
          g.msg = 'baker: psych bench ready';
          g.msgT = 1.4;
          beep(700, .045, 'triangle', .019);
        }
      }
      function psychComboName(k) {
        return k === 1 ? 'snaplane' : k === 2 ? 'whiplash rail' : 'trance pool';
      }
      function pushPsychFx(v) {
        if (psyFx.length >= MAX_PSYFX) psyFx.shift();
        psyFx.push(v);
      }
      function addPsychCombo(k, px, py, dx, dy) {
        const ln = Math.hypot(dx, dy) || 1, ux = dx / ln, uy = dy / ln;
        if (k === 3) {
          pushPsychFx({ k, x: px, y: py, r: 136, t: 2.9, d: 2.9 });
          burst(px, py, '#a0ffd7', 12, 88);
        } else if (k === 2) {
          pushPsychFx({ k, x: px, y: py, dx: ux, dy: uy, len: 220, w: 44, t: 2.2, d: 2.2 });
          burst(px, py, '#bde8ff', 14, 96);
        } else {
          pushPsychFx({ k, x: px, y: py, dx: ux, dy: uy, len: 250, w: 56, t: 2.4, d: 2.4 });
          burst(px, py, '#9ed9ff', 12, 84);
        }
        g.msg = psychComboName(k);
        g.msgT = .9;
        beep(k === 2 ? 860 : k === 3 ? 680 : 760, .05, 'triangle', .02);
      }
      function applyPsychMark(m, bit, dur) {
        const before = ((m.psJ || 0) > 0 ? 1 : 0) | ((m.psF || 0) > 0 ? 2 : 0) | ((m.psD || 0) > 0 ? 4 : 0);
        if (bit === 1) m.psJ = Math.max(m.psJ || 0, dur);
        else if (bit === 2) m.psF = Math.max(m.psF || 0, dur);
        else m.psD = Math.max(m.psD || 0, dur);
        m.fb = Math.max(m.fb || 0, dur * .9);
        const after = ((m.psJ || 0) > 0 ? 1 : 0) | ((m.psF || 0) > 0 ? 2 : 0) | ((m.psD || 0) > 0 ? 4 : 0);
        if (after === before || isBossType(m.k) || (m.psComboCd || 0) > 0) return;
        let combo = 0;
        if ((after & 1) && (after & 2)) combo = 1;
        else if ((after & 1) && (after & 4)) combo = 2;
        else if ((after & 2) && (after & 4)) combo = 3;
        if (combo) {
          const dx = m.x - p.x, dy = m.y - p.y;
          addPsychCombo(combo, m.x, m.y, dx, dy);
          m.psComboCd = PSY_COMBO_CD;
        }
      }
      function autoFocusBark(dt) {
        if (!p.fb || p.fbT > 0 || !g.start || g.dead || g.lvup || g.pz) return 0;
        if (p.fbAiT > 0) { p.fbAiT = Math.max(0, p.fbAiT - dt); return 0; }
        p.fbAiT = PSY_AUTO_INTERVAL;
        const mask = g.psyMask || 1;
        const rr = Math.max(90, p.fbR * 1.06), rr2 = rr * rr;
        const midR = rr * 1.5, midR2 = midR * midR;
        let near = 0, close = 0, mid = 0, bossNear = 0;
        let q1 = 0, q2 = 0, q3 = 0, q4 = 0;
        for (let i = 0; i < z.length; i++) {
          const m = z[i], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
          if (d2 < rr2) {
            near++;
            if (isBossType(m.k)) bossNear++;
            if (dx >= 0 && dy >= 0) q1 = 1;
            else if (dx < 0 && dy >= 0) q2 = 1;
            else if (dx < 0 && dy < 0) q3 = 1;
            else q4 = 1;
          }
          const cr = m.r + p.r + 22;
          if (d2 < cr * cr) close++;
          if (d2 < midR2) mid++;
        }
        if (!near && mid < 4) return 0;
        const surround = q1 + q2 + q3 + q4;
        let mode = 0;
        if ((mask & 2) && (surround >= 3 || close >= 4 || (bossNear > 0 && close >= 1))) mode = 2;
        else if ((mask & 1) && (close >= 2 || near >= 5)) mode = 1;
        else if ((mask & 4) && (mid >= 6 || near >= 8)) mode = 3;
        else if (mask & 1) mode = 1;
        else if (mask & 2) mode = 2;
        else mode = 3;
        if (!(mask & (1 << (mode - 1)))) mode = (mask & 1) ? 1 : ((mask & 2) ? 2 : 3);
        return castFocusBark(mode, 1);
      }
      function castFocusBark(mode, auto) {
        if (!p.fb || p.fbT > 0 || !g.start || g.dead || g.lvup || g.pz) return 0;
        const mask = g.psyMask || 1;
        let barkMode = mode || 1;
        if (!(mask & (1 << (barkMode - 1)))) barkMode = (mask & 1) ? 1 : ((mask & 2) ? 2 : 3);
        p.fbMode = barkMode;
        p.fbT = p.fbI;
        p.fbFx = .62;
        const markMul = clamp(p.fbFear / 2.3, .7, 2.2);
        if (barkMode === 2) {
          decoy.on = 1;
          decoy.x = clamp(p.x + p.gx * 62, 24, MAP_W - 24);
          decoy.y = clamp(p.y + p.gy * 62, 24, MAP_H - 24);
          decoy.t = PSY_DECOY_TIME;
          decoy.d = PSY_DECOY_TIME;
          decoy.pop = 0;
          trauma(.06);
          burst(decoy.x, decoy.y, '#9fe9ff', 10, 58);
          beep(560, .05, 'square', .022);
          beep(760, .04, 'triangle', .017);
          g.msg = psychName(barkMode);
          g.msgT = 1;
          return 0;
        }
        const rr = Math.max(82, p.fbR * (barkMode === 1 ? 1.02 : .95)), rr2 = rr * rr;
        let hit = 0;
        const hitCol = barkMode === 3 ? '#cabdff' : '#86ddff';
        for (let i = z.length - 1; i >= 0; i--) {
          const m = z[i], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
          if (d2 > rr2) continue;
          const d = Math.sqrt(d2) || 1, q = 1 - d / rr, boss = isBossType(m.k);
          let push = 0, dmg = 0;
          if (barkMode === 1) {
            const closeHit = d < rr * .38;
            push = (boss ? 135 : 220) + q * (boss ? 90 : 240) + p.fbKn * .18;
            m.fbSt = Math.max(m.fbSt || 0, closeHit ? (boss ? .22 : .45 + .26 * q) : (boss ? .14 : .24 + .14 * q));
            dmg = boss ? (2 + q * 3) : (8 + q * 12);
            applyPsychMark(m, 1, PSY_MARK_TIME * (.68 + .32 * q) * markMul);
          } else {
            push = (boss ? 75 : 120) + q * (boss ? 45 : 90) + p.fbKn * .08;
            m.fbSt = Math.max(m.fbSt || 0, boss ? .28 : .62 + .28 * q);
            dmg = boss ? (3 + q * 4) : (6 + q * 9);
            applyPsychMark(m, 4, PSY_MARK_TIME * (.74 + .26 * q) * markMul);
          }
          m.vx += dx / d * push;
          m.vy += dy / d * push;
          m.hp -= dmg;
          m.ht = Math.max(m.ht, .12);
          hit++;
          if (m.hp <= 0) {
            killZombie(i, hitCol, 8, barkMode === 3 ? 74 : 66, 1);
            continue;
          }
        }
        trauma(.13);
        hitStop(.03);
        if (barkMode === 3) {
          burst(p.x, p.y, '#c7bcff', 22, rr * .66);
          burst(p.x, p.y, '#eee6ff', 10, rr * .36);
          beep(430, .06, 'triangle', .024);
          beep(640, .05, 'sine', .018);
        } else {
          burst(p.x, p.y, '#8adfff', 20, rr * .54);
          burst(p.x, p.y, '#d9f5ff', 8, rr * .26);
          beep(560, .05, 'square', .022);
          beep(930, .04, 'triangle', .018);
        }
        g.msg = auto ? (psychName(barkMode) + (hit > 0 ? ' ' + hit : '')) : psychName(barkMode);
        g.msgT = 1;
        return hit;
      }
      function tickPsychDecoy(dt) {
        if (decoy.pop > 0) decoy.pop = Math.max(0, decoy.pop - dt);
        if (!decoy.on) return;
        decoy.t -= dt;
        if (decoy.t > 0) return;
        decoy.on = 0;
        decoy.t = 0;
        decoy.pop = .3;
        burst(decoy.x, decoy.y, '#9fe9ff', 6, 40);
        beep(700, .04, 'triangle', .014);
      }
      function botVariantCap() {
        if (g.sch.nsh !== 2) return 0;
        let cap = 1;
        if (g.mbd || g.bs || g.bd || g.bs2 || g.bd2) cap = 2;
        if (g.bs2 || g.bd2) cap = 3;
        return cap;
      }
      function chemVariantCap() {
        if (g.sch.mel !== 2) return 0;
        let cap = 1;
        if (g.bd || g.bs2 || g.bd2) cap = 2;
        if (g.bs2 || g.bd2) cap = 3;
        return cap;
      }
      function evacHotspot() {
        let target = 0, count = 0;
        for (let i = 0; i < SAFE_BUILDINGS.length; i++) {
          const s = SAFE_BUILDINGS[i];
          if (s.id === 'home') continue;
          const n = shelterThreatCount(s);
          if (n > count) { count = n; target = s; }
        }
        return { target, count };
      }
      function nearestEnemyNavTarget() {
        if (!z.length) return 0;
        let t = 0, bd = 1e18;
        for (let i = 0; i < z.length; i++) {
          const m = z[i], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
          if (d2 < bd) { bd = d2; t = m; }
        }
        if (!t) return 0;
        return { x: t.x, y: t.y, r: 22, c: '#ef6f7f', n: 'THREATS' };
      }
      function evacDirectiveText() {
        if (!z.length) return 'evac routes stable - scout schools for upgrades';
        const hot = evacHotspot();
        if (hot.target && hot.count >= SHELTER_MIN_THREAT) return 'clear evac path near ' + hot.target.n + ' - ' + hot.count + ' enemies pressuring';
        return 'clear routes and protect evac paths - ' + z.length + ' enemies active';
      }
      function evacNavTarget() {
        const hot = evacHotspot();
        if (hot.target && hot.count >= Math.max(3, SHELTER_MIN_THREAT - 1)) return hot.target;
        return nearestEnemyNavTarget();
      }
      function objectiveText() {
        if (!p.mkOn) return 'collect mints ' + g.homeGot + '/' + g.homeNeed + ' to unlock territory puddles';
        if (g.inB && g.safeCampT >= SHELTER_WARN && g.safeThreat >= SHELTER_MIN_THREAT) return 'shelter breached - move out and clear pressure';
        if (g.won) return 'CAMPUS SECURED - you did it!';
        if (g.moth) return 'defeat the mother to secure campus!';
        if (g.pred) return 'defeat the predator!';
        if (g.kills >= KILL_CAP) return 'clear remaining enemies! ' + z.length + ' left';
        if (g.pz && g.pz.id === 'nsh') return 'solve nsh lab sequence';
        if (g.pz && g.pz.id === 'mel') return 'solve mellon lab sequence';
        if (g.pz && g.pz.id === 'bak') return 'baker: calm panic waves';
        if (g.sch.nsh === 0) return 'reach nsh and request robotics support';
        if (g.sch.nsh === 1) return 'complete nsh puzzle to unlock first buddy';
        if (g.sch.mel === 0) return 'reach mellon institute and request catalyst support';
        if (g.sch.mel === 1) return 'complete mellon puzzle to unlock first catalyst';
        if (g.sch.bak === 0) {
          if (!g.mbd) return 'keep evac routes clear - eliminate threats';
          return 'reach baker hall and request psychology support';
        }
        if (g.sch.bak === 1) return 'baker: stabilize panic waves';
        if (g.bd2) {
          if (g.kills >= MOTHER_TRIGGER - 200) return 'WAVE ' + g.endWave + ' - ' + g.kills + '/' + MOTHER_TRIGGER + ' - something stirs...';
          if (g.endWave > 0) return 'WAVE ' + g.endWave + ' - ' + g.kills + '/' + MOTHER_TRIGGER + ' kills';
          return 'endless cleanup - ' + g.kills + '/' + MOTHER_TRIGGER + ' kills to final boss';
        }
        if (g.bs2 && knownVariants(g.chemMask) >= 3) return 'triple burst! overlap all 3 puddles to storm apex!';
        if (g.bs2) return 'defeat apex dean';
        if (g.bs) return 'defeat dean and keep evac mints out of his reach';
        if (g.mb) return 'defeat the provost!';
        const botKnown = knownVariants(g.botMask);
        const chemKnown = knownVariants(g.chemMask);
        const psyKnown = knownVariants(g.psyMask);
        if (g.sch.nsh === 2 && botKnown < botVariantCap()) {
          if (botVariantCap() === 2 && !g.mbd) return 'push midgame pressure to unlock buddy prototype tier 2';
          if (botVariantCap() === 3 && !g.bs2 && !g.bd2) return 'reach apex phase to unlock final buddy prototype';
          return 'visit nsh for buddy prototype trial';
        }
        if (g.sch.mel === 2 && chemKnown < chemVariantCap()) {
          if (chemVariantCap() === 2 && !g.bd) return 'take down dean to unlock catalyst tier 2';
          if (chemVariantCap() === 3 && !g.bs2 && !g.bd2) return 'reach apex phase to unlock final catalyst';
          return 'visit mellon institute for catalyst prototype trial';
        }
        if (g.sch.bak === 2 && psyKnown < psychVariantCap()) {
          if (psychVariantCap() === 2 && g.kills < BAK_SECOND_BARK_KILLS && !g.mbd) return 'stabilize pressure to unlock psych prototype tier 2';
          if (psychVariantCap() === 3 && g.kills < BAK_THIRD_BARK_KILLS && !g.bs2 && !g.bd2) return 'reach apex phase to unlock final psych prototype';
          if (g.labBak > 0) return 'visit baker hall for psych prototype trial';
          return 'baker psych prototypes calibrating';
        }
        const labReady = (g.labNsh > 0 ? 1 : 0) + (g.labMel > 0 ? 1 : 0) + (g.labBak > 0 ? 1 : 0);
        if (labReady > 1) return 'visit schools for prototype upgrades';
        if (g.labNsh > 0) return 'visit nsh for buddy prototype';
        if (g.labMel > 0) return 'visit mellon institute for catalyst prototype';
        if (g.labBak > 0) return 'visit baker hall for psych prototype trial';
        if (g.sch.nsh === 2 && g.sch.mel === 2 && g.sch.bak === 2 && !g.mb && !g.bs && !g.bd && !g.bs2 && !g.bd2) return evacDirectiveText();
        if (g.sch.bak === 2 && psyKnown > 0) return 'auto ' + psychName(p.fbMode) + ' - combos ready';
        if (g.bd && !g.bs2 && !g.bd2) {
          const eta = Math.max(0, g.b2At - g.t);
          return 'hold campus perimeter - apex eta ' + eta.toFixed(1) + 's';
        }
        return 'clear routes and protect evac paths - ' + g.kills + ' threats down';
      }
      function shelterThreatCount(safe) {
        if (!safe) return 0;
        const rr = safe.r + SHELTER_THREAT_RADIUS, rr2 = rr * rr;
        let n = 0;
        for (let i = 0; i < z.length; i++) {
          const m = z[i], dx = m.x - safe.x, dy = m.y - safe.y;
          if (dx * dx + dy * dy < rr2) n++;
        }
        return n;
      }
      function applyShelterPressure(safe, dt) {
        if (!safe) {
          g.safeCampT = 0;
          g.safeBreachCd = 0;
          g.safeThreat = 0;
          return;
        }
        g.safeCampT += dt;
        g.safeThreat = shelterThreatCount(safe);
        if (g.safeCampT < SHELTER_GRACE || g.safeThreat < SHELTER_MIN_THREAT) return;
        g.safeBreachCd -= dt;
        if (g.safeBreachCd > 0) return;
        const over = g.safeCampT - SHELTER_GRACE;
        const pressure = Math.max(0, g.safeThreat - SHELTER_MIN_THREAT);
        const dmg = 2.6 + Math.min(7.5, over * .35) + Math.min(5.5, pressure * .45);
        hitPlayer(dmg);
        g.safeBreachCd = SHELTER_PULSE;
        g.msg = 'shelter breached - move!';
        g.msgT = .65;
        burst(p.x, p.y, '#ef4f6c', 8, 55);
        beep(150, .04, 'sawtooth', .018);
      }
      function queueUnlock(id) {
        if (g.uq.indexOf(id) < 0) g.uq.push(id);
      }
      function knownVariants(mask) {
        return ((mask & 1) ? 1 : 0) + ((mask & 2) ? 1 : 0) + ((mask & 4) ? 1 : 0);
      }
      function zoomiesBusy() {
        return p.zt > 0 || p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0;
      }
      function scottyShielded() {
        return p.zt > 0;
      }
      function levelUiBlocked() {
        return zoomiesBusy() || g.lvGrace > 0;
      }
      function ownedBotTypes() {
        const out = [];
        for (let i = 1; i <= 3; i++)if (g.botMask & (1 << (i - 1))) out.push(i);
        return out;
      }
      const BOT_REF = { rate: 1.9, dmg: 1.15, range: 480, fetch: 95, pull: 195, carry: 2, grab: .38, pier: 4, size: 6, healI: 10, healAmt: 10 };
      const BOT_BASE = {
        1: { rate: 1.15, dmg: 1.6, range: 620, fetch: 72, pull: 150, carry: 1, grab: .42, pier: 5, size: 7.2, auraR: 0, auraSl: 0, healI: 0, healAmt: 0, pulse: 1, col: '#9de6ff', body: '#93d8ff', ring: '#d0efff' },
        2: { rate: 1.72, dmg: .95, range: 520, fetch: 118, pull: 198, carry: 2, grab: .34, pier: 0, size: 3.8, auraR: 0, auraSl: 0, healI: 8, healAmt: 18, pulse: 0, col: '#7ae8a3', body: '#74de95', ring: '#d9ffe5' },
        3: { rate: 2.85, dmg: .82, range: 390, fetch: 110, pull: 205, carry: 2, grab: .34, pier: 2, size: 8.5, auraR: 124, auraSl: .46, healI: 0, healAmt: 0, pulse: 1, kb: .35, col: '#ffd48c', body: '#ffd48c', ring: '#fff0c7' }
      };
      function botStats(t) {
        const b = BOT_BASE[t] || BOT_BASE[1];
        const carryBonus = Math.max(0, p.bCarryMax - BOT_REF.carry);
        return {
          rate: Math.max(.5, b.rate * (p.bRate / BOT_REF.rate)),
          dmg: b.dmg * (p.bDmg / BOT_REF.dmg),
          range: b.range * (p.bRange / BOT_REF.range),
          fetch: b.fetch * (p.bFetch / BOT_REF.fetch),
          pull: b.pull * (p.bPull / BOT_REF.pull),
          carry: Math.max(1, b.carry + carryBonus),
          grab: Math.max(.14, b.grab * (p.bGrabI / BOT_REF.grab)),
          pier: Math.max(0, Math.round(b.pier + (p.bPier - BOT_REF.pier))),
          size: Math.max(2.8, b.size * (p.bSize / BOT_REF.size)),
          auraR: b.auraR,
          auraSl: b.auraSl,
          healI: b.healI > 0 ? Math.max(1.9, b.healI * (p.bHealI / BOT_REF.healI)) : 0,
          healAmt: b.healAmt > 0 ? b.healAmt * (p.bHealAmt / BOT_REF.healAmt) : 0,
          pulse: b.pulse,
          kb: b.kb || 0,
          col: b.col,
          body: b.body,
          ring: b.ring
        };
      }
      function remainingVariants(mask) {
        const rem = [];
        for (let i = 1; i <= 3; i++)if (!(mask & (1 << (i - 1)))) rem.push(i);
        return rem;
      }
      function botName(t) {
        return t === 1 ? 'Volt Buddy' : t === 2 ? 'Medic Buddy' : 'Guard Buddy';
      }
      function chemName(t) {
        return t === 1 ? 'Acidic Puddle' : t === 2 ? 'Heal Puddle' : 'Gravity Puddle';
      }
      function botChoiceCard(t) {
        if (t === 1) return { n: 'Volt Buddy', d: 'striker bot: rapid shock pulses, low cargo', f: () => setBotVariant(1), bg: 'rgba(29,53,79,.96)', st: 'rgba(147,216,255,.88)', tx: '#f1f9ff', sub: '#b3d4ee' };
        if (t === 2) return { n: 'Medic Buddy', d: 'green rounds + heals Scotty every 8s', f: () => setBotVariant(2), bg: 'rgba(24,72,44,.96)', st: 'rgba(148,232,171,.9)', tx: '#e9ffef', sub: '#b9e5c6' };
        return { n: 'Guard Buddy', d: 'warden bot: slowing aura + sturdy pulse', f: () => setBotVariant(3), bg: 'rgba(73,50,27,.96)', st: 'rgba(255,205,138,.9)', tx: '#fff4df', sub: '#e6cda5' };
      }
      function chemChoiceCard(t) {
        if (t === 1) return { n: 'Acidic Puddle', d: 'corrosive zone: burst + damage over time', f: () => setChemVariant(1), bg: 'rgba(33,75,34,.96)', st: 'rgba(160,236,146,.88)', tx: '#edffe9', sub: '#bce2b3' };
        if (t === 2) return { n: 'Heal Puddle', d: 'restorative zone: heals Scotty while inside', f: () => setChemVariant(2), bg: 'rgba(22,79,72,.96)', st: 'rgba(151,242,228,.9)', tx: '#e8fffb', sub: '#b6e7df' };
        return { n: 'Gravity Puddle', d: 'black hole zone: drags enemies from far outside', f: () => setChemVariant(3), bg: 'rgba(30,45,86,.96)', st: 'rgba(156,190,255,.9)', tx: '#edf3ff', sub: '#bfd1f0' };
      }
      function psychChoiceCard(t) {
        if (t === 1) return { n: 'Command Bark', d: 'push + close stun, applies jolt mark', f: () => setPsychVariant(1), bg: 'rgba(34,67,94,.96)', st: 'rgba(158,214,255,.88)', tx: '#eef8ff', sub: '#c7def2' };
        if (t === 2) return { n: 'decoy scotty', d: 'spawns decoy taunt, applies fixate mark', f: () => setPsychVariant(2), bg: 'rgba(33,71,86,.96)', st: 'rgba(143,234,255,.88)', tx: '#ecfcff', sub: '#c0e8f2' };
        return { n: 'Cognitive Freeze', d: 'mind-wave slow lock, applies daze mark', f: () => setPsychVariant(3), bg: 'rgba(56,63,102,.96)', st: 'rgba(185,191,255,.88)', tx: '#f0f2ff', sub: '#ccd0f1' };
      }
      function queueLabMilestoneRewards() {
        while (g.kills >= (g.labStep + 1) * LAB_REFRESH_KILLS) {
          g.labStep++;
          g.labBank = Math.min(6, g.labBank + 1);
          g.msg = 'new prototype intel';
          g.msgT = 1.25;
          beep(620, .04, 'triangle', .018);
        }
        while (g.labBank > 0) {
          const nshQueued = g.uq.indexOf('nsh') >= 0 ? 1 : 0;
          const melQueued = g.uq.indexOf('mel') >= 0 ? 1 : 0;
          const nshKnown = knownVariants(g.botMask);
          const melKnown = knownVariants(g.chemMask);
          const nshCap = botVariantCap();
          const melCap = chemVariantCap();
          const nshProgress = nshKnown + g.labNsh + nshQueued;
          const melProgress = melKnown + g.labMel + melQueued;
          const nshNext = nshProgress + 1;
          const melNext = melProgress + 1;
          const nshCost = nshNext === 2 ? NSH_SECOND_BOT_INTEL_COST : NSH_THIRD_BOT_INTEL_COST;
          const melCost = melNext === 2 ? MEL_SECOND_PUDDLE_INTEL_COST : MEL_THIRD_PUDDLE_INTEL_COST;
          const needNsh = g.sch.nsh === 2 && nshKnown >= 1 && nshProgress < nshCap && g.labBank >= nshCost;
          const needMel = g.sch.mel === 2 && melKnown >= 1 && melProgress < melCap && g.labBank >= melCost;
          if (!needNsh && !needMel) break;
          let id = '';
          if (needNsh && needMel) { g.labFlip ^= 1; id = g.labFlip ? 'nsh' : 'mel'; }
          else id = needNsh ? 'nsh' : 'mel';
          if (id === 'nsh') {
            g.labNsh++;
            g.msg = 'nsh: prototype bench ready';
            g.msgT = 1.6;
            beep(700, .05, 'triangle', .02);
            g.labBank -= nshCost;
          } else {
            g.labMel++;
            g.msg = 'mellon: catalyst bench ready';
            g.msgT = 1.6;
            beep(680, .05, 'triangle', .02);
            g.labBank -= melCost;
          }
        }
        queueBakerPsychUnlocks();
      }
      function claimLabVisit(id) {
        if (g.lvup || g.pz || g.uq.length || g.labCd > 0) return;
        if (id === 'nsh' && g.labNsh > 0) {
          startPuzzle('nsh', 'lab');
          g.msg = 'nsh: run prototype trial';
          g.msgT = 1.35;
          beep(700, .05, 'triangle', .02);
        } else if (id === 'mel' && g.labMel > 0) {
          startPuzzle('mel', 'lab');
          g.msg = 'mellon: run prototype trial';
          g.msgT = 1.35;
          beep(680, .05, 'triangle', .02);
        } else if (id === 'bak' && g.labBak > 0) {
          startPuzzle('bak', 'lab');
          g.msg = 'baker: run psych trial';
          g.msgT = 1.35;
          beep(720, .05, 'triangle', .02);
        }
      }
      function syncBots() {
        const types = ownedBotTypes();
        const want = p.bot ? Math.max(1, Math.min(p.botCount | 0, types.length || 1)) : 0;
        while (bots.length < want) {
          const t = types[Math.min(types.length - 1, bots.length)] || 1;
          bots.push({ x: p.x, y: p.y, t, cd: rnd(.05, .3), grabCd: rnd(.03, .22), mcd: 0, slx: 0, sly: 0, vx: 0, vy: 0 });
        }
        while (bots.length > want) bots.pop();
        for (let i = 0; i < bots.length; i++)bots[i].t = types[Math.min(types.length - 1, i)] || bots[i].t || 1;
        if (p.botSlots !== want) {
          const rr = 40;
          for (let i = 0; i < bots.length; i++) {
            const a = p.ba + i * (Math.PI * 2 / Math.max(1, bots.length));
            bots[i].x = p.x + Math.cos(a) * rr;
            bots[i].y = p.y + Math.sin(a) * rr;
            bots[i].cd = rnd(.05, .3);
            bots[i].grabCd = rnd(.03, .22);
            bots[i].slx = 0;
            bots[i].sly = 0;
            bots[i].vx = 0;
            bots[i].vy = 0;
          }
          p.botSlots = want;
        }
        if (!bots.length) {
          p.bx = p.x + 20;
          p.by = p.y + 4;
          p.botSlots = 0;
        }
      }
      function setBotVariant(t) {
        const first = !p.bot;
        p.bot = 1; p.bType = t;
        p.bx = p.x + 20; p.by = p.y + 4; p.ba = 0;
        if (first) {
          p.bcd = .45; p.bRate = BOT_REF.rate; p.bDmg = BOT_REF.dmg; p.bRange = BOT_REF.range; p.bFetch = BOT_REF.fetch; p.bPull = BOT_REF.pull;
          p.bCarry = 0; p.bCarryMax = BOT_REF.carry; p.bGrabCd = 0; p.bGrabI = BOT_REF.grab; p.bPier = BOT_REF.pier; p.bSize = BOT_REF.size;
          p.bAtk = 1; p.bAuraR = 0; p.bAuraSl = 0; p.bHealCd = 0; p.bHealI = BOT_REF.healI; p.bHealAmt = BOT_REF.healAmt; p.bHealFx = 0;
        }
        g.botMask |= (1 << (t - 1));
        p.botCount = Math.max(1, knownVariants(g.botMask));
        syncBots();
        queueLabMilestoneRewards();
      }
      function setChemVariant(t) {
        p.cat = 1; p.catType = t; p.catM = 0;
        p.chDo = 14; p.chBurst = 10; p.chHeal = 8; p.chHealCd = 0; p.chHealI = .85;
        if (t === 1) {
          p.chDo = 20; p.chBurst = 13;
        } else if (t === 2) {
          p.chHeal = 10; p.chHealI = .85;
        } else {
          p.mkSl = Math.max(p.mkSl, .6);
        }
        g.chemMask |= (1 << (t - 1));
        queueLabMilestoneRewards();
      }
      function setPsychVariant(t) {
        const first = !p.fb;
        unlockFocusBark();
        if (first) {
          p.fbI = Math.min(p.fbI, 7.4);
          p.fbR = Math.max(p.fbR, 230);
          p.fbFear = Math.max(p.fbFear, 2.8);
          p.fbKn = Math.max(p.fbKn, 420);
        }
        g.psyMask |= (1 << (t - 1));
        p.fbMode = t;
        queueBakerPsychUnlocks();
      }
      function popUnlockBook() {
        if (g.lvup || g.dead || g.pz || !g.uq.length || levelUiBlocked()) return;
        const id = g.uq.shift();
        g.choices = [];
        if (id === 'nsh') {
          const rem = remainingVariants(g.botMask);
          if (rem.length === 1) {
            const t = rem[0];
            setBotVariant(t);
            g.msg = 'nsh: ' + botName(t) + ' calibrated';
            g.msgT = 1.6;
            burst(p.x, p.y, '#9de6ff', 14, 84);
            beep(760, .06, 'triangle', .025);
            return;
          }
          if (rem.length === 2) {
            g.choices = [
              botChoiceCard(rem[0]),
              botChoiceCard(rem[1]),
              { n: 'Wildcard Buddy', d: 'installs one of the remaining buddy prototypes', f: () => setBotVariant(rem[(Math.random() * rem.length) | 0]), bg: 'rgba(42,63,95,.96)', st: 'rgba(167,207,255,.86)', tx: '#eef7ff', sub: '#c3d8ef' }
            ];
          } else if (rem.length === 3) {
            g.choices = [botChoiceCard(1), botChoiceCard(2), botChoiceCard(3)];
          }
        } else if (id === 'mel') {
          const rem = remainingVariants(g.chemMask);
          if (rem.length === 1) {
            const t = rem[0];
            setChemVariant(t);
            g.msg = 'mellon: ' + chemName(t) + ' calibrated';
            g.msgT = 1.6;
            burst(p.x, p.y, '#b6ef9d', 14, 84);
            beep(740, .06, 'triangle', .025);
            return;
          }
          if (rem.length === 2) {
            g.choices = [
              chemChoiceCard(rem[0]),
              chemChoiceCard(rem[1]),
              { n: 'Wildcard Catalyst', d: 'mixes one of the remaining catalyst variants', f: () => setChemVariant(rem[(Math.random() * rem.length) | 0]), bg: 'rgba(38,76,56,.96)', st: 'rgba(159,236,184,.88)', tx: '#eaffef', sub: '#c2ebd0' }
            ];
          } else if (rem.length === 3) {
            g.choices = [chemChoiceCard(1), chemChoiceCard(2), chemChoiceCard(3)];
          }
        } else if (id === 'bak') {
          const rem = remainingVariants(g.psyMask);
          if (rem.length === 1) {
            const t = rem[0];
            setPsychVariant(t);
            g.msg = 'baker: ' + psychName(t) + ' online';
            g.msgT = 1.6;
            burst(p.x, p.y, '#b7d6ff', 14, 88);
            beep(760, .06, 'triangle', .025);
            return;
          }
          if (rem.length === 2) {
            g.choices = [
              psychChoiceCard(rem[0]),
              psychChoiceCard(rem[1]),
              { n: 'Wildcard Psyche', d: 'installs one of the remaining psych prototypes', f: () => setPsychVariant(rem[(Math.random() * rem.length) | 0]), bg: 'rgba(46,64,98,.96)', st: 'rgba(174,199,255,.86)', tx: '#edf3ff', sub: '#c8d6ef' }
            ];
          } else if (rem.length === 3) {
            g.choices = [psychChoiceCard(1), psychChoiceCard(2), psychChoiceCard(3)];
          }
        }
        if (!g.choices.length) return;
        g.lvup = 1;
        g.cardT = 0;
        g.msg = 'up';
        g.msgT = 1.4;
        beep(760, .07, 'triangle', .028);
      }
      function trauma(v) { g.shake = clamp(g.shake + v, 0, 1.3) }
      function hitStop(v) { g.stop = Math.max(g.stop, v) }

      function resize() {
        DPR = Math.max(1, Math.min(2, devicePixelRatio || 1)); W = Math.max(320, innerWidth | 0); H = Math.max(560, innerHeight | 0); c.width = (W * DPR) | 0; c.height = (H * DPR) | 0; x.setTransform(DPR, 0, 0, DPR, 0, 0); x.imageSmoothingEnabled = false;
        const pad = joy.r + JOY_EDGE_PAD;
        if (joy.act) { joy.x = clamp(joy.x, pad, W - pad); joy.y = clamp(joy.y, pad, H - pad); }
        else { joy.x = 78; joy.y = H - 88; }
      }
      function joyStart(cx, cy) {
        const pad = joy.r + JOY_EDGE_PAD;
        joy.x = clamp(cx, pad, W - pad);
        joy.y = clamp(cy, pad, H - pad);
        joy.tx = 0; joy.ty = 0; joy.ax = 0; joy.ay = 0;
        joy.ttx = 0; joy.tty = 0; joy.tax = 0; joy.tay = 0;
        joy.act = 1;
      }
      function joySet(cx, cy) {
        let dx = cx - joy.x, dy = cy - joy.y;
        const ln = Math.hypot(dx, dy) || 1, m = joy.r;
        if (ln < JOY_CENTER_SNAP) { dx = 0; dy = 0; }
        else if (ln > m) { dx = dx / ln * m; dy = dy / ln * m }
        joy.ttx = dx; joy.tty = dy; joy.tax = dx / m; joy.tay = dy / m;
      }
      function joyTick(dt) {
        const s = 1 - Math.exp(-dt * JOY_SMOOTH), v = 1 - Math.exp(-dt * JOY_VIS_SMOOTH);
        joy.tx += (joy.ttx - joy.tx) * s; joy.ty += (joy.tty - joy.ty) * s;
        joy.ax += (joy.tax - joy.ax) * s; joy.ay += (joy.tay - joy.ay) * s;
        joy.show += ((joy.act ? 1 : 0) - joy.show) * v;
        if (!joy.act && joy.show < .003) joy.show = 0;
      }
      function joyReset(hard) {
        joy.act = 0;
        joy.ttx = 0; joy.tty = 0; joy.tax = 0; joy.tay = 0;
        if (hard) { joy.tx = 0; joy.ty = 0; joy.ax = 0; joy.ay = 0; joy.show = 0; }
      }

      function pushFx(v) { if (fx.length >= MAX_FX) return; fx.push(v) }
      function pushFood(v) {
        if (food.length >= MAX_FOOD) return;
        food.push(v);
      }
      function pushBullet(v) {
        if (b.length >= MAX_B) return;
        b.push(v);
      }
      function burst(px, py, col, n, s) {
        const q = z.length > 130 ? .5 : z.length > 90 ? .7 : 1;
        const cnt = Math.max(1, (n * q) | 0);
        for (let i = 0; i < cnt; i++) {
          const a = Math.random() * Math.PI * 2, sp = (s || 70) * (0.4 + Math.random());
          pushFx({ x: px, y: py, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, t: rnd(.2, .6), c: col });
        }
      }
      function killZombie(i, col, n, s, mode) {
        const m = z[i];
        const light = !!mode;
        // exploder death burst (k=6)
        if (m.k === 6) {
          const blastR = 72 + m.r * 1.8;
          const blastDmg = 8 + g.time * .18;
          const dx = p.x - m.x, dy = p.y - m.y, dl = Math.hypot(dx, dy);
          if (dl < blastR && !safeBuildingAt(p.x, p.y, -8)) {
            hitPlayer(blastDmg * (1 - dl / blastR));
            p.vx += dx / (dl || 1) * 180;
            p.vy += dy / (dl || 1) * 180;
          }
          burst(m.x, m.y, '#ff6644', 20, blastR);
          burst(m.x, m.y, '#ffaa44', 12, blastR * .65);
          trauma(.1);
          beep(180, .06, 'sawtooth', .02);
        }
        // predator kill -- advances game, not a win
        if (m.k === 9) {
          g.pred = 0; g.predDead = 1;
          g.msg = 'predator down!'; g.msgT = 2.2;
          g.b2At = g.t + 60;
          g.bossDownT = 2.0;
          hitStop(.1);
          trauma(.45);
          burst(m.x, m.y, '#ff2222', 30, 200);
          burst(m.x, m.y, '#ffa64d', 18, 140);
          beep(240, .1, 'sawtooth', .03);
          beep(380, .1, 'triangle', .022);
          // kill all remaining clones
          for (let j = z.length - 1; j >= 0; j--) {
            if (z[j].k === 10) { burst(z[j].x, z[j].y, '#882222', 8, 40); z.splice(j, 1); }
          }
        }
        // MOTHER kill = VICTORY
        if (m.k === 11) {
          g.moth = 0; g.mothDead = 1;
          g.won = 1;
          g.msg = 'CAMPUS SECURED'; g.msgT = 999;
          g.bossDownT = 5;
          hitStop(.15);
          trauma(.7);
          burst(m.x, m.y, '#ff44ff', 60, 360);
          burst(m.x, m.y, '#ffd56d', 50, 300);
          burst(m.x, m.y, '#69f0c9', 40, 250);
          burst(m.x, m.y, '#8ec0ff', 30, 200);
          beep(440, .22, 'triangle', .035);
          beep(554, .2, 'triangle', .03);
          beep(659, .24, 'triangle', .035);
          beep(880, .3, 'triangle', .03);
          // kill all adds she spawned
          for (let j = z.length - 1; j >= 0; j--) {
            if (z[j].k === 12) { burst(z[j].x, z[j].y, '#662266', 6, 34); z.splice(j, 1); }
          }
          void fetchLeaderboardPreview(1);
          void fetchOwnRankPreview(1);
          void submitLeaderboardScore();
        }
        // shadow clone despawn (k=10) -- no special handler, just dies normally
        // mini-boss kill
        if (m.k === 5) {
          g.mb = 0; g.mbd = 1;
          g.msg = 'the provost is down!'; g.msgT = 2.0;
          g.bossDownT = 1.6;
          hitStop(.08);
          trauma(.4);
          burst(m.x, m.y, '#ffa64d', 36, 190);
          burst(m.x, m.y, '#ffe0a0', 20, 130);
          beep(240, .1, 'sawtooth', .03);
          beep(380, .1, 'triangle', .02);
        }
        if (m.k === 3) {
          g.bd = 1; g.bs = 0; g.b2At = g.t + APEX_ARRIVAL_DELAY;
          g.apWarn1 = 0; g.apWarn2 = 0; g.apStormHitCd = 0;
          const eats = m.b1Eat || 0;
          g.msg = eats > 8 ? 'the dean falls... stuffed with ' + eats + ' mints' : 'the dean is defeated!';
          g.msgT = 2.4;
          g.bossDownT = 2.4;
          hitStop(.12);
          trauma(.6);
          burst(m.x, m.y, '#ffe38f', 48, 240);
          burst(m.x, m.y, '#a789ff', 30, 180);
          if (eats > 4) burst(m.x, m.y, '#69f0c9', 20, 160);
          beep(200, .12, 'sawtooth', .038);
          beep(320, .12, 'triangle', .024);
          beep(500, .14, 'square', .02);
        }
        else if (m.k === 4) {
          g.bd2 = 1; g.bs2 = 0;
          g.msg = 'APEX DOWN ‚Äî ENDLESS MODE BEGINS'; g.msgT = 2.8;
          g.endWave = 0; g.endT = 0; g.endSpawnT = 6;
          trauma(.42); hitStop(.08);
          burst(m.x, m.y, '#c8b6ff', 40, 260);
          burst(m.x, m.y, '#ffd56d', 24, 180);
          beep(210, .16, 'sawtooth', .04);
          beep(330, .12, 'triangle', .025);
        }
        g.kills++;
        g.spawnT = Math.min((g.spawnT || 0) + 0.08, 2.0); // spawn fatigue
        queueLabMilestoneRewards();
        if (!light) {
          hitStop(.03);
          trauma(.08);
          burst(m.x, m.y, col || '#ff9675', n || 9, s || 70);
          beep(280, .03, 'square', .012);
        } else {
          burst(m.x, m.y, col || '#ff9675', Math.max(2, ((n || 9) * .35) | 0), Math.max(20, (s || 70) * .6));
        }
        const dropRoom = MAX_FOOD - food.length;
        if (dropRoom > 0) {
          const drops = light ? (Math.random() < .25 ? 1 : 0) : (1 + (Math.random() < .4 ? 1 : 0));
          for (let k = 0; k < Math.min(drops, dropRoom); k++) {
            pushFood({ x: m.x + rnd(-7, 7), y: m.y + rnd(-7, 7), v: rnd(5, 8) | 0, m: 1, t: 0 });
          }
        }
        z.splice(i, 1);
      }
      function placeBurstPuddle(type) {
        if (pudd.length >= MAX_PUDD) pudd.shift();
        pudd.push({ x: p.x + p.gx * 4, y: p.y + 8, r: p.mkR, t: p.mkD, d: p.mkD, m: type });
        const label = type === 1 ? 'acid' : type === 2 ? 'heal' : type === 3 ? 'grav' : 'territory';
        const col = type === 1 ? '#8fdd73' : type === 2 ? '#7ad8cd' : type === 3 ? '#8fb6ff' : '#ffd56d';
        g.msg = label; g.msgT = .5;
        burst(p.x, p.y + 8, col, 8, 38);
        beep(type === 1 ? 540 : type === 2 ? 600 : type === 3 ? 480 : 560, .03, 'triangle', .018);
        hitStop(.015); trauma(.035);
      }
      function startBurst() {
        const types = [];
        if (p.cat) { for (let i = 1; i <= 3; i++)if (g.chemMask & (1 << (i - 1))) types.push(i); }
        if (!types.length) types.push(0);
        placeBurstPuddle(types[0]);
        p.mkS = .32;
        p.mkBurstQ = types.slice(1);
        p.mkBurst = p.mkBurstQ.length;
        p.mkBurstT = p.mkBurst > 0 ? .5 : 0;
        if (p.mkBurst <= 0) p.mkT = p.mkI;
      }
      function reactionNear(k, px, py, r) {
        for (let i = 0; i < react.length; i++) {
          const q = react[i], dx = px - q.x, dy = py - q.y;
          if (q.k === k && dx * dx + dy * dy < (r + q.r) * (r + q.r) * .22) return 1;
        }
        return 0;
      }
      function reactionMsg(k) {
        if (k === 1) return 'vortex: pull + melt';
        if (k === 2) return 'sanctuary: heal + slow';
        if (k === 3) return 'toxic bloom: chip + regen';
        return 'campus storm!';
      }
      function reactionColor(k) {
        if (k === 1) return '#95f0b8';
        if (k === 2) return '#89ffe8';
        if (k === 3) return '#ccff9b';
        return '#c8f3ff';
      }
      function addReaction(k, px, py, r, dur) {
        if (reactionNear(k, px, py, r)) return;
        if (react.length >= MAX_REACT) react.shift();
        react.push({ k, x: px, y: py, r, t: dur, d: dur, pcd: 0 });
        g.msg = reactionMsg(k);
        g.msgT = k === 4 ? 1.55 : 1.2;
        burst(px, py, reactionColor(k), k === 4 ? 24 : 14, k === 4 ? 126 : 84);
        beep(k === 4 ? 820 : k === 1 ? 700 : k === 2 ? 640 : 680, .06, 'triangle', .022);
      }
      function consumePuddles(a, b, c) {
        if (pudd[a]) pudd[a].t = Math.min(pudd[a].t, .05);
        if (pudd[b]) pudd[b].t = Math.min(pudd[b].t, .05);
        if (c !== undefined && pudd[c]) pudd[c].t = Math.min(pudd[c].t, .05);
      }
      function brewReactions() {
        const chem = [];
        for (let i = 0; i < pudd.length; i++) {
          const pd = pudd[i];
          if (pd.t > .08 && pd.m >= 1 && pd.m <= 3) chem.push(i);
        }
        if (chem.length < 2) return;
        if (g.stormCd <= 0 && chem.length >= 3) {
          for (let a = 0; a < chem.length - 2; a++) {
            const pa = pudd[chem[a]];
            for (let b = a + 1; b < chem.length - 1; b++) {
              const pb = pudd[chem[b]];
              for (let c = b + 1; c < chem.length; c++) {
                const pc = pudd[chem[c]];
                const mask = (1 << pa.m) | (1 << pb.m) | (1 << pc.m);
                if (mask !== 14) continue;
                const dab = Math.hypot(pa.x - pb.x, pa.y - pb.y), dbc = Math.hypot(pb.x - pc.x, pb.y - pc.y), dca = Math.hypot(pc.x - pa.x, pc.y - pa.y);
                if (dab > (pa.r + pb.r) * .8 || dbc > (pb.r + pc.r) * .8 || dca > (pc.r + pa.r) * .8) continue;
                const px = (pa.x + pb.x + pc.x) / 3, py = (pa.y + pb.y + pc.y) / 3;
                const rr = Math.min(152, (pa.r + pb.r + pc.r) / 3 + 36);
                addReaction(4, px, py, rr, 6);
                g.stormCd = 8;
                consumePuddles(chem[a], chem[b], chem[c]);
                for (let ri = react.length - 1; ri >= 0; ri--) {
                  const ar = react[ri];
                  if (ar.k === 5) {
                    const dd = Math.hypot(ar.x - px, ar.y - py);
                    if (dd < rr + ar.r + 80) { burst(ar.x, ar.y, '#8effdc', 12, 72); react.splice(ri, 1); }
                  }
                }
                for (let zi = z.length - 1; zi >= 0; zi--) {
                  const m = z[zi], dx = m.x - px, dy = m.y - py, d2 = dx * dx + dy * dy;
                  if (m.k === 4 && d2 < (rr * 1.8) * (rr * 1.8)) {
                    m.hp -= (p.chBurst * 4.5 + p.chDo * 3.5); m.ht = .3; m.s *= .45;
                    m.apStormCd = Math.max(m.apStormCd || 0, 4);
                    const ln2 = Math.hypot(dx, dy) || 1;
                    m.vx += dx / ln2 * 520; m.vy += dy / ln2 * 520;
                    burst(m.x, m.y, '#8effdc', 26, 160);
                    g.msg = 'campus storm: apex vulnerable!'; g.msgT = 1.8;
                    beep(860, .08, 'triangle', .03);
                    if (m.hp <= 0) { killZombie(zi, '#8effdc', 18, 130, 1); continue; }
                  }
                  if (d2 < rr * rr * 1.2) {
                    const ln = Math.hypot(dx, dy) || 1;
                    m.hp -= p.chBurst * 2.8 + p.chDo * 1.5; m.ht = .2;
                    m.vx += dx / ln * 360; m.vy += dy / ln * 360;
                    if (m.hp <= 0) killZombie(zi, '#c8f3ff', 12, 96, 1);
                  }
                }
                return;
              }
            }
          }
        }
        const used = {};
        for (let a = 0; a < chem.length - 1; a++) {
          const ia = chem[a]; if (used[ia]) continue;
          const pa = pudd[ia];
          for (let b = a + 1; b < chem.length; b++) {
            const ib = chem[b]; if (used[ib]) continue;
            const pb = pudd[ib];
            if (pa.m === pb.m) continue;
            const d = Math.hypot(pa.x - pb.x, pa.y - pb.y);
            if (d > (pa.r + pb.r) * .7) continue;
            const m1 = Math.min(pa.m, pb.m), m2 = Math.max(pa.m, pb.m);
            const k = (m1 === 1 && m2 === 3) ? 1 : (m1 === 2 && m2 === 3) ? 2 : 3;
            const px = (pa.x + pb.x) * .5, py = (pa.y + pb.y) * .5;
            const rr = Math.min(122, (pa.r + pb.r) * .44 + 18);
            const dur = k === 1 ? 5.4 : k === 2 ? 6.1 : 5.8;
            addReaction(k, px, py, rr, dur);
            // Keep acid pressure active in acid pair reactions: consume only the non-acid source.
            if (pa.m === 1 && pb.m !== 1) {
              if (pudd[ib]) pudd[ib].t = Math.min(pudd[ib].t, .05);
            } else if (pb.m === 1 && pa.m !== 1) {
              if (pudd[ia]) pudd[ia].t = Math.min(pudd[ia].t, .05);
            } else {
              consumePuddles(ia, ib);
            }
            used[ia] = 1; used[ib] = 1;
            break;
          }
        }
      }

      function togglePause() {
        if (!g.start || g.dead || g.lvup || !g.paused && g.pz) return;
        g.paused = g.paused ? 0 : 1;
        if (g.paused) {
          bgMusic.pause();
          beep(520, .04, 'triangle', .016);
        } else {
          if (g.musicStarted) bgMusic.play().catch(() => { });
          beep(620, .04, 'triangle', .018);
        }
      }

      function reset(full) {
        g.dead = 0; g.lvup = 0; g.t = 0; g.time = 0; g.spawnT = 0; g.nextSpawn = .8; g.kills = 0; g.msg = ''; g.msgT = 0; g.level = 1; g.xp = 0; g.nextXp = 24; g.stop = 0; g.shake = 0; g.xpPulse = 0; g.cardT = 0; g.choices = []; g.homeGot = 0; g.sch.nsh = 0; g.sch.mel = 0; g.sch.bak = 0; g.pz = 0; g.uq.length = 0; g.inB = ''; g.mb = 0; g.mbd = 0; g.bs = 0; g.bd = 0; g.bs2 = 0; g.bd2 = 0; g.b2At = 0; g.pred = 0; g.predDead = 0; g.moth = 0; g.mothDead = 0; g.bossDownT = 0; g.won = 0; g.endWave = 0; g.endT = 0; g.endSpawnT = 0; g.apWarn1 = 0; g.apWarn2 = 0; g.apStormHitCd = 0; g.botMask = 0; g.chemMask = 0; g.psyMask = 0; g.labStep = 0; g.labBank = 0; g.labFlip = 0; g.labNsh = 0; g.labMel = 0; g.labBak = 0; g.labNshRuns = 0; g.labMelRuns = 0; g.stormCd = 0; g.labCd = 0; g.safeCampT = 0; g.safeBreachCd = 0; g.safeThreat = 0; g.lvPend = 0; g.lvGrace = 0; g.lbSent = 0; g.lbTopErr = ''; g.lbRankErr = ''; g.lbRankText = ''; g.lbFetchT = 0; g.lbRankFetchT = 0; g.lbRetryAt = 0; g.lbBtnX = 0; g.lbBtnY = 0; g.lbBtnW = 0; g.lbBtnH = 0; g.paused = 0; g.pauseBtnX = 0; g.pauseBtnY = 0; g.pauseBtnW = 0; g.pauseBtnH = 0;
        p.x = 260; p.y = MAP_H * .5; p.vx = 0; p.vy = 0; p.hp = 100; p.maxHp = 100; p.speed = 185; p.fireCd = 0; p.fireRate = .46; p.dmg = 12; p.range = 400; p.shots = 1; p.magnet = 88; p.face = 1; p.rx = 0; p.ry = 0; p.flash = 0; p.gx = 1; p.gy = 0; p.zc = 0; p.zr = 0; p.zt = 0; p.zx = 1; p.zy = 0; p.zcd = 0; p.zDur = 1; p.zSpd = 2.1; p.zLoad = 1.5; p.zCool = 5.5; p.zDmg = 24; p.zDr = .55; p.zb = 0; p.zp = 0; p.zDriftVx = 0; p.zDriftVy = 0; p.mkOn = 0; p.mkT = 0; p.mkI = 8.8; p.mkS = 0; p.mkD = 14; p.mkR = 54; p.mkSl = .54; p.mkBurst = 0; p.mkBurstT = 0; p.mkBurstQ = []; p.chDo = 14; p.chBurst = 10; p.chHeal = 8; p.chHealCd = 0; p.chHealI = .85; p.cat = 0; p.catM = 0; p.catType = 0; p.fb = 0; p.fbT = 0; p.fbI = 8.6; p.fbR = 210; p.fbFear = 2.3; p.fbKn = 320; p.fbFx = 0; p.fbTier = 0; p.fbMode = 1; p.fbAiT = 0; p.bot = 0; p.botCount = 0; p.botSlots = 0; p.bType = 0; p.bAtk = 1; p.bAuraR = 0; p.bAuraSl = 0; p.bHealCd = 0; p.bHealI = 10; p.bHealAmt = 10; p.bHealFx = 0; p.triA = 0; p.triFx = 0; p.slCharge = 0; p.slFocus = 0; p.slT = 0; p.slRecallT = 0; p.slLinkT = 0; p.slRecallPulse = 0; p.slCarryVx = 0; p.slCarryVy = 0; p.slPow = 0; p.slWave = 0; p.slComboFx = 0; p.slHitMask = 0; p.slPerfect = 0; p.slDx = 1; p.slDy = 0; p.bx = p.x + 20; p.by = p.y + 4; p.ba = 0; p.bcd = .45; p.bRate = 1.9; p.bDmg = 1.15; p.bRange = 480; p.bFetch = 95; p.bPull = 195; p.bCarry = 0; p.bCarryMax = 2; p.bGrabCd = 0; p.bGrabI = .38; p.bPier = 4; p.bSize = 6;
        p.slRopeRest = 0;
        z.length = 0; b.length = 0; food.length = 0; pudd.length = 0; fx.length = 0; bots.length = 0; react.length = 0; psyFx.length = 0;
        decoy.on = 0; decoy.t = 0; decoy.pop = 0;
        keys.l = keys.r = keys.u = keys.d = keys.gr = 0; touchMove = 0; joyReset(1);
        randomizeBuildings();
        g.msg = 'home: unlock';
        g.msgT = 1.6;
        if (full) {
          // middle mint patch
          for (let i = 0; i < 24; i++)pushFood({ x: MID_X + rnd(-120, 120), y: MID_Y + rnd(-120, 120), v: 7, m: 1, t: 0 });
          // early trail to teach collection
          for (let i = 0; i < 10; i++)pushFood({ x: 330 + i * 58, y: MAP_H * .5 + rnd(-60, 60), v: 5, m: 1, t: 0 });
        }
      }

      function spawnZombie() {
        const currentCap = Math.min(MAX_Z, 100 + g.kills * 0.12 + (g.time || 0) * 0.5);
        if (z.length >= currentCap) return;
        const a = Math.random() * Math.PI * 2;
        const d = rnd(360, 560);
        const base = 1 + g.time * .045;
        let hp = 22 + base * 8 + rnd(-4, 8), sp = 56 + base * 6 + rnd(-6, 10), r = rnd(12, 18), dmg = 8 + base * .9, k = 0;
        if (g.time > 8 && Math.random() < .24) { k = 1; sp *= 1.28; hp *= .66; r *= .88; dmg *= .82; }
        if (g.time > 18 && Math.random() < .18) { k = 2; sp *= .74; hp *= 2.15; r *= 1.35; dmg *= 1.28; }
        // post-Dean new enemy types (introduced progressively by kills since Dean)
        const deanKills = g.bd ? (g.kills - (FIRST_BOSS_TRIGGER_KILLS || 800)) : 0;
        if (deanKills > 0) {
          const roll = Math.random();
          if (deanKills > HEALER_INTRO_KILLS && roll < .10) {
            k = 8; hp *= 1.1; sp *= .62; r = rnd(13, 17); dmg *= .6;
          } else if (deanKills > SHIELDED_INTRO_KILLS && roll < .20) {
            k = 7; hp *= 1.6; sp *= .82; r = rnd(14, 19); dmg *= 1.1;
          } else if (deanKills > EXPLODER_INTRO_KILLS && roll < .22) {
            k = 6; hp *= .72; sp *= .92; r = rnd(12, 16); dmg *= .7;
          }
        }
        // endless mode escalation
        if (g.endT > 0) {
          const esc = 1 + g.endT * .02 + g.endWave * .08;
          hp *= esc; sp = Math.min(sp * (1 + g.endT * .006), sp * 1.6); dmg *= Math.min(esc, 3.5);
        }
        let zx = clamp(p.x + Math.cos(a) * d, 20, MAP_W - 20);
        let zy = clamp(p.y + Math.sin(a) * d, 20, MAP_H - 20);
        const sb = safeBuildingAt(zx, zy, 10);
        if (sb) {
          const dx = zx - sb.x, dy = zy - sb.y, ln = Math.hypot(dx, dy) || 1;
          zx = sb.x + dx / ln * (sb.r + 18);
          zy = sb.y + dy / ln * (sb.r + 18);
        }
        const obj = { x: zx, y: zy, r, hp, s: sp, dmg, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k };
        if (k === 8) obj.healCd = rnd(1.8, 2.8);
        z.push(obj);
      }
      function spawnPredator() {
        if (g.pred || g.predDead || z.length >= MAX_Z) return;
        const a = Math.random() * Math.PI * 2, d = 500;
        const hp = 1600 + g.time * 8;
        const m = {
          x: clamp(p.x + Math.cos(a) * d, 50, MAP_W - 50), y: clamp(p.y + Math.sin(a) * d, 50, MAP_H - 50),
          r: 32, hp, s: 76, dmg: 24, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 9,
          prMax: hp, prCloak: 0, prCloakCd: rnd(5, 7), prLunge: 0, prLungeDx: 0, prLungeDy: 0,
          prCloneCd: rnd(10, 15), prPhase: 1, prTrailT: 0
        };
        pushOutsideSafe(m, 26); z.push(m);
        g.pred = 1;
        g.msg = 'the predator stalks...'; g.msgT = 2.0;
        beep(80, .2, 'sawtooth', .03); beep(55, .25, 'sawtooth', .018);
        trauma(.22);
      }
      function spawnPredatorClone(src) {
        if (z.length >= MAX_Z - 1) return;
        const a = Math.random() * Math.PI * 2, dd = rnd(60, 120);
        const hp = 80 + g.time * 1.5;
        const cl = {
          x: clamp(src.x + Math.cos(a) * dd, 20, MAP_W - 20), y: clamp(src.y + Math.sin(a) * dd, 20, MAP_H - 20),
          r: src.r * .8, hp, s: src.s * .95, dmg: src.dmg * .3, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 10,
          cloneLife: rnd(4, 6)
        };
        pushOutsideSafe(cl, 8); z.push(cl);
        burst(cl.x, cl.y, 'rgba(180,20,40,.6)', 6, 40);
        beep(140, .04, 'sawtooth', .012);
      }
      function spawnMother() {
        if (g.moth || g.mothDead || z.length >= MAX_Z) return;
        const a = Math.random() * Math.PI * 2, d = 600;
        const hp = 8400 + g.time * 22;
        const m = {
          x: clamp(p.x + Math.cos(a) * d, 60, MAP_W - 60), y: clamp(p.y + Math.sin(a) * d, 60, MAP_H - 60),
          r: 52, hp, s: 54, dmg: 48, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 11,
          moMax: hp, moPhase: 1, moScreamCd: rnd(6, 9), moScreamT: 0,
          moBroodCd: rnd(5, 8), moWaveCd: rnd(4, 6), moWaveT: 0, moRage: 0
        };
        pushOutsideSafe(m, 40); z.push(m);
        g.moth = 1;
        g.msg = 'THE MOTHER AWAKENS'; g.msgT = 3.0;
        beep(60, .4, 'sawtooth', .05); beep(40, .5, 'sawtooth', .035); beep(90, .3, 'triangle', .025);
        trauma(.42);
      }
      function spawnBroodling(src) {
        if (z.length >= MAX_Z - 1) return;
        const a = Math.random() * Math.PI * 2, dd = rnd(40, 100);
        const hp = 60 + g.time * 1.2;
        const br = {
          x: clamp(src.x + Math.cos(a) * dd, 20, MAP_W - 20), y: clamp(src.y + Math.sin(a) * dd, 20, MAP_H - 20),
          r: rnd(9, 13), hp, s: rnd(90, 120), dmg: 8 + g.time * .2, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 12
        };
        pushOutsideSafe(br, 6); z.push(br);
      }
      function spawnMiniBoss() {
        if (g.mb || g.mbd || g.bs || g.bd || g.bs2 || g.bd2 || z.length >= MAX_Z) return;
        const a = Math.random() * Math.PI * 2, d = 440;
        const hp = 320 + g.time * 8;
        const m = {
          x: clamp(p.x + Math.cos(a) * d, 40, MAP_W - 40), y: clamp(p.y + Math.sin(a) * d, 40, MAP_H - 40), r: 28, hp, s: 78, dmg: 18, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 5,
          mbMax: hp, mbChargeCd: rnd(2.2, 3.4), mbChargeT: 0, mbDx: 0, mbDy: 0
        };
        pushOutsideSafe(m, 22); z.push(m); g.mb = 1; g.msg = 'the provost charges in!'; g.msgT = 1.6; beep(200, .12, 'sawtooth', .028); trauma(.18);
      }
      function spawnBoss() {
        if (g.bs || g.bd || g.bs2 || g.bd2 || z.length >= MAX_Z) return;
        const a = Math.random() * Math.PI * 2, d = 520;
        const hp = 880 + g.time * 14;
        const m = {
          x: clamp(p.x + Math.cos(a) * d, 40, MAP_W - 40), y: clamp(p.y + Math.sin(a) * d, 40, MAP_H - 40), r: 38, hp, s: 52, dmg: 28, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 3,
          b1Max: hp, b1Eat: 0, b1Cd: 0, b1BaseR: 38, b1BaseS: 52, b1BaseDmg: 28, b1Pulse: 0, b1Roar: 0
        };
        pushOutsideSafe(m, 28); z.push(m); g.bs = 1; g.msg = 'the dean hungers...'; g.msgT = 1.8; beep(170, .15, 'sawtooth', .03); beep(85, .25, 'sawtooth', .02); trauma(.24);
      }
      function spawnApexAdds(src, count, phase) {
        if (z.length >= MAX_Z - 1) return;
        const tier = Math.max(1, phase | 0);
        for (let s = 0; s < count && z.length < MAX_Z; s++) {
          const aa = Math.random() * Math.PI * 2, dd = rnd(30, 90);
          const mx = clamp(src.x + Math.cos(aa) * dd, 20, MAP_W - 20);
          const my = clamp(src.y + Math.sin(aa) * dd, 20, MAP_H - 20);
          const kind = (tier >= 2 && Math.random() < .38) ? 2 : 1;
          const hp = kind === 2 ? (110 + g.time * 5.6 + rnd(-8, 12)) : (68 + g.time * 4.0 + rnd(-6, 10));
          const sp = kind === 2 ? (78 + rnd(-8, 12)) : (108 + rnd(-10, 20));
          const dmg = kind === 2 ? (22 + g.time * .34) : (16 + g.time * .28);
          const add = { x: mx, y: my, r: kind === 2 ? rnd(15, 20) : rnd(12, 17), hp, s: sp, dmg, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: kind };
          pushOutsideSafe(add, 10);
          z.push(add);
        }
      }
      function addApexStorm(px, py, r, dur) {
        const rr = clamp(r * .78, 44, 86);
        const dd = Math.max(1.15, dur * .72);
        for (let i = 0; i < react.length; i++) {
          const rc = react[i];
          if (rc.k !== 5) continue;
          const dx = rc.x - px, dy = rc.y - py;
          const link = (rc.r + rr) * .4;
          if (dx * dx + dy * dy < link * link) {
            rc.x = (rc.x + px) * .5;
            rc.y = (rc.y + py) * .5;
            rc.r = Math.max(rc.r, rr);
            rc.t = Math.max(rc.t, dd);
            rc.d = Math.max(rc.d, dd);
            rc.pcd = 0;
            return;
          }
        }
        if (react.length >= MAX_REACT) react.shift();
        react.push({ k: 5, x: px, y: py, r: rr, t: dd, d: dd, pcd: 0, ap: 1 });
        burst(px, py, '#d4b8ff', 8, 52);
        beep(250, .035, 'sawtooth', .011);
      }
      function spawnApexBoss() {
        if (g.bs2 || g.bd2 || z.length >= MAX_Z) return;
        const a = Math.random() * Math.PI * 2, d = 560;
        const hp = 2600 + g.time * 32;
        const m = { x: clamp(p.x + Math.cos(a) * d, 44, MAP_W - 44), y: clamp(p.y + Math.sin(a) * d, 44, MAP_H - 44), r: 46, hp, s: 68, dmg: 52, vx: 0, vy: 0, ht: 0, sl: 0, ce: 0, bm: 0, bt: 0, bi: '', k: 4, apMax: hp, apBaseS: 68, apCd: rnd(1.4, 2.2), apTele: 0, apTeleD: 0, apAimX: 0, apAimY: 0, apBurstLeft: 0, apBurstSpd: 920, apPhase: 1, apStormCd: rnd(3.6, 5.2), apSummonCd: rnd(2.6, 3.8), apEvadeCd: 0, apImpactCd: 0, apSlamCd: 0, apRegenCd: 0, apShieldT: 0 };
        pushOutsideSafe(m, 36); z.push(m); g.bs2 = 1; g.msg = 'APEX DEAN APPROACHES'; g.msgT = 2.0; beep(120, .2, 'sawtooth', .04); beep(60, .3, 'sawtooth', .03); trauma(.38);
      }
      function nearestZombie() {
        let best = 0, bd = 1e9;
        for (let i = 0; i < z.length; i++) {
          const dz = z[i], dx = dz.x - p.x, dy = dz.y - p.y, d = dx * dx + dy * dy;
          if (d < bd) { bd = d; best = dz }
        }
        return best;
      }

      function shoot() {
        const t = nearestZombie();
        if (!t) return;
        let dx = t.x - p.x, dy = t.y - p.y, ln = Math.hypot(dx, dy) || 1;
        if (ln > p.range) return;
        dx /= ln; dy /= ln;
        const n = p.shots, spread = .18;
        for (let i = 0; i < n; i++) {
          const off = n === 1 ? 0 : (i - (n - 1) / 2) * spread;
          const cs = Math.cos(off), sn = Math.sin(off);
          const sx = dx * cs - dy * sn, sy = dx * sn + dy * cs;
          pushBullet({ x: p.x, y: p.y, vx: sx * 520, vy: sy * 520, d: p.dmg, life: 1.05, pier: 1 });
        }
        p.gx = dx; p.gy = dy;
        p.rx -= dx * 6; p.ry -= dy * 4;
        p.flash = .07;
        p.face = dx >= 0 ? 1 : -1;
        burst(p.x + dx * 16, p.y + dy * 10, '#ffd56d', 3, 35);
        trauma(.025);
        beep(640, .04, 'square', .018);
      }
      function openLevelUp() {
        rollChoices();
        if (!g.choices.length) return 0;
        g.lvup = 1;
        g.cardT = 0;
        g.xpPulse = .65;
        g.msg = 'upgrade';
        g.msgT = 2.1;
        hitStop(.06);
        trauma(.2);
        beep(860, .08, 'triangle', .03);
        return 1;
      }

      function addXp(v) {
        g.xp += v;
        while (g.xp >= g.nextXp) {
          g.xp -= g.nextXp;
          g.level++;
          g.nextXp = (g.nextXp * 1.36 + 9) | 0;
          if (levelUiBlocked()) {
            g.lvPend++;
            g.xpPulse = .65;
            g.msg = 'upgrade queued';
            g.msgT = 1;
            beep(760, .05, 'triangle', .018);
          } else {
            openLevelUp();
          }
          break;
        }
      }
      function collectMint(i, src) {
        const f = food[i];
        if (!f) return;
        if (f.bc && p.bCarry > 0) p.bCarry--;
        addXp(f.v);
        food.splice(i, 1);
        g.xpPulse = Math.min(.5, g.xpPulse + .11);
        let ox = p.x, oy = p.y;
        if (src === 'bot') {
          const bi = (f.bc | 0) - 1;
          const bt = bi >= 0 && bi < bots.length ? bots[bi] : 0;
          ox = bt ? bt.x : p.bx;
          oy = bt ? bt.y : p.by;
        }
        burst(ox, oy, '#69f0c9', 4, 40);
        if (!p.mkOn) {
          g.homeGot++;
          if (g.homeGot >= g.homeNeed) {
            p.mkOn = 1; p.mkT = 0;
            startBurst();
            g.msg = 'territory online';
            g.msgT = 2.2;
            beep(820, .07, 'triangle', .028);
            burst(p.x, p.y, '#ffd56d', 16, 95);
          }
        }
      }

      // progressive upgrade scaling: upgrades get much stronger as kills increase
      // 1x at 0 kills, ~2x at 1200, ~4.5x at 4200, ~8.5x at 9000
      function upScale() { return 1 + g.kills / 1200; }

      const UPS = [
        // --- CORE ---
        { n: 'Rapid Fire', d: 'shoot faster', f: () => p.fireRate = Math.max(.06, p.fireRate * (1 - .22 * Math.min(upScale(), 4))), req: () => 1 },
        { n: 'Big Bites', d: 'more damage', f: () => p.dmg += 10 * upScale(), req: () => 1 },
        { n: 'Speed Paws', d: 'move faster', f: () => p.speed += 35 * upScale(), req: () => 1 },
        { n: 'Extra Shot', d: '+projectiles', f: () => { const add = 1 + Math.floor(upScale() / 2); p.shots = Math.min(14, p.shots + add) }, req: () => 1 },
        { n: 'Snack Magnet', d: 'pickup range up', f: () => p.magnet += 45 * upScale(), req: () => 1 },
        { n: 'Tough Fur', d: '+max hp +heal', f: () => { const v = 40 * upScale(); p.maxHp += v; p.hp = Math.min(p.maxHp, p.hp + v) }, req: () => 1 },
        { n: 'Quick Heal', d: 'heal now', f: () => p.hp = Math.min(p.maxHp, p.hp + 55 * upScale()), req: () => 1 },
        { n: 'Range Up', d: 'bullets fly farther', f: () => p.range = Math.min(1200, p.range + 60 * upScale()), req: () => 1 },
        // --- ZOOMIES ---
        { n: 'Zoomies Time', d: 'zoomies lasts longer', f: () => p.zDur = Math.min(6, p.zDur + .38 * upScale()), req: () => 1 },
        { n: 'Zoomies CD', d: 'zoomies cooldown down', f: () => p.zCool = Math.max(.4, p.zCool - .9 * upScale()), req: () => 1 },
        { n: 'Zoomies Speed', d: 'zoomies speed up', f: () => p.zSpd = Math.min(8, p.zSpd + .5 * upScale()), req: () => 1 },
        { n: 'Zoomies Charge', d: 'zoomies charge faster', f: () => p.zLoad = Math.max(.2, p.zLoad - .26 * upScale()), req: () => 1 },
        { n: 'Zoomies Damage', d: 'zoomies hit harder', f: () => p.zDmg += 6 * upScale(), req: () => 1 },
        { n: 'Zoomies Drift', d: 'longer momentum after dash', f: () => p.zDr = Math.min(1.6, p.zDr + .22 * upScale()), req: () => 1 },
        // --- TERRITORY / PUDDLES ---
        { n: 'Territory CD', d: 'territory cooldown down', f: () => p.mkI = Math.max(1.2, p.mkI - .75 * upScale()), req: () => p.mkOn },
        { n: 'Territory Radius', d: 'territory area bigger', f: () => p.mkR = Math.min(260, p.mkR + 18 * upScale()), req: () => p.mkOn },
        { n: 'Territory Duration', d: 'territory lasts longer', f: () => p.mkD = Math.min(90, p.mkD + 6 * upScale()), req: () => p.mkOn },
        { n: 'Territory Slow', d: 'territory slows more', f: () => p.mkSl = Math.min(.96, p.mkSl + .14 * Math.min(upScale(), 3)), req: () => p.mkOn },
        // --- CHEMICAL / CATALYST ---
        { n: 'Chemical Puddle', d: 'chem damage up', f: () => { const s = upScale(); p.chDo = Math.min(200, p.chDo + 12 * s); p.chBurst = Math.min(120, p.chBurst + 10 * s) }, req: () => p.cat },
        { n: 'Chemical Radius', d: 'chem area bigger', f: () => p.mkR = Math.min(280, p.mkR + 15 * upScale()), req: () => p.cat },
        { n: 'Chemical Tempo', d: 'chem cooldown down', f: () => p.mkI = Math.max(.8, p.mkI - .65 * upScale()), req: () => p.cat },
        { n: 'Sanctuary Boost', d: 'heal puddles restore more + faster', f: () => { p.chHeal = Math.min(30, p.chHeal + 4 * upScale()); p.chHealI = Math.max(.3, p.chHealI - .08 * upScale()) }, req: () => p.cat && (g.chemMask & 2) },
        // --- PSYCH ---
        { n: 'Psych Tempo', d: 'psych cooldown down', f: () => p.fbI = Math.max(2.4, p.fbI - .65 * upScale()), req: () => p.fb },
        { n: 'Psych Radius', d: 'psych effect radius up', f: () => p.fbR = Math.min(360, p.fbR + 22 * upScale()), req: () => p.fb },
        { n: 'Psych Control', d: 'control marks last longer', f: () => p.fbFear = Math.min(8, p.fbFear + .35 * upScale()), req: () => p.fb },
        { n: 'Psych Force', d: 'stronger psych knockback', f: () => p.fbKn = Math.min(1200, p.fbKn + 90 * upScale()), req: () => p.fb },
        // --- BOTS ---
        { n: 'Bot Fetch', d: 'bot grabs mints farther', f: () => p.bFetch = Math.min(500, p.bFetch + 40 * upScale()), req: () => p.bot },
        { n: 'Bot Cargo', d: 'bot carries more mints', f: () => p.bCarryMax = Math.min(12, p.bCarryMax + 1 + Math.floor(upScale() / 3)), req: () => p.bot },
        { n: 'Bot Speed', d: 'bots move faster', f: () => p.bPull = Math.min(600, p.bPull + 35 * upScale()), req: () => p.bot },
        { n: 'Medic Protocol', d: 'medic buddy heals stronger + faster', f: () => { const s = Math.min(upScale(), 3.4); p.bHealAmt = Math.min(90, p.bHealAmt + 6 * s); p.bHealI = Math.max(1.9, p.bHealI - .9) }, req: () => p.bot && (g.botMask & 2) },
        // --- SHOCK (bot attack) ---
        { n: 'Shock Tempo', d: 'shock pulse cooldown down', f: () => p.bRate = Math.max(.2, p.bRate * (1 - .2 * Math.min(upScale(), 4))), req: () => p.bot && p.bAtk },
        { n: 'Shock Pierce', d: 'pulse pierces more + wider', f: () => { p.bPier = Math.min(20, p.bPier + Math.ceil(upScale() * 1.2)); p.bSize = Math.min(36, p.bSize + 1.6 * upScale()) }, req: () => p.bot && p.bAtk },
        { n: 'Shock Power', d: 'shock pulse damage up', f: () => p.bDmg = Math.min(8, p.bDmg + .4 * upScale()), req: () => p.bot && p.bAtk },
        { n: 'Shock Range', d: 'shock pulse range up', f: () => p.bRange = Math.min(900, p.bRange + 55 * upScale()), req: () => p.bot && p.bAtk },
      ];

      function rollChoices() {
        const pool = UPS.filter(u => !u.req || u.req());
        g.choices = [];
        for (let i = 0; i < 3 && pool.length; i++) {
          const k = (Math.random() * pool.length) | 0;
          g.choices.push(pool[k]);
          pool.splice(k, 1);
        }
      }

      function takeChoice(i) {
        if (!g.lvup || !g.choices[i]) return;
        g.choices[i].f();
        g.lvup = 0;
        g.msg = g.choices[i].n + ' applied';
        g.msgT = 1.4;
        g.xpPulse = .25;
        g.labCd = Math.max(g.labCd, 3);
        trauma(.08);
        burst(p.x, p.y, '#69f0c9', 12, 90);
        popUnlockBook();
      }

      function hitPlayer(d) {
        if (scottyShielded()) {
          p.flash = Math.max(p.flash, .03);
          return;
        }
        let safetyRed = 0;
        for (let i = 0; i < SAFE_BUILDINGS.length; i++) {
          const b = SAFE_BUILDINGS[i], dst = Math.hypot(p.x - b.x, p.y - b.y);
          if (dst < b.r + SAFE_ZONE_EDGE_BUFFER) safetyRed = Math.max(safetyRed, SAFE_ZONE_DAMAGE_REDUCTION);
        }
        d *= (1 - safetyRed);

        const shieldRatio = clamp(p.zoomShield / ZOOMIES_SHIELD_DURATION, 0, 1);
        const shieldAmount = shieldRatio * ZOOMIES_SHIELD_REDUCTION;
        const dmg = Math.max(0, d * (1 - shieldAmount));
        if (dmg <= 0) return;
        p.hp -= dmg;
        trauma(.03);
        if (p.hp <= 0) {
          p.hp = 0; g.dead = 1; g.start = 1;
          if (g.kills > g.best) { g.best = g.kills | 0; localStorage.ss_best = g.best }
          g.msg = 'swarmed'; g.msgT = 999;
          hitStop(.09);
          trauma(.42);
          beep(120, .22, 'sawtooth', .05);
          burst(p.x, p.y, '#ff6f89', 26, 130);
          void fetchLeaderboardPreview(1);
          void fetchOwnRankPreview(1);
          void submitLeaderboardScore();
        }
      }

      function update(dt) {
        const rdt = dt;
        joyTick(rdt);
        if (g.paused) return;
        if (g.msgT > 0) g.msgT -= rdt;
        if (g.bossDownT > 0) g.bossDownT = Math.max(0, g.bossDownT - rdt);
        if (g.apStormHitCd > 0) g.apStormHitCd = Math.max(0, g.apStormHitCd - rdt);
        if (g.stormCd > 0) g.stormCd = Math.max(0, g.stormCd - rdt);
        if (g.labCd > 0) g.labCd = Math.max(0, g.labCd - rdt);
        if (g.stop > 0) { g.stop = Math.max(0, g.stop - rdt); dt *= .06; }
        if (g.shake > 0) g.shake = Math.max(0, g.shake - rdt * 2.2);
        if (g.xpPulse > 0) g.xpPulse = Math.max(0, g.xpPulse - rdt * 1.7);
        if (p.flash > 0) p.flash = Math.max(0, p.flash - rdt * 7);
        if (p.zb > 0) p.zb = Math.max(0, p.zb - rdt);
        if (p.zp > 0) p.zp = Math.max(0, p.zp - rdt);
        p.rx *= Math.max(0, 1 - rdt * 18);
        p.ry *= Math.max(0, 1 - rdt * 18);
        if (p.zcd > 0) p.zcd = Math.max(0, p.zcd - rdt);
        if (p.mkS > 0) p.mkS = Math.max(0, p.mkS - rdt);
        if (p.mkT > 0 && p.zt <= 0) p.mkT = Math.max(0, p.mkT - rdt);
        if (p.fbT > 0) p.fbT = Math.max(0, p.fbT - rdt);
        if (p.fbFx > 0) p.fbFx = Math.max(0, p.fbFx - rdt);
        if (p.bHealFx > 0) p.bHealFx = Math.max(0, p.bHealFx - rdt);
        if (p.triFx > 0) p.triFx = Math.max(0, p.triFx - rdt * ((p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) ? 1 : 1.7));
        if (p.slWave > 0) p.slWave = Math.max(0, p.slWave - rdt * 2.6);
        if (p.slComboFx > 0) p.slComboFx = Math.max(0, p.slComboFx - rdt * 2.1);
        if (p.slLinkT > 0) p.slLinkT = Math.max(0, p.slLinkT - rdt);
        if (p.zoomShield > 0) p.zoomShield = Math.max(0, p.zoomShield - rdt);
        for (let i = pudd.length - 1; i >= 0; i--) { const pd = pudd[i]; pd.t -= dt; if (pd.t <= 0) pudd.splice(i, 1); }
        for (let i = react.length - 1; i >= 0; i--) { const rc = react[i]; rc.t -= dt; if (rc.pcd > 0) rc.pcd = Math.max(0, rc.pcd - dt); if (rc.t <= 0) react.splice(i, 1); }
        for (let i = psyFx.length - 1; i >= 0; i--) { const q = psyFx[i]; q.t -= dt; if (q.t <= 0) psyFx.splice(i, 1); }
        for (let i = fx.length - 1; i >= 0; i--) { const f = fx[i]; f.t -= dt; f.x += f.vx * dt; f.y += f.vy * dt; f.vy += 480 * dt; if (f.t <= 0) fx.splice(i, 1) }

        if (!g.start) return;
        if (g.dead) {
          void fetchLeaderboardPreview(0);
          void fetchOwnRankPreview(0);
          void submitLeaderboardScore();
          return;
        }
        tickPsychDecoy(dt);
        if (g.won) {
          // victory: keep particles/fx ticking but no combat
          g.bossDownT = Math.max(g.bossDownT, 3);
          return;
        }
        if (zoomiesBusy()) g.lvGrace = LEVEL_UI_ZOOMIES_GRACE;
        else if (g.lvGrace > 0) g.lvGrace = Math.max(0, g.lvGrace - rdt);
        if (!g.lvup && !g.pz && g.lvPend > 0 && !levelUiBlocked()) {
          g.lvPend--;
          openLevelUp();
        }
        if (g.lvup) { g.cardT = Math.min(.9, g.cardT + rdt); return; }
        if (g.pz) {
          stepBakerPuzzle(dt);
          g.t += dt;
          return;
        }
        g.t += dt;
        if (g.bd && !g.bs2 && !g.bd2) {
          const rem = g.b2At - g.t;
          if (rem <= APEX_WARN_ONE && !g.apWarn1) {
            g.apWarn1 = 1;
            g.msg = 'something big is approaching...';
            g.msgT = 1.5;
            beep(190, .055, 'triangle', .016);
          }
          if (rem <= APEX_WARN_TWO && !g.apWarn2) {
            g.apWarn2 = 1;
            g.msg = 'someone...';
            g.msgT = 1.2;
            beep(170, .06, 'sawtooth', .02);
          }
        }

        const nsh = school('nsh'), mel = school('mel'), bak = school('bak');
        if (p.mkOn && g.sch.nsh === 0 && Math.hypot(p.x - nsh.x, p.y - nsh.y) < nsh.r) beginSchool('nsh');
        if (g.sch.nsh === 2 && g.sch.mel === 0 && Math.hypot(p.x - mel.x, p.y - mel.y) < mel.r) beginSchool('mel');
        if (g.sch.mel === 2 && g.mbd && g.sch.bak === 0 && Math.hypot(p.x - bak.x, p.y - bak.y) < bak.r) beginSchool('bak');
        if (g.sch.nsh === 2 && g.sch.bak === 2 && g.labNsh > 0 && Math.hypot(p.x - nsh.x, p.y - nsh.y) < nsh.r) claimLabVisit('nsh');
        if (g.sch.mel === 2 && g.sch.bak === 2 && g.labMel > 0 && Math.hypot(p.x - mel.x, p.y - mel.y) < mel.r) claimLabVisit('mel');
        if (g.sch.bak === 2 && g.labBak > 0 && Math.hypot(p.x - bak.x, p.y - bak.y) < bak.r) claimLabVisit('bak');
        popUnlockBook();

        // movement (keyboard + touch)
        const kx = (keys.r ? 1 : 0) - (keys.l ? 1 : 0), ky = (keys.d ? 1 : 0) - (keys.u ? 1 : 0);
        const joyMag = Math.hypot(joy.ax, joy.ay);
        let mx = kx, my = ky;
        if (touchMove && joyMag > JOY_INPUT_DEAD) { mx += joy.ax; my += joy.ay }
        let ln = Math.hypot(mx, my);
        if (ln > 1) { mx /= ln; my /= ln; }

        const hasInput = (Math.hypot(kx, ky) > .05 || (touchMove && joyMag > JOY_INPUT_DEAD)) && p.mkS <= 0;
        const pSafeChargeZone = safeBuildingAt(p.x, p.y, -6);
        if (p.mkOn && p.mkT <= 0 && p.mkS <= 0 && p.zt <= 0 && p.zr <= 0 && p.zc <= 0 && p.mkBurst <= 0) startBurst();
        if (p.mkBurst > 0) {
          p.mkBurstT = Math.max(0, p.mkBurstT - dt);
          if (p.mkBurstT <= 0 && p.mkBurstQ.length > 0) {
            placeBurstPuddle(p.mkBurstQ.shift());
            p.mkBurst--;
            if (p.mkBurst > 0) p.mkBurstT = .5;
            else p.mkT = p.mkI;
          }
        }
        brewReactions();
        if (p.zt <= 0) {
          if (!pSafeChargeZone && !hasInput && p.zcd <= 0 && p.mkS <= 0) {
            p.zc = Math.min(p.zLoad, p.zc + dt);
            if (p.zc > .25) {
              const q = p.zc / p.zLoad;
              p.rx += (Math.random() * 2 - 1) * .9 * q * 60 * dt;
              p.ry += (Math.random() * 2 - 1) * .9 * q * 60 * dt;
              trauma(.0007 * q * 60 * dt);
            }
            if (p.zc >= p.zLoad && !p.zr) {
              p.zr = 1;
              g.msg = 'zoomies ready';
              g.msgT = 1.1;
              trauma(.08);
              beep(760, .05, 'triangle', .024);
            }
          } else {
            if (p.zr) {
              p.zt = p.zDur;
              p.zr = 0;
              p.zc = 0;
              const l2 = ln || 1;
              p.zx = mx / l2;
              p.zy = my / l2;
              p.slCharge = 0;
              p.slFocus = 0;
              p.slPow = 0;
              p.slScale = 1;
              p.slLinkT = 0;
              p.slHitMask = 0;
              p.slPerfect = 0;
              p.slRopeRest = 0;
              hitStop(.04);
              trauma(.28);
              p.flash = .09;
              p.gx = p.zx; p.gy = p.zy;
              burst(p.x, p.y, '#9dffea', 22, 140);
              burst(p.x, p.y, '#ffffff', 6, 60);
              beep(980, .06, 'square', .028);
            } else {
              p.zc = 0;
            }
          }
        }

        const wasZooming = p.zt > 0;
        if (p.zt > 0) {
          p.zt = Math.max(0, p.zt - dt);
          if (hasInput) {
            const s = Math.min(1, dt * (bots.length >= 3 ? 20 : bots.length >= 2 ? 12 : 5));
            p.zx += (mx - p.zx) * s;
            p.zy += (my - p.zy) * s;
            const n = Math.hypot(p.zx, p.zy) || 1;
            p.zx /= n; p.zy /= n;
          }
          const zb = p.zb > 0 ? 1.35 : 1;
          const prog = 1 - p.zt / p.zDur;
          const ease = prog < .15 ? prog / .15 : p.zt / p.zDur < .2 ? p.zt / (.2 * p.zDur) : 1;
          const zs = (.4 + .6 * ease) * p.speed * p.zSpd * zb;
          p.vx = p.zx * zs + p.slCarryVx;
          p.vy = p.zy * zs + p.slCarryVy;
          p.face = p.vx >= 0 ? 1 : -1;
          p.rx -= p.zx * 8 * dt * 60;
          p.ry -= p.zy * 6 * dt * 60;
          if (Math.random() < .8) pushFx({ x: p.x + rnd(-8, 8), y: p.y + rnd(-8, 8), vx: -p.vx * .12 + rnd(-40, 40), vy: -p.vy * .12 + rnd(-40, 40), t: rnd(.1, .25), c: '#8fffe5' });
          if (Math.random() < .3) pushFx({ x: p.x + rnd(-3, 3), y: p.y + rnd(-3, 3), vx: -p.vx * .06 + rnd(-12, 12), vy: -p.vy * .06 + rnd(-12, 12), t: rnd(.3, .6), c: '#d4fffa' });
          if (p.zt <= 0) {
            if (p.bot && bots.length >= 2 && p.slCharge >= SLINGSHOT_CHARGE_TRIGGER) {
              const slSc = bots.length >= 3 ? 1 : SL_DUO_SCALE;
              p.slScale = slSc;
              const perfect = p.slPerfect && p.slFocus >= .98 ? 1 : 0;
              const q = Math.min(1, p.slCharge * (perfect ? 1.15 : 1));
              p.slT = (SLINGSHOT_DASH_MIN + (SLINGSHOT_DASH_MAX - SLINGSHOT_DASH_MIN) * q) * slSc;
              p.slRecallT = 0;
              p.slRecallPulse = 0;
              p.slCarryVx = 0;
              p.slCarryVy = 0;
              p.slPow = (.68 + .48 * q + .34 * perfect) * slSc;
              p.slLinkT = SLINGSHOT_LINK_HOLD * (.82 + .34 * q + .2 * perfect) * slSc;
              p.slDx = p.zx;
              p.slDy = p.zy;
              p.slWave = 1;
              p.triFx = 1;
              p.slHitMask = 0;
              p.slRopeRest = (SLINGSHOT_ROPE_START + 72 * q + 36 * perfect) * slSc;
              p.slComboFx = Math.max(p.slComboFx, perfect ? .95 * slSc : 0);
              const carry = Math.max(0, p.vx * p.zx + p.vy * p.zy);
              const baseSp = (SLINGSHOT_DASH_SPEED * (1.02 + .82 * q + .46 * perfect) + carry * .6) * slSc;
              for (let bi = 0; bi < Math.min(3, bots.length); bi++) {
                const bt = bots[bi];
                const spread = (bi - 1) * .26;
                const cs = Math.cos(spread), sn = Math.sin(spread);
                const dx = p.zx * cs - p.zy * sn, dy = p.zx * sn + p.zy * cs;
                const sp = baseSp * (1 - Math.abs(bi - 1) * .06);
                bt.slx = dx * sp + p.vx * .28;
                bt.sly = dy * sp + p.vy * .28;
                bt.vx = bt.slx;
                bt.vy = bt.sly;
                burst(bt.x, bt.y, '#b6f6ff', 6, 50 + q * 44);
              }
              hitStop((.05 + .025 * q) * slSc);
              trauma((.2 + .14 * q) * slSc);
              burst(p.x, p.y, '#8eefff', 14, (92 + q * 58) * slSc);
              g.msg = perfect ? 'perfect slingshot' : (slSc < 1 ? 'duo slingshot' : 'slingshot pack');
              g.msgT = .82;
              beep(perfect ? 1020 : 940, .05, 'square', .026);
              beep(perfect ? 1350 : 1220, .04, 'triangle', .018);
              if (perfect) {
                // Sonic Boom: recall blast when perfect, triggered after zoomies ends
                burst(p.x, p.y, '#ff4444', 40, 320);
                burst(p.x, p.y, '#ffffff', 20, 160);
                trauma(.45);
                for (let k = 0; k < z.length; k++) {
                  const m = z[k], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
                  if (d2 < 340 * 340) {
                    const d = Math.sqrt(d2) || 1;
                    m.vx += dx / d * 1800;
                    m.vy += dy / d * 1800;
                    m.hp -= 25 + g.kills * .05;
                    m.ht = .2;
                    burst(m.x, m.y, '#ff4444', 8, 60);
                  }
                }
                for (let k = 0; k < food.length; k++) {
                  const f = food[k];
                  f.vx = (p.x - f.x) * 4;
                  f.vy = (p.y - f.y) * 4;
                }
              }
              p.slPerfect = 0;
              p.slFocus = 0;
            } else {
              p.zDriftVx = p.vx * .6;
              p.zDriftVy = p.vy * .6;
              if (p.slPerfect) {
                // Sonic Boom: recall blast when perfect, triggered after zoomies ends
                burst(p.x, p.y, '#ff4444', 40, 320);
                burst(p.x, p.y, '#ffffff', 20, 160);
                trauma(.45);
                for (let k = 0; k < z.length; k++) {
                  const m = z[k], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
                  if (d2 < 340 * 340) {
                    const d = Math.sqrt(d2) || 1;
                    m.vx += dx / d * 1800;
                    m.vy += dy / d * 1800;
                    m.hp -= 25 + g.kills * .05;
                    m.ht = .2;
                    burst(m.x, m.y, '#ff4444', 8, 60);
                  }
                }
                for (let k = 0; k < food.length; k++) {
                  const f = food[k];
                  f.vx = (p.x - f.x) * 4;
                  f.vy = (p.y - f.y) * 4;
                }
              }
              p.slCharge = 0;
              p.slFocus = 0;
              p.slPerfect = 0;
              p.slScale = 1;
              p.slRecallT = 0;
              p.slLinkT = 0;
              p.slRecallPulse = 0;
              p.slCarryVx = 0;
              p.slCarryVy = 0;
              p.slHitMask = 0;
              p.slRopeRest = 0;
              g.msg = 'zoomies cd';
              g.msgT = .65;
              beep(420, .04, 'triangle', .016);
              beep(280, .1, 'sawtooth', .01);
            }
            p.zcd = p.zCool;
          }
        } else {
          const dr = Math.max(0, 1 - dt / p.zDr);
          p.zDriftVx *= dr; p.zDriftVy *= dr;
          if (Math.abs(p.zDriftVx) + Math.abs(p.zDriftVy) < 1) { p.zDriftVx = 0; p.zDriftVy = 0; }
          p.vx = mx * p.speed + p.slCarryVx + p.zDriftVx; p.vy = my * p.speed + p.slCarryVy + p.zDriftVy;
          if (p.zDriftVx * p.zDriftVx + p.zDriftVy * p.zDriftVy > 400 && Math.random() < .25) pushFx({ x: p.x + rnd(-4, 4), y: p.y + rnd(-4, 4), vx: -p.zDriftVx * .06 + rnd(-15, 15), vy: -p.zDriftVy * .06 + rnd(-15, 15), t: rnd(.08, .2), c: '#b8ffe8' });
          if (Math.abs(p.vx) > .5) p.face = p.vx > 0 ? 1 : -1;
          if (p.mkS > 0) {
            p.rx += Math.sin(g.t * 45) * .5;
            if (Math.random() < .7) pushFx({ x: p.x + rnd(-5, 5), y: p.y + 10 + rnd(-3, 3), vx: rnd(-14, 14), vy: rnd(6, 30), t: rnd(.12, .26), c: '#ffd56d' });
          }
        }
        if (wasZooming && p.zt <= 0) p.zoomShield = ZOOMIES_SHIELD_DURATION;

        p.x = clamp(p.x + p.vx * dt, 12, MAP_W - 12);
        p.y = clamp(p.y + p.vy * dt, 12, MAP_H - 12);
        if (p.zt > 0 && p.zp <= 0) {
          for (let i = 0; i < pudd.length; i++) {
            const pd = pudd[i], dx = p.x - pd.x, dy = p.y - pd.y;
            if (dx * dx + dy * dy < pd.r * pd.r) {
              p.zp = .22; p.zb = .48;
              burst(p.x, p.y, '#8fffe5', 8, 95);
              beep(740, .03, 'triangle', .02);
              for (let j = z.length - 1; j >= 0; j--) {
                const m = z[j], ex = m.x - pd.x, ey = m.y - pd.y;
                if (ex * ex + ey * ey < pd.r * pd.r) {
                  m.hp -= p.zDmg * 2.2; m.ht = .13; m.vx += p.zx * 260; m.vy += p.zy * 260;
                  if (m.hp <= 0) killZombie(j, '#8fffe5', 10, 80, 1);
                }
              }
              break;
            }
          }
        }
        const pSafeNow = safeBuildingAt(p.x, p.y, -6);
        g.time += dt;
        const bid = pSafeNow ? pSafeNow.id : '';
        g.inB = bid;
        if (!g.musicStarted) {
          const dist = Math.hypot(p.x - HOME.x, p.y - HOME.y);
          if (dist > 460) {
            g.musicStarted = 1;
            bgMusic.play().catch(() => { });
          }
        }
        applyShelterPressure(pSafeNow, dt);
        queueBakerPsychUnlocks();
        if (!pSafeNow || g.safeThreat >= SHELTER_MIN_THREAT) autoFocusBark(dt);
        if (p.cat) {
          if (p.chHealCd > 0) p.chHealCd = Math.max(0, p.chHealCd - dt);
          let healPad = 0;
          for (let i = 0; i < pudd.length; i++) {
            const pd = pudd[i], dx = p.x - pd.x, dy = p.y - pd.y;
            if (pd.m === 2 && dx * dx + dy * dy < pd.r * pd.r) { healPad = 1; break; }
          }
          if (healPad && p.chHealCd <= 0 && p.hp < p.maxHp) {
            const heal = Math.min(p.chHeal, p.maxHp - p.hp);
            p.hp += heal;
            p.chHealCd = p.chHealI;
            burst(p.x, p.y, '#7fe8dd', 8, 52);
            g.msg = 'heal +' + (heal | 0);
            g.msgT = .65;
          }
        }
        let inBloom = 0, inStorm = 0;
        let well = 0;
        let apexZone = 0;
        for (let i = 0; i < react.length; i++) {
          const rc = react[i], dx = p.x - rc.x, dy = p.y - rc.y;
          if (dx * dx + dy * dy < rc.r * rc.r) {
            if (rc.k === 2) {
              if (!well || rc.t > well.t) well = rc;
            } else if (rc.k === 3) inBloom = 1;
            else if (rc.k === 4) inStorm = 1;
            else if (rc.k === 5) apexZone = rc;
          }
        }
        if (well && well.pcd <= 0 && p.hp < p.maxHp) {
          const heal = Math.min(10, p.maxHp - p.hp);
          p.hp += heal;
          well.pcd = 1.6;
          burst(p.x, p.y, '#95ffe8', 10, 70);
          g.msg = 'well +' + (heal | 0);
          g.msgT = .6;
        }
        if (inBloom && p.hp < p.maxHp) {
          const heal = Math.min(p.maxHp - p.hp, 1.6 * dt);
          if (heal > 0) p.hp += heal;
        }
        if (inStorm && p.hp < p.maxHp) {
          const heal = Math.min(p.maxHp - p.hp, 8 * dt);
          if (heal > 0) p.hp += heal;
        }
        if (apexZone && !pSafeNow) {
          const adx = apexZone.x - p.x, ady = apexZone.y - p.y, adl = Math.hypot(adx, ady) || 1;
          const age = (apexZone.d - apexZone.t) / Math.max(.001, apexZone.d);
          const edge = clamp(adl / Math.max(1, apexZone.r), 0, 1);
          let pull = (APEX_STORM_PULL_BASE + age * APEX_STORM_PULL_GROW) * (.35 + .65 * edge);
          if (p.zt > 0) pull *= APEX_STORM_ZOOMIES_RESIST;
          p.x = clamp(p.x + adx / adl * pull * dt, 12, MAP_W - 12);
          p.y = clamp(p.y + ady / adl * pull * dt, 12, MAP_H - 12);
          if (g.apStormHitCd <= 0 && adl < apexZone.r * .82) {
            hitPlayer(p.zt > 0 ? APEX_STORM_TICK_DMG * .45 : APEX_STORM_TICK_DMG);
            g.apStormHitCd = APEX_STORM_TICK_CD;
          }
          if (Math.random() < .28) pushFx({ x: p.x + rnd(-8, 8), y: p.y + rnd(-8, 8), vx: rnd(-18, 18), vy: rnd(-30, 10), t: rnd(.08, .18), c: '#d4b8ff' });
        }

        let triMode = 0;
        if (p.bot && p.botCount > 0) {
          syncBots();
          triMode = p.zt > 0 && bots.length >= 2;
          if (triMode) {
            const aimDot = hasInput ? Math.max(0, mx * p.zx + my * p.zy) : 0;
            const pullGain = .6 + aimDot * .95;
            p.slCharge = Math.min(1, p.slCharge + dt * pullGain);
            if (p.zt <= SLINGSHOT_PERFECT_WINDOW) {
              if (hasInput && aimDot > SLINGSHOT_AIM_DOT) {
                p.slFocus = Math.min(1, p.slFocus + dt * 4.5);
                if (p.slFocus >= 1 && !p.slPerfect) {
                  p.slPerfect = 1;
                  p.slComboFx = Math.max(p.slComboFx, .55);
                  g.msg = 'perfect line';
                  g.msgT = .45;
                  beep(1180, .03, 'triangle', .014);
                  // Payoff (Sonic Boom) triggers when zoomies ends, not immediately
                }
              } else if (!p.slPerfect) {
                p.slFocus = Math.max(0, p.slFocus - dt * 3.8);
              }
            } else if (!p.slPerfect) {
              p.slFocus = Math.max(0, p.slFocus - dt * 1.6);
            }
            p.triFx = Math.min(1, p.triFx + dt * (p.slPerfect ? 4.1 : 3.2));
          } else if (p.slT <= 0 && p.slRecallT <= 0 && p.slLinkT <= 0 && (p.slCharge > 0 || p.slFocus > 0 || p.slPerfect)) {
            p.slCharge = Math.max(0, p.slCharge - dt * 2.6);
            p.slFocus = Math.max(0, p.slFocus - dt * 2.8);
            if (p.slFocus <= .02) p.slPerfect = 0;
          }
          if (p.slT > 0) {
            p.slT = Math.max(0, p.slT - dt);
            if (p.slT <= 0) {
              if (bots.length >= 2 && p.slPow > .08) {
                p.slRecallT = SLINGSHOT_RECALL_TIME * (.86 + .28 * Math.min(1, p.slPow));
                p.slRecallPulse = 0;
                g.msg = 'recall strike';
                g.msgT = .52;
                beep(860, .03, 'triangle', .014);
              } else {
                p.slHitMask = 0;
              }
            }
          } else if (p.slRecallT > 0) {
            p.slRecallT = Math.max(0, p.slRecallT - dt);
            if (p.slRecallT <= 0) {
              p.slRecallPulse = 1;
              p.slLinkT = Math.max(p.slLinkT, SLINGSHOT_LINK_MIN + .4 * SLINGSHOT_LINK_HOLD);
              p.slHitMask = 0;
            }
          }
          p.ba += dt * ((triMode || p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) ? 4.9 : 2.3);
          p.triA += dt * ((triMode || p.slLinkT > 0) ? 9.2 : 4.2);
          const linkMode = bots.length >= 2 && p.slLinkT > 0;
          if ((p.slT > 0 || p.slRecallT > 0 || linkMode) && hasInput) {
            const tln = Math.hypot(mx, my) || 1;
            const tx = mx / tln, ty = my / tln;
            const steerRate = p.slT > 0 ? 9.2 : (p.slRecallT > 0 ? 7.4 : 6.1);
            const steerBlend = Math.min(1, dt * steerRate);
            p.slDx += ((tx) - p.slDx) * steerBlend;
            p.slDy += ((ty) - p.slDy) * steerBlend;
            const sn = Math.hypot(p.slDx, p.slDy) || 1;
            p.slDx /= sn;
            p.slDy /= sn;
          }
          if (bots.length >= 2 && (p.slT > 0 || p.slRecallT > 0 || linkMode)) {
            if ((p.slRopeRest || 0) <= 0) p.slRopeRest = SLINGSHOT_ROPE_START;
            const ropeShrink = SLINGSHOT_ROPE_SHRINK * (.7 + .45 * Math.min(1, p.slPow) + (p.slT > 0 ? .24 : 0));
            p.slRopeRest = Math.max(SLINGSHOT_ROPE_DEFAULT, p.slRopeRest - dt * ropeShrink);
          } else if ((p.slRopeRest || 0) > 0) {
            p.slRopeRest = Math.max(0, p.slRopeRest - dt * 220);
          }
          let carryMode = 0, carryFx = 0, carryFy = 0, carryN = 0, carryGain = .18;
          let tetherCarryFx = 0, tetherCarryFy = 0, tetherCarryN = 0;
          if (bots.length >= 2) {
            if (p.slT > 0) { carryMode = 2; carryGain = .46 * p.slScale; }
            else if (p.slRecallT > 0) { carryMode = 3; carryGain = .33 * p.slScale; }
            else if (linkMode) { carryMode = 4; carryGain = .29 * p.slScale; }
            else if (triMode) { carryMode = 1; carryGain = .18; }
          }
          for (let bi = 0; bi < bots.length; bi++) {
            const bt = bots[bi];
            const px0 = bt.x, py0 = bt.y;
            const dtt = Math.max(.001, dt);
            if (p.slT > 0 && bi < 3) {
              const steer = SLINGSHOT_THROW_STEER * (.62 + .48 * Math.min(1, p.slPow));
              bt.slx += p.slDx * steer * dt;
              bt.sly += p.slDy * steer * dt;
              bt.x = clamp(bt.x + bt.slx * dt, 16, MAP_W - 16);
              bt.y = clamp(bt.y + bt.sly * dt, 16, MAP_H - 16);
              const drag = Math.max(0, 1 - dt * (SLINGSHOT_THROW_DRAG + 1.2 * Math.max(0, .9 - p.slPow)));
              bt.slx *= drag;
              bt.sly *= drag;
            } else {
              let tx = 0, ty = 0;
              if (p.slRecallT > 0 && bi < 3) {
                const rq = clamp(p.slRecallT / SLINGSHOT_RECALL_TIME, 0, 1);
                const front = 24 + 22 * rq;
                const side = (bi - 1) * (24 + 12 * rq);
                tx = p.x + p.slDx * front - p.slDy * side;
                ty = p.y + p.slDy * front + p.slDx * side;
                const k = 22 + 20 * (1 - rq);
                bt.vx += (tx - bt.x) * k * dt;
                bt.vy += (ty - bt.y) * k * dt;
                const damp = Math.max(0, 1 - dt * (SLINGSHOT_RECALL_HOME_RATE + 1.8 * (1 - rq)));
                bt.vx *= damp;
                bt.vy *= damp;
                bt.x = clamp(bt.x + bt.vx * dt, 16, MAP_W - 16);
                bt.y = clamp(bt.y + bt.vy * dt, 16, MAP_H - 16);
              } else if (triMode && bi < 3) {
                const back = 94 + 34 * p.slCharge;
                const side = (bi - 1) * (34 + 12 * p.slCharge);
                const sway = Math.sin(g.t * 18 + bi * 1.6) * (4 + 8 * p.slCharge);
                tx = p.x - p.zx * back - p.zy * side;
                ty = p.y - p.zy * back + p.zx * side + sway;
                const k = 18 + 20 * p.slCharge;
                bt.vx += (tx - bt.x) * k * dt;
                bt.vy += (ty - bt.y) * k * dt;
                const damp = Math.max(0, 1 - dt * (7.4 + 1.8 * p.slCharge));
                bt.vx *= damp;
                bt.vy *= damp;
                bt.x = clamp(bt.x + bt.vx * dt, 16, MAP_W - 16);
                bt.y = clamp(bt.y + bt.vy * dt, 16, MAP_H - 16);
              } else {
                const a = p.ba + bi * (Math.PI * 2 / bots.length);
                const rr = 38 + Math.sin(g.t * 2 + bi * .7) * 2;
                tx = p.x + Math.cos(a) * rr;
                ty = p.y + Math.sin(a) * rr;
                bt.x += (tx - bt.x) * Math.min(1, dt * 8);
                bt.y += (ty - bt.y) * Math.min(1, dt * 8);
              }
              bt.slx *= Math.max(0, 1 - dt * 7.8);
              bt.sly *= Math.max(0, 1 - dt * 7.8);
            }
            bt.vx = (bt.x - px0) / dtt;
            bt.vy = (bt.y - py0) / dtt;
            if (!(p.slT > 0 && bi < 3)) {
              bt.slx = bt.slx * .74 + bt.vx * .26;
              bt.sly = bt.sly * .74 + bt.vy * .26;
            }
            if (linkMode && bi < 3) {
              const ldx = bt.x - p.x, ldy = bt.y - p.y, ld = Math.hypot(ldx, ldy) || 1;
              const nx = ldx / ld, ny = ldy / ld;
              const linkQ = clamp(p.slLinkT / SLINGSHOT_LINK_HOLD, 0, 1);
              const ropeBase = Math.max(SLINGSHOT_ROPE_DEFAULT, (p.slRopeRest || SLINGSHOT_LINK_REST));
              let rest = ropeBase + SLINGSHOT_LINK_SWING * .34 * linkQ + 20 * Math.min(1, p.slPow);
              if (p.slT > 0) rest += 28;
              else if (p.slRecallT > 0) rest = Math.max(SLINGSHOT_ROPE_DEFAULT, rest * .74);
              const rvx = bt.vx - p.vx, rvy = bt.vy - p.vy;
              const radial = rvx * nx + rvy * ny;
              const springVel = clamp(((ld - rest) * SLINGSHOT_LINK_SPRING + radial * (SLINGSHOT_LINK_SPRING * SLINGSHOT_LINK_DAMP)) * dt, -125, 125);
              const tx = -ny, ty = nx;
              const tang = rvx * tx + rvy * ty;
              const tangVel = clamp(-tang * SLINGSHOT_LINK_TANGENT * (.65 + .55 * Math.min(1, p.slPow)) * dt, -84, 84);
              const impX = -nx * springVel + tx * tangVel;
              const impY = -ny * springVel + ty * tangVel;
              bt.slx += impX;
              bt.sly += impY;
              bt.vx += impX;
              bt.vy += impY;
              bt.x = clamp(bt.x + impX * dt, 16, MAP_W - 16);
              bt.y = clamp(bt.y + impY * dt, 16, MAP_H - 16);
              const dogShare = SLINGSHOT_LINK_DOG_SHARE * (.76 + .34 * Math.min(1, p.slPow));
              tetherCarryFx -= impX * dogShare;
              tetherCarryFy -= impY * dogShare;
              tetherCarryN++;
              if (Math.random() < .18 && Math.abs(ld - rest) > 10) {
                pushFx({ x: (p.x + bt.x) * .5 + rnd(-4, 4), y: (p.y + bt.y) * .5 + rnd(-4, 4), vx: rnd(-16, 16), vy: rnd(-16, 16), t: rnd(.06, .14), c: '#d6f7ff' });
              }
            }
            if (carryMode && bi < 3) {
              let ivx = 0, ivy = 0;
              if (carryMode === 2) {
                ivx = bt.vx * .6 + bt.slx * .4;
                ivy = bt.vy * .6 + bt.sly * .4;
              } else if (carryMode === 3) {
                const hx = p.x - bt.x, hy = p.y - bt.y, hl = Math.hypot(hx, hy) || 1;
                const pull = 190 + 110 * p.slPow;
                ivx = hx / hl * pull + bt.vx * .45 + bt.slx * .2;
                ivy = hy / hl * pull + bt.vy * .45 + bt.sly * .2;
              } else if (carryMode === 4) {
                ivx = bt.vx * .78 + bt.slx * .38;
                ivy = bt.vy * .78 + bt.sly * .38;
              } else {
                ivx = bt.vx * .72 + bt.slx * .25;
                ivy = bt.vy * .72 + bt.sly * .25;
              }
              carryFx += ivx;
              carryFy += ivy;
              carryN++;
            }
            if (bt.grabCd > 0) bt.grabCd = Math.max(0, bt.grabCd - dt);
            if (bt.mcd > 0) bt.mcd = Math.max(0, bt.mcd - dt);
          }
          if (tetherCarryN > 0) {
            carryFx += tetherCarryFx;
            carryFy += tetherCarryFy;
            carryN += tetherCarryN;
          }
          if (carryN > 0) {
            const targetVx = carryFx / carryN * carryGain;
            const targetVy = carryFy / carryN * carryGain;
            const blend = Math.min(1, dt * (carryMode === 2 ? 9.2 : carryMode === 3 ? 8.4 : carryMode === 4 ? 7.8 : 6.8));
            p.slCarryVx += (targetVx - p.slCarryVx) * blend;
            p.slCarryVy += (targetVy - p.slCarryVy) * blend;
          } else {
            const drag = Math.max(0, 1 - dt * 8.5);
            p.slCarryVx *= drag;
            p.slCarryVy *= drag;
            if (Math.abs(p.slCarryVx) + Math.abs(p.slCarryVy) < .5) {
              p.slCarryVx = 0;
              p.slCarryVy = 0;
            }
          }
          if (p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) p.triFx = Math.min(1, p.triFx + dt * 4.1);
          else if (!triMode && p.slLinkT <= 0 && p.slPow > 0) p.slPow = Math.max(0, p.slPow - dt * 2.2);
          if (p.slT <= 0 && p.slRecallT <= 0 && p.slLinkT <= 0 && p.slWave <= 0 && p.slPow < .01) {
            p.slPow = 0;
            p.slRopeRest = 0;
            p.triFx = Math.max(0, p.triFx - dt * 2.2);
          }
          p.bx = bots[0].x;
          p.by = bots[0].y;
          let medic = 0, medicI = 8, medicAmt = 18;
          for (let bi = 0; bi < bots.length; bi++) {
            const bt = bots[bi];
            if ((bt.t | 0) === 2) {
              const bs = botStats(2);
              medic = 1;
              medicI = Math.min(medicI, bs.healI || 8);
              medicAmt = Math.max(medicAmt, bs.healAmt || 18);
            }
          }
          if (medic) {
            if (p.bHealCd > 0) p.bHealCd = Math.max(0, p.bHealCd - dt);
            if (p.bHealCd <= 0 && p.hp < p.maxHp) {
              const heal = Math.min(medicAmt, p.maxHp - p.hp);
              p.hp += heal;
              p.bHealCd = medicI;
              p.bHealFx = .7;
              g.msg = 'medic +' + (heal | 0);
              g.msgT = .9;
              burst(p.x, p.y, '#84f0a6', 10, 62);
              beep(760, .05, 'triangle', .018);
            }
          }
          if (!pSafeNow && p.bAtk) {
            for (let bi = 0; bi < bots.length; bi++) {
              const bt = bots[bi];
              const bs = botStats(bt.t | 0 || 1);
              bt.cd -= dt;
              if (bt.cd > 0) continue;
              let t = 0, bd = bs.range * bs.range;
              for (let i = 0; i < z.length; i++) {
                const m = z[i], dx = m.x - bt.x, dy = m.y - bt.y, d2 = dx * dx + dy * dy;
                if (d2 < bd) { bd = d2; t = m; }
              }
              if (t) {
                const ln2 = Math.hypot(t.x - bt.x, t.y - bt.y) || 1;
                const pulse = !!bs.pulse, col = bs.col, pier = bs.pier;
                pushBullet({ x: bt.x, y: bt.y, vx: (t.x - bt.x) / ln2 * 420, vy: (t.y - bt.y) / ln2 * 420, d: p.dmg * bs.dmg, life: 1.35, pier, c: col, r: bs.size, pulse, kb: bs.kb, bounces: (bt.t | 0) === 1 ? 3 : 0 });
                bt.cd = bs.rate;
                burst(bt.x, bt.y, col, 4, 36);
              } else bt.cd = .35;
            }
          }
        } else {
          bots.length = 0;
          p.bCarry = 0;
          p.botSlots = 0;
          triMode = 0;
          p.slCharge = 0;
          p.slFocus = 0;
          p.slT = 0;
          p.slRecallT = 0;
          p.slLinkT = 0;
          p.slRecallPulse = 0;
          p.slCarryVx = 0;
          p.slCarryVy = 0;
          p.slPow = 0;
          p.slHitMask = 0;
          p.slPerfect = 0;
          p.slScale = 1;
          p.slComboFx = 0;
          p.slRopeRest = 0;
        }

        // auto-shoot
        p.fireCd -= dt;
        if (!pSafeNow && p.fireCd <= 0) { p.fireCd = p.fireRate; shoot() }

        // endless mode timer
        if (g.bd2) g.endT += dt;

        // victory is triggered by killing the Predator boss (handled in killZombie)
        // fallback: if somehow past KILL_CAP with no mother and no enemies, also win
        if (!g.won && g.kills >= KILL_CAP && !g.mothDead && z.length === 0) {
          g.won = 1;
          g.msg = 'CAMPUS SECURED'; g.msgT = 999;
          g.bossDownT = 4;
          trauma(.5); hitStop(.12);
          burst(p.x, p.y, '#ffd56d', 50, 300);
          burst(p.x, p.y, '#69f0c9', 40, 250);
          burst(p.x, p.y, '#8ec0ff', 30, 200);
          beep(523, .2, 'triangle', .03);
          beep(659, .18, 'triangle', .025);
          beep(784, .25, 'triangle', .03);
          void fetchLeaderboardPreview(1);
          void fetchOwnRankPreview(1);
          void submitLeaderboardScore();
        }

        // spawn (stop all spawning at kill cap or after predator dies)
        const canSpawn = g.kills < KILL_CAP && !g.won && !g.mothDead;
        g.spawnT -= dt;
        // predator: spawns after Dean dies at 1500 kills (before apex)
        if (canSpawn && g.bd && !g.pred && !g.predDead && !g.bs2 && !g.bd2 && g.kills >= PREDATOR_TRIGGER) spawnPredator();
        // mother: spawns at 9000 kills during endless mode
        if (canSpawn && g.bd2 && !g.moth && !g.mothDead && g.kills >= MOTHER_TRIGGER) spawnMother();
        // mini-boss: spawns after NSH done + enough kills
        if (canSpawn && g.sch.nsh === 2 && !g.mb && !g.mbd && !g.bs && !g.bd && g.kills >= MINI_BOSS_MIN_KILLS) spawnMiniBoss();
        const firstBossReadyByProgress = g.kills > FIRST_BOSS_TRIGGER_KILLS || g.time > FIRST_BOSS_TRIGGER_TIME;
        if (canSpawn && g.sch.bak === 2 && !g.bs && !g.bd && !g.bs2 && !g.bd2 && g.kills >= FIRST_BOSS_MIN_KILLS && firstBossReadyByProgress) spawnBoss();
        if (canSpawn && g.bd && !g.pred && !g.bs2 && !g.bd2 && g.predDead && g.t >= g.b2At) spawnApexBoss();
        if (canSpawn && g.spawnT <= 0) {
          g.spawnT = g.nextSpawn;
          const baseRate = .8 - g.time * .0056;
          // endless mode: spawn rate accelerates with waves
          const endBonus = g.endT > 0 ? g.endT * ENDLESS_SPAWN_ACCEL : 0;
          g.nextSpawn = Math.max(.12, baseRate - endBonus);
          spawnZombie();
          if (!g.bs && !g.bs2 && g.time > 26 && Math.random() < .28) spawnZombie();
          // endless mode: extra spawns
          if (g.endT > 0) {
            if (Math.random() < .35 + g.endWave * .04) spawnZombie();
            if (g.endWave >= 2 && Math.random() < .2) spawnZombie();
          }
        }
        // endless wave escalation
        if (canSpawn && g.endT > 0) {
          g.endSpawnT -= dt;
          if (g.endSpawnT <= 0) {
            g.endWave++;
            g.endSpawnT = Math.max(18, 35 - g.endWave * 2.5);
            g.msg = 'ENDLESS WAVE ' + g.endWave;
            g.msgT = 2.0;
            trauma(.12);
            beep(320, .08, 'square', .02);
            beep(440, .06, 'triangle', .015);
            // spawn a burst of enemies for the wave
            const waveBurst = 4 + g.endWave * 2;
            for (let w = 0; w < Math.min(waveBurst, 12); w++)spawnZombie();
          }
        }

        // bullets
        for (let i = b.length - 1; i >= 0; i--) {
          const q = b[i];
          q.life -= dt; q.x += q.vx * dt; q.y += q.vy * dt;
          if (q.life <= 0 || q.x < -20 || q.y < -20 || q.x > MAP_W + 20 || q.y > MAP_H + 20) { b.splice(i, 1); continue }
          for (let j = z.length - 1; j >= 0; j--) {
            const m = z[j], dx = m.x - q.x, dy = m.y - q.y;
            const br = q.r || 3;
            if (dx * dx + dy * dy < (m.r + br) * (m.r + br)) {
              let dmgMul = 1;
              if (m.k === 4 && m.apShieldT > 0) dmgMul = .72;
              // shielded enemy: reduced damage when moving toward bullet source
              if (m.k === 7) {
                const toP = Math.atan2(p.y - m.y, p.x - m.x);
                const moveA = Math.atan2(m.vy || .001, m.vx || .001);
                const diff = Math.abs(toP - moveA);
                if (diff < 1.2 || diff > Math.PI * 2 - 1.2) dmgMul *= .35;
              }
              m.hp -= q.d * dmgMul;
              m.ht = q.pulse ? .12 : .09;
              const kbval = q.kb || (q.pulse ? .11 : .07);
              m.vx += q.vx * kbval;
              m.vy += q.vy * kbval;
              if (q.pulse) burst(m.x, m.y, '#9de6ff', 3, 28);
              q.pier--;
              if (m.hp <= 0) killZombie(j, q.pulse ? '#9de6ff' : '#ff9675', q.pulse ? 7 : 9, q.pulse ? 58 : 70, q.pulse ? 1 : 0);
              if (q.pier < 0) {
                // chain bounce for Volt Buddy pulse bullets
                if (q.pulse && (q.bounces || 0) > 0) {
                  let best = 0, bd2 = 220 * 220;
                  for (let bj = 0; bj < z.length; bj++) {
                    if (bj === j) continue;
                    const bm = z[bj], bdx = bm.x - q.x, bdy = bm.y - q.y, dd = bdx * bdx + bdy * bdy;
                    if (dd < bd2) { bd2 = dd; best = bm; }
                  }
                  if (best) {
                    const bdx = best.x - q.x, bdy = best.y - q.y, bln = Math.hypot(bdx, bdy) || 1;
                    q.vx = bdx / bln * 420;
                    q.vy = bdy / bln * 420;
                    q.pier = 0;
                    q.bounces--;
                    q.d *= .8;
                    q.life = Math.max(q.life, .6);
                    burst(q.x, q.y, '#6ecfff', 4, 32);
                    beep(680 + (3 - q.bounces) * 80, .02, 'triangle', .01);
                    break;
                  }
                }
                b.splice(i, 1); break;
              }
            }
          }
        }

        // zombies + contact damage
        let contact = 0;
        let zoomHits = 0, zoomKills = 0;
        let slBurst = 0, slBurstPow = 0;
        const pSafe = pSafeNow;
        for (let i = z.length - 1; i >= 0; i--) {
          const m = z[i];
          if (m.fb > 0) m.fb = Math.max(0, m.fb - dt);
          if (m.fbSt > 0) m.fbSt = Math.max(0, m.fbSt - dt);
          if (m.psJ > 0) m.psJ = Math.max(0, m.psJ - dt);
          if (m.psF > 0) m.psF = Math.max(0, m.psF - dt);
          if (m.psD > 0) m.psD = Math.max(0, m.psD - dt);
          if (m.psComboCd > 0) m.psComboCd = Math.max(0, m.psComboCd - dt);
          let tx = p.x, ty = p.y;
          if (pSafe) {
            if (m.bi !== pSafe.id) { m.bi = pSafe.id; m.bm = 0; m.bt = rnd(.9, 1.7); }
            m.bt -= dt;
            if (m.bt <= 0) {
              if (m.bm === 0) { m.bm = 1; m.bt = rnd(1.1, 2.1); }
              else { m.bm = 0; m.bt = rnd(.9, 1.7); }
            }
            if (m.bm === 0) {
              const pdx = p.x - pSafe.x, pdy = p.y - pSafe.y, pl = Math.hypot(pdx, pdy) || 1;
              tx = pSafe.x + pdx / pl * (pSafe.r + 8);
              ty = pSafe.y + pdy / pl * (pSafe.r + 8);
            } else {
              const bx = m.x - pSafe.x, by = m.y - pSafe.y, bl = Math.hypot(bx, by) || 1;
              tx = m.x + bx / bl * 220 + (-by / bl) * Math.sin(g.t * 2 + i) * 30;
              ty = m.y + by / bl * 220 + (bx / bl) * Math.sin(g.t * 2 + i) * 30;
            }
          } else {
            m.bi = ''; m.bt = 0; m.bm = 0;
          }
          if (decoy.on && !isBossType(m.k)) {
            const ddx = decoy.x - m.x, ddy = decoy.y - m.y;
            if (ddx * ddx + ddy * ddy < PSY_DECOY_RADIUS * PSY_DECOY_RADIUS) {
              tx = decoy.x;
              ty = decoy.y;
              m.psF = Math.max(m.psF || 0, .8);
            }
          }
          if (m.fb > 0) {
            const fearable = m.k !== 3 && m.k !== 4 && m.k !== 5 && m.k !== 9 && m.k !== 11;
            if (fearable) {
              const fx = m.x - p.x, fy = m.y - p.y, fl = Math.hypot(fx, fy) || 1;
              tx = m.x + fx / fl * 280;
              ty = m.y + fy / fl * 280;
            }
          }
          // --- MOTHER BOSS (k===11): scream + broodlings + damaging wave ---
          if (m.k === 11) {
            if (!m.moMax) m.moMax = m.hp;
            const moHpR = clamp(m.hp / (m.moMax || 1), 0, 1);
            m.moPhase = moHpR > .6 ? 1 : (moHpR > .25 ? 2 : 3);
            m.moRage = m.moPhase - 1;
            // scream: slows player + knockback
            m.moScreamCd -= dt;
            if (m.moScreamT > 0) {
              m.moScreamT = Math.max(0, m.moScreamT - dt);
              if (!pSafeNow) {
                const sdx = p.x - m.x, sdy = p.y - m.y, sl2 = Math.hypot(sdx, sdy) || 1;
                if (sl2 < 320 + m.moRage * 60) {
                  // temporary slow: reduce velocity, don't touch base speed
                  p.vx *= Math.max(.3, 1 - 3.5 * dt);
                  p.vy *= Math.max(.3, 1 - 3.5 * dt);
                  // push away
                  p.vx -= sdx / sl2 * 80 * dt;
                  p.vy -= sdy / sl2 * 80 * dt;
                }
              }
              if (Math.random() < .4) pushFx({ x: m.x + rnd(-m.r * 2, m.r * 2), y: m.y + rnd(-m.r * 2, m.r * 2), vx: rnd(-30, 30), vy: rnd(-30, 30), t: rnd(.1, .22), c: '#cc44cc' });
            } else if (m.moScreamCd <= 0) {
              m.moScreamT = 1.2 + m.moRage * .4;
              m.moScreamCd = rnd(Math.max(3, 6 - m.moRage * 1.5), Math.max(5, 9 - m.moRage * 2));
              burst(m.x, m.y, '#dd66dd', 16 + m.moRage * 4, 200 + m.moRage * 40);
              beep(70, .12, 'sawtooth', .03);
              g.msg = m.moPhase === 3 ? 'MOTHER SCREAMS!' : 'mother scream!'; g.msgT = .8;
            }
            // spawn broodlings
            m.moBroodCd -= dt;
            if (m.moBroodCd <= 0) {
              const count = 2 + m.moPhase;
              for (let bb = 0; bb < count; bb++)spawnBroodling(m);
              m.moBroodCd = rnd(Math.max(3, 6 - m.moRage), Math.max(4, 8 - m.moRage));
              burst(m.x, m.y, '#993399', 8, 80);
              beep(100, .05, 'sawtooth', .015);
            }
            // damaging wave pulse
            m.moWaveCd -= dt;
            if (m.moWaveT > 0) {
              m.moWaveT = Math.max(0, m.moWaveT - dt);
            } else if (m.moWaveCd <= 0) {
              m.moWaveT = .6;
              m.moWaveCd = rnd(Math.max(2.5, 4.5 - m.moRage * .8), Math.max(3.5, 6 - m.moRage));
              const waveR = 180 + m.moRage * 50;
              const waveDmg = 10 + m.moRage * 5;
              const ddp = Math.hypot(p.x - m.x, p.y - m.y);
              if (ddp < waveR && !pSafeNow) hitPlayer(waveDmg * (1 - ddp / waveR));
              burst(m.x, m.y, '#ee55ee', 14 + m.moRage * 4, waveR * .6);
              beep(90, .08, 'sawtooth', .022);
            }
            // speed scales with rage
            m.s = 54 + m.moRage * 12;
          }
          // --- PREDATOR BOSS (k===9): cloak + lunge + shadow clones ---
          if (m.k === 9) {
            if (!m.prMax) m.prMax = m.hp;
            if (!m.prCloakCd) m.prCloakCd = rnd(4, 6);
            if (!m.prCloneCd) m.prCloneCd = rnd(8, 12);
            const prHpR = clamp(m.hp / (m.prMax || 1), 0, 1);
            m.prPhase = prHpR > .5 ? 1 : 2;
            const prRage = m.prPhase === 2 ? 1 : 0;
            // cloak timer
            m.prCloakCd -= dt;
            if (m.prCloak > 0) {
              m.prCloak = Math.max(0, m.prCloak - dt);
              // while cloaked: move faster, circle the player
              const circA = Math.atan2(p.y - m.y, p.x - m.x) + (.7 + prRage * .3);
              const circD = 180 + prRage * 40;
              tx = p.x + Math.cos(circA) * circD;
              ty = p.y + Math.sin(circA) * circD;
              m.s = (88 + prRage * 30) * 1.5;
              // subtle trail particles
              if (Math.random() < .3) pushFx({ x: m.x + rnd(-m.r, m.r), y: m.y + rnd(-m.r, m.r), vx: rnd(-10, 10), vy: rnd(-10, 10), t: rnd(.06, .14), c: 'rgba(180,20,20,.5)' });
              // lunge when cloak ends
              if (m.prCloak <= 0) {
                const ldx = p.x - m.x, ldy = p.y - m.y, ll = Math.hypot(ldx, ldy) || 1;
                m.prLunge = .35;
                m.prLungeDx = ldx / ll; m.prLungeDy = ldy / ll;
                m.prCloakCd = rnd(Math.max(2.5, 4.5 - prRage * 1.5), Math.max(3.5, 6 - prRage * 1.5));
                burst(m.x, m.y, '#ff3333', 14, 100);
                beep(160, .06, 'sawtooth', .025);
                g.msg = m.prPhase === 2 ? 'PREDATOR STRIKES!' : 'predator lunges!'; g.msgT = .7;
              }
            } else if (m.prCloakCd <= 0) {
              // enter cloak
              m.prCloak = rnd(2.2 + prRage * .8, 3.5 + prRage * 1);
              m.prCloakCd = 99; // reset after cloak ends
              burst(m.x, m.y, 'rgba(120,10,10,.6)', 10, 70);
              beep(100, .08, 'sawtooth', .018);
              g.msg = 'predator cloaks...'; g.msgT = 1.0;
            }
            // lunge: fast dash
            if (m.prLunge > 0) {
              m.prLunge = Math.max(0, m.prLunge - dt);
              m.vx += (m.prLungeDx || 0) * 1100 * dt;
              m.vy += (m.prLungeDy || 0) * 1100 * dt;
              if (Math.random() < .5) pushFx({ x: m.x + rnd(-8, 8), y: m.y + rnd(-8, 8), vx: -(m.prLungeDx || 0) * rnd(40, 100), vy: -(m.prLungeDy || 0) * rnd(40, 100), t: rnd(.08, .2), c: '#ff3333' });
            }
            m.s = m.prCloak > 0 ? (88 + prRage * 30) * 1.5 : (88 + prRage * 30);
            // shadow clones
            m.prCloneCd -= dt;
            if (m.prCloneCd <= 0) {
              const count = m.prPhase === 2 ? 3 : 2;
              for (let c = 0; c < count; c++)spawnPredatorClone(m);
              m.prCloneCd = rnd(Math.max(5, 9 - prRage * 3), Math.max(7, 12 - prRage * 3));
              burst(m.x, m.y, '#881111', 10, 80);
              beep(110, .06, 'sawtooth', .016);
              g.msg = 'predator summons shadows'; g.msgT = .9;
            }
            // trail particles when visible
            m.prTrailT -= dt;
            if (m.prTrailT <= 0 && m.prCloak <= 0) {
              m.prTrailT = .08;
              pushFx({ x: m.x + rnd(-4, 4), y: m.y + rnd(-4, 4), vx: rnd(-12, 12), vy: rnd(5, 20), t: rnd(.12, .24), c: '#aa2222' });
            }
          }
          // --- SHADOW CLONE (k===10): timed life, just chases ---
          if (m.k === 10) {
            if (m.cloneLife !== undefined) {
              m.cloneLife -= dt;
              if (m.cloneLife <= 0) {
                burst(m.x, m.y, '#661111', 6, 30);
                z.splice(i, 1); continue;
              }
            }
          }
          // --- MINI-BOSS (k===5): The Provost - charge attack ---
          if (m.k === 5) {
            if (!m.mbMax) m.mbMax = m.hp;
            if (!m.mbChargeCd) m.mbChargeCd = rnd(2.2, 3.4);
            if (!m.mbChargeT) m.mbChargeT = 0;
            m.mbChargeCd -= dt;
            if (m.mbChargeT > 0) {
              // charging: fast dash in stored direction
              m.mbChargeT = Math.max(0, m.mbChargeT - dt);
              m.vx += (m.mbDx || 0) * 680 * dt;
              m.vy += (m.mbDy || 0) * 680 * dt;
              if (Math.random() < .4) pushFx({ x: m.x + rnd(-6, 6), y: m.y + rnd(-6, 6), vx: -(m.mbDx || 0) * rnd(30, 80), vy: -(m.mbDy || 0) * rnd(30, 80), t: rnd(.08, .18), c: '#ffa64d' });
            } else if (m.mbChargeCd <= 0 && !pSafeNow) {
              // start charge toward player
              const cdx = p.x - m.x, cdy = p.y - m.y, cl = Math.hypot(cdx, cdy) || 1;
              m.mbDx = cdx / cl; m.mbDy = cdy / cl;
              m.mbChargeT = .42;
              m.mbChargeCd = rnd(2.0, 3.2);
              burst(m.x, m.y, '#ffa64d', 8, 60);
              beep(220, .05, 'sawtooth', .02);
              g.msg = 'provost charges!'; g.msgT = .7;
            }
          }
          // --- HEALER (k===8): pulse heal nearby zombies ---
          if (m.k === 8) {
            if (!m.healCd) m.healCd = rnd(1.8, 2.8);
            m.healCd -= dt;
            if (m.healCd <= 0) {
              m.healCd = rnd(1.6, 2.6);
              const healR = 120, healAmt = 15 + g.time * .4;
              let healed = 0;
              for (let j = 0; j < z.length; j++) {
                if (j === i || z[j].k >= 3) continue; // don't heal bosses
                const hx = z[j].x - m.x, hy = z[j].y - m.y;
                if (hx * hx + hy * hy < healR * healR) {
                  z[j].hp += healAmt;
                  z[j].ht = Math.max(z[j].ht, .06);
                  healed++;
                }
              }
              if (healed > 0) {
                burst(m.x, m.y, '#7fff7f', 6 + healed * 2, healR * .6);
                if (Math.random() < .5) pushFx({ x: m.x, y: m.y - 10, vx: 0, vy: -30, t: .3, c: '#7fff7f' });
              }
            }
          }
          // --- FIRST BOSS (k===3): tick timers (eating handled after player pickup) ---
          if (m.k === 3) {
            if (!m.b1Max) m.b1Max = m.hp;
            if (!m.b1BaseR) m.b1BaseR = m.r;
            if (!m.b1BaseS) m.b1BaseS = m.s;
            if (!m.b1BaseDmg) m.b1BaseDmg = m.dmg;
            if (m.b1Cd > 0) m.b1Cd = Math.max(0, m.b1Cd - dt);
            if (m.b1Pulse > 0) m.b1Pulse = Math.max(0, m.b1Pulse - dt);
            if (m.b1Roar > 0) m.b1Roar = Math.max(0, m.b1Roar - dt);
          }
          if (m.k === 4) {
            if (!m.apMax) m.apMax = m.hp;
            if (!m.apBaseS) m.apBaseS = m.s;
            if (!m.apCd) m.apCd = rnd(1.4, 2.2);
            if (!m.apStormCd) m.apStormCd = rnd(3.6, 5.2);
            if (!m.apSummonCd) m.apSummonCd = rnd(2.6, 3.8);
            if (!m.apBurstSpd) m.apBurstSpd = 920;
            if (!m.apTele) m.apTele = 0;
            if (!m.apBurstLeft) m.apBurstLeft = 0;
            if (!m.apEvadeCd) m.apEvadeCd = 0;
            if (!m.apImpactCd) m.apImpactCd = 0;
            if (!m.apSlamCd) m.apSlamCd = 0;
            if (!m.apRegenCd) m.apRegenCd = 0;
            if (!m.apShieldT) m.apShieldT = 0;
            const hpR = clamp(m.hp / (m.apMax || 1), 0, 1);
            const phase = hpR > .66 ? 1 : (hpR > .33 ? 2 : 3);
            const rage = phase - 1;
            m.apPhase = phase;
            m.s = (m.apBaseS || 68) * (1 + .18 * rage + (p.zt > 0 ? .22 : 0));
            m.apCd -= dt;
            m.apStormCd -= dt;
            m.apSummonCd -= dt;
            if (m.apEvadeCd > 0) m.apEvadeCd = Math.max(0, m.apEvadeCd - dt);
            if (m.apImpactCd > 0) m.apImpactCd = Math.max(0, m.apImpactCd - dt);
            if (m.apSlamCd > 0) m.apSlamCd = Math.max(0, m.apSlamCd - dt);
            if (m.apRegenCd > 0) m.apRegenCd = Math.max(0, m.apRegenCd - dt);
            if (m.apShieldT > 0) m.apShieldT = Math.max(0, m.apShieldT - dt);
            const qx = p.x - m.x, qy = p.y - m.y, ql = Math.hypot(qx, qy) || 1;
            const pred = phase === 1 ? .38 : phase === 2 ? .58 : .78;
            const aimX = clamp(p.x + p.vx * pred + (p.zx || 0) * 34, 20, MAP_W - 20);
            const aimY = clamp(p.y + p.vy * pred + (p.zy || 0) * 34, 20, MAP_H - 20);
            // GROUND SLAM: when close, slam the ground dealing AOE damage + knockback
            if (!pSafeNow && ql < 140 + phase * 20 && m.apSlamCd <= 0 && m.apTele <= 0) {
              m.apSlamCd = Math.max(2.2, 4.2 - rage * 1.1);
              const slamDmg = 14 + phase * 6 + rage * 4;
              const slamR = 120 + phase * 28;
              if (ql < slamR) hitPlayer(slamDmg);
              // knockback player away
              const kbStr = 320 + phase * 80;
              p.vx += (p.x - m.x) / ql * kbStr;
              p.vy += (p.y - m.y) / ql * kbStr;
              trauma(.22 + .08 * rage);
              hitStop(.04);
              // slam visual: expanding ring + particles
              burst(m.x, m.y, '#e0c8ff', 22 + phase * 6, 160 + phase * 30);
              burst(m.x, m.y, '#ff8bd9', 10 + phase * 3, 100 + phase * 20);
              addApexStorm(clamp(m.x + rnd(-18, 18), 24, MAP_W - 24), clamp(m.y + rnd(-18, 18), 24, MAP_H - 24), 52 + phase * 14, 1.6 + phase * .4);
              beep(90, .1, 'sawtooth', .035);
              beep(55, .14, 'sawtooth', .025);
              g.msg = phase === 3 ? 'APEX SLAM! OMEGA FURY!' : 'apex ground slam!'; g.msgT = .9;
              m.vx *= .1; m.vy *= .1; // brief pause after slam
            }
            // OMEGA PHASE HP REGEN: very low out-of-combat sustain only
            if (phase >= 3 && m.apRegenCd <= 0 && m.apShieldT <= 0 && m.ht <= .01 && ql > 220) {
              const missingHp = Math.max(0, m.apMax - m.hp);
              const regenAmt = Math.min(m.apMax * .0007, missingHp);
              if (regenAmt > 0) {
                m.hp += regenAmt;
                if (Math.random() < .35) pushFx({ x: m.x + rnd(-14, 14), y: m.y + rnd(-14, 14), vx: rnd(-10, 10), vy: rnd(-30, -10), t: rnd(.15, .3), c: '#d8b4ff' });
              }
              m.apRegenCd = regenAmt > 0 ? .7 : .32;
            }
            // DAMAGE SHIELD: brief damage reduction after phase transitions
            if (m.apShieldT > 0) {
              // reduce incoming damage handled in bullet section implicitly via ht extension
              if (Math.random() < .5) pushFx({ x: m.x + rnd(-m.r, m.r), y: m.y + rnd(-m.r, m.r), vx: rnd(-16, 16), vy: rnd(-16, 16), t: rnd(.08, .16), c: '#c8b6ff' });
            }
            // trigger shield on phase transition
            if (phase > 1 && !m.apLastPhase) m.apLastPhase = 1;
            if (m.apLastPhase && phase !== m.apLastPhase) {
              m.apShieldT = 1.8;
              m.apLastPhase = phase;
              burst(m.x, m.y, '#c8b6ff', 18, 140);
              beep(180, .08, 'triangle', .022);
              g.msg = phase === 2 ? 'APEX RAGE MODE' : 'APEX OMEGA FRENZY';
              g.msgT = 1.2;
              // summon a wave on transition
              spawnApexAdds(m, phase + 1, phase);
            }
            // evade: smarter, more frequent, sometimes dodges into flanking position
            if (!pSafeNow && p.zt > 0 && m.apEvadeCd <= 0) {
              const side = Math.random() < .5 ? -1 : 1;
              const evade = 300 + rage * 90;
              m.vx += (-p.zy) * side * evade;
              m.vy += (p.zx) * side * evade;
              // sometimes dash behind the player
              if (phase >= 2 && Math.random() < .35) {
                m.vx += qx / ql * 180;
                m.vy += qy / ql * 180;
              }
              m.apEvadeCd = Math.max(.35, .55 - rage * .1);
              if (phase >= 2 && Math.random() < .55 + rage * .15) {
                addApexStorm(
                  clamp(m.x + (-p.zy) * side * 60, 24, MAP_W - 24),
                  clamp(m.y + (p.zx) * side * 60, 24, MAP_H - 24),
                  62 + rage * 14,
                  2.0 + rage * .45
                );
              }
              burst(m.x, m.y, '#d7c1ff', 12 + phase * 2, 80 + phase * 10);
              beep(176 - .05 * rage, .05, 'sawtooth', .02);
            }
            if (m.apTele > 0) {
              m.apTele = Math.max(0, m.apTele - dt);
              m.vx *= Math.max(0, 1 - dt * 13);
              m.vy *= Math.max(0, 1 - dt * 13);
              if (Math.random() < .65) {
                pushFx({ x: m.x + rnd(-8, 8), y: m.y + rnd(-8, 8), vx: rnd(-26, 26), vy: rnd(-26, 26), t: rnd(.1, .2), c: '#dab9ff' });
              }
              if (Math.random() < .6) {
                pushFx({ x: m.apAimX + rnd(-10, 10), y: m.apAimY + rnd(-10, 10), vx: rnd(-20, 20), vy: rnd(-20, 20), t: rnd(.08, .18), c: '#f4dcff' });
              }
              if (m.apTele <= 0) {
                const lx = m.apAimX - m.x, ly = m.apAimY - m.y, ll = Math.hypot(lx, ly) || 1;
                const burstSp = (m.apBurstSpd || 920) + rage * 180 + rnd(-45, 70);
                m.vx += lx / ll * burstSp;
                m.vy += ly / ll * burstSp;
                m.ht = Math.max(m.ht, .18);
                trauma(.22 + .06 * rage);
                hitStop(.035);
                burst(m.x, m.y, '#c7a9ff', 24, 160);
                addApexStorm(clamp(m.apAimX + rnd(-22, 22), 24, MAP_W - 24), clamp(m.apAimY + rnd(-22, 22), 24, MAP_H - 24), 72 + rage * 16, 2.4 + rage * .6);
                // always spawn adds on burst from phase 2+, sometimes in phase 1 too
                if (phase >= 2) spawnApexAdds(m, phase === 3 ? 4 : 2, phase);
                else if (Math.random() < .3) spawnApexAdds(m, 1, phase);
                m.apBurstLeft = (m.apBurstLeft | 0) - 1;
                if (m.apBurstLeft > 0) {
                  m.apTeleD = Math.max(.16, .30 - rage * .04);
                  m.apTele = m.apTeleD;
                  m.apAimX = clamp(p.x + p.vx * (pred * .7) + rnd(-36, 36), 20, MAP_W - 20);
                  m.apAimY = clamp(p.y + p.vy * (pred * .7) + rnd(-36, 36), 20, MAP_H - 20);
                } else {
                  m.apCd = rnd(Math.max(.5, 1.35 - rage * .2), Math.max(.9, 2.1 - rage * .24));
                }
                beep(140 - rage * 10, .07, 'sawtooth', .035);
              }
            } else if (m.apCd <= 0) {
              const close = ql < 180, far = ql > 360;
              let bursts = phase === 1 ? 2 : (phase === 2 ? 3 : 4);
              if (close && phase >= 2) bursts++;
              if (far) bursts = Math.max(bursts, 3);
              m.apBurstLeft = bursts;
              m.apTeleD = Math.max(.20, .46 - rage * .09 - (close ? .08 : 0));
              m.apTele = m.apTeleD;
              m.apAimX = aimX;
              m.apAimY = aimY;
              m.apBurstSpd = 880 + rage * 190 + (far ? 110 : 0);
              if (Math.random() < .45 + rage * .25) {
                const side = Math.random() < .5 ? -1 : 1;
                m.apAimX = clamp(m.apAimX + (-qy / ql) * side * (80 + rage * 50), 20, MAP_W - 20);
                m.apAimY = clamp(m.apAimY + (qx / ql) * side * (80 + rage * 50), 20, MAP_H - 20);
              }
              g.msg = phase === 3 ? 'APEX FRENZY!' : 'apex charging';
              g.msgT = .6;
              burst(m.x, m.y, '#b59bff', 14 + phase * 5, 100 + phase * 22);
              beep(185 - rage * 12, .06, 'square', .022);
              if (m.apSummonCd <= 0) {
                spawnApexAdds(m, phase + 1, phase);
                m.apSummonCd = rnd(Math.max(.9, 2.4 - rage * .7), Math.max(1.4, 3.4 - rage * .8));
              }
            }
            // storms: more frequent, bigger, double-storm in omega
            if (m.apStormCd <= 0 && !pSafeNow) {
              addApexStorm(clamp(p.x + p.vx * .36 + rnd(-40, 40), 24, MAP_W - 24), clamp(p.y + p.vy * .36 + rnd(-40, 40), 24, MAP_H - 24), 68 + phase * 14, 2.2 + phase * .55);
              if (phase >= 2 && Math.random() < .2 + rage * .1) {
                addApexStorm(clamp(m.x + rnd(-140, 140), 24, MAP_W - 24), clamp(m.y + rnd(-140, 140), 24, MAP_H - 24), 60 + phase * 12, 2.0 + phase * .45);
              }
              if (phase >= 3 && Math.random() < .16) {
                // triple storm in omega
                const sa = Math.random() * Math.PI * 2;
                addApexStorm(clamp(p.x + Math.cos(sa) * 130 + rnd(-30, 30), 24, MAP_W - 24), clamp(p.y + Math.sin(sa) * 130 + rnd(-30, 30), 24, MAP_H - 24), 56 + rage * 10, 1.8 + rage * .4);
              }
              m.apStormCd = rnd(Math.max(2.8, 4.9 - rage * .45), Math.max(3.8, 6.4 - rage * .45));
            }
            // gravity pull: stronger, wider
            if (!pSafeNow) {
              const px = m.x - p.x, py = m.y - p.y, pl = Math.hypot(px, py) || 1;
              const pullR = 340 + phase * 50;
              if (pl < pullR) {
                const pull = (1 - pl / pullR) * (130 + phase * 48);
                p.x = clamp(p.x + px / pl * pull * dt, 12, MAP_W - 12);
                p.y = clamp(p.y + py / pl * pull * dt, 12, MAP_H - 12);
                p.rx -= px / pl * (1.8 + phase * .42);
                p.ry -= py / pl * (1.5 + phase * .36);
              }
            }
          }
          const dx = tx - m.x, dy = ty - m.y, ln = Math.hypot(dx, dy) || 1;
          let sf = 1, inPad = 0, padMode = 0, inAcidPad = 0, reactDot = 0;
          let inPlayerStorm = 0;
          for (let r = 0; r < react.length; r++) {
            const rc = react[r], rx = m.x - rc.x, ry = m.y - rc.y, d2 = rx * rx + ry * ry;
            if (rc.k === 5) {
              if (d2 < rc.r * rc.r && m.k !== 4) sf = Math.min(sf, 1.15);
              continue;
            }
            if (rc.k === 1) {
              const gr = rc.r * 1.9;
              if (d2 < gr * gr) {
                const gd = Math.sqrt(d2) || 1, q = 1 - gd / gr, pull = 120 + q * q * 390;
                m.vx += (-rx / gd) * pull * dt;
                m.vy += (-ry / gd) * pull * dt;
                sf = Math.min(sf, .8);
                if (d2 < rc.r * rc.r) {
                  sf = Math.min(sf, .48);
                  reactDot += p.chDo * .82 + 6;
                }
              }
              continue;
            }
            if (d2 >= rc.r * rc.r) continue;
            if (rc.k === 2) {
              sf = Math.min(sf, .5);
            } else if (rc.k === 3) {
              sf = Math.min(sf, .72);
              reactDot += p.chDo * 1.02 + 7;
            } else if (rc.k === 4) {
              const gd = Math.sqrt(d2) || 1, q = 1 - gd / rc.r, pull = 170 + q * q * 420;
              m.vx += (-rx / gd) * pull * dt;
              m.vy += (-ry / gd) * pull * dt;
              sf = Math.min(sf, .28);
              reactDot += p.chDo * 1.75 + 18;
              inPlayerStorm = 1;
              if ((m.sc || 0) <= 0) {
                m.sc = .24;
                burst(m.x, m.y, '#c8f3ff', 4, 34);
              }
            }
          }
          if (m.sc > 0) m.sc = Math.max(0, m.sc - dt);
          for (let pi = 0; pi < psyFx.length; pi++) {
            const q = psyFx[pi];
            if (q.k === 3) {
              const dxp = m.x - q.x, dyp = m.y - q.y, d2 = dxp * dxp + dyp * dyp;
              if (d2 < q.r * q.r) {
                let best = 0, bd = 1e18;
                for (let pk = 0; pk < pudd.length; pk++) {
                  const pd = pudd[pk];
                  if (pd.t <= .08) continue;
                  const pdx = pd.x - m.x, pdy = pd.y - m.y, dd = pdx * pdx + pdy * pdy;
                  if (dd < bd) { bd = dd; best = pd; }
                }
                if (best) {
                  const pdx = best.x - m.x, pdy = best.y - m.y, pl = Math.hypot(pdx, pdy) || 1;
                  const edge = Math.max(16, best.r * .84);
                  const tx = best.x - pdx / pl * edge, ty = best.y - pdy / pl * edge;
                  const ex = tx - m.x, ey = ty - m.y, el = Math.hypot(ex, ey) || 1;
                  const pull = 120 + 220 * (1 - Math.min(1, Math.sqrt(d2) / Math.max(1, q.r)));
                  m.vx += ex / el * pull * dt;
                  m.vy += ey / el * pull * dt;
                  sf = Math.min(sf, .64);
                } else {
                  const dl = Math.hypot(dxp, dyp) || 1;
                  m.vx += (-dxp / dl) * (90 * dt);
                  m.vy += (-dyp / dl) * (90 * dt);
                  sf = Math.min(sf, .7);
                }
              }
              continue;
            }
            const qx = m.x - q.x, qy = m.y - q.y;
            const along = qx * q.dx + qy * q.dy;
            if (Math.abs(along) > q.len) continue;
            const px = qx - q.dx * along, py = qy - q.dy * along;
            const pd = Math.hypot(px, py) || 1;
            const laneW = q.w * (q.k === 2 ? 1.35 : 1.55);
            if (pd > laneW) continue;
            const pull = 1 - pd / laneW;
            const side = (q.k === 2 ? 180 : 140) + pull * (q.k === 2 ? 280 : 230);
            m.vx += (-px / pd) * side * dt;
            m.vy += (-py / pd) * side * dt;
            if (q.k === 2) {
              const pulse = .55 + .45 * Math.sin((1 - q.t / Math.max(.001, q.d)) * Math.PI * 8);
              const rail = 120 + pulse * 340;
              m.vx += q.dx * rail * dt;
              m.vy += q.dy * rail * dt;
              sf = Math.min(sf, .58);
            } else {
              sf = Math.min(sf, .66);
            }
            if (p.zt > 0) {
              const zBoost = (q.k === 2 ? 340 : 260) + pull * 220;
              m.vx += q.dx * zBoost * dt;
              m.vy += q.dy * zBoost * dt;
              m.hp -= (q.k === 2 ? (p.zDmg * .75 + 8) : (p.zDmg * .45 + 4)) * dt;
            }
          }
          for (let k = 0; k < pudd.length; k++) {
            const pd = pudd[k], px = m.x - pd.x, py = m.y - pd.y;
            const d2 = px * px + py * py;
            const mode = pd.m | 0;
            if (mode === 3) {
              const gr = pd.r * 2.35;
              if (d2 < gr * gr) {
                const gd = Math.sqrt(d2) || 1, q = 1 - gd / gr;
                const pull = 90 + q * q * 350;
                m.vx += (-px / gd) * pull * dt;
                m.vy += (-py / gd) * pull * dt;
                sf = Math.min(sf, .88);
                if (d2 < pd.r * pd.r) {
                  if (padMode !== 1) padMode = 3;
                  sf = Math.min(sf, .42);
                  inPad = 1;
                }
              }
              continue;
            }
            if (d2 < pd.r * pd.r) {
              if (mode === 1) {
                inAcidPad = 1;
                padMode = 1;
              } else if (padMode !== 1) {
                padMode = mode;
              }
              const slow = mode === 1 ? .3 : mode === 2 ? .18 : p.mkSl;
              sf = Math.min(sf, 1 - slow);
              inPad = 1;
              if (mode === 1 && p.cat && m.ce <= 0) {
                m.ce = .55; m.hp -= p.chBurst;
                burst(m.x, m.y, '#ffd58f', 5, 44);
              }
            }
          }
          if (p.bot && bots.length) {
            for (let bi = 0; bi < bots.length; bi++) {
              const bt = bots[bi], bx = m.x - bt.x, by = m.y - bt.y, d2 = bx * bx + by * by, bs = botStats(bt.t | 0 || 1);
              if (d2 < 20 * 20) sf = Math.min(sf, .65);
              if (bs.auraR > 0 && d2 < bs.auraR * bs.auraR) sf = Math.min(sf, 1 - bs.auraSl);
              if (bots.length >= 3 && d2 < BOT_MELEE_RANGE * BOT_MELEE_RANGE && bt.mcd <= 0) {
                const md = Math.sqrt(d2) || 1;
                m.hp -= BOT_MELEE_DMG * bs.dmg;
                m.ht = Math.max(m.ht, .1);
                m.vx += bx / md * BOT_MELEE_KB;
                m.vy += by / md * BOT_MELEE_KB;
                bt.mcd = BOT_MELEE_CD;
                burst(bt.x, bt.y, bs.col, 4, 28);
                if (m.hp <= 0) { killZombie(i, bs.col, 7, 52); break; }
              }
            }
          }
          const bladeRopeMode = (triMode || p.slRecallT > 0 || p.slLinkT > 0) && bots.length >= 2;
          if (bladeRopeMode) {
            sf = Math.min(sf, triMode ? .58 : .66);
            let tetherHit = 0;
            for (let bi = 0; bi < Math.min(3, bots.length); bi++) {
              const bt = bots[bi], hitR = m.r + 14;
              if (segDist2(m.x, m.y, p.x, p.y, bt.x, bt.y) < hitR * hitR) {
                tetherHit = 1;
                break;
              }
            }
            if (tetherHit && ((m.tc || 0) <= 0)) {
              const ropePow = triMode ? Math.max(.1, p.slCharge) : Math.max(.32, p.slPow);
              const lashMul = (triMode ? (.24 + .38 * ropePow) : (.34 + .92 * ropePow)) * p.slScale;
              const lash = p.zDmg * lashMul * (m.k >= 3 ? .82 : 1);
              m.hp -= lash;
              m.ht = Math.max(m.ht, triMode ? .12 : .16);
              const shove = (triMode ? 170 : 230) + (triMode ? 120 : 250) * ropePow;
              const dirx = triMode ? p.zx : p.slDx;
              const diry = triMode ? p.zy : p.slDy;
              m.vx += dirx * shove;
              m.vy += diry * shove;
              m.tc = triMode ? .08 : .06;
              zoomHits++;
              burst(m.x, m.y, triMode ? '#95edff' : '#bff8ff', triMode ? 3 : 5, triMode ? 34 : 48);
              if (m.hp <= 0) {
                killZombie(i, triMode ? '#95edff' : '#bff8ff', triMode ? 9 : 11, triMode ? 70 : 84, 1);
                zoomKills++;
                continue;
              }
            }
          }
          if ((p.slT > 0 || p.slRecallT > 0) && bots.length >= 2) {
            const recallOnly = p.slT <= 0 && p.slRecallT > 0;
            let slammed = 0;
            for (let bi = 0; bi < Math.min(3, bots.length); bi++) {
              const bt = bots[bi], bx = m.x - bt.x, by = m.y - bt.y, hitR = m.r + (recallOnly ? 20 : 22);
              if (bx * bx + by * by < hitR * hitR && ((m.tc || 0) <= 0)) {
                const slamMul = ((recallOnly ? 1.05 : 1.45) + (recallOnly ? 1.05 : 1.75) * p.slPow) * p.slScale;
                const slam = p.zDmg * slamMul * (m.k >= 3 ? .82 : (recallOnly ? 1 : 1.05));
                m.hp -= slam;
                m.ht = .18;
                const bl = Math.hypot(bx, by) || 1;
                const dirL = Math.hypot(p.x - bt.x, p.y - bt.y) || 1;
                const dirx = recallOnly ? (p.x - bt.x) / dirL : p.slDx;
                const diry = recallOnly ? (p.y - bt.y) / dirL : p.slDy;
                const push = (recallOnly ? 240 : 340) + (recallOnly ? 190 : 320) * p.slPow;
                m.vx += dirx * push + bx / bl * (130 + 100 * p.slPow);
                m.vy += diry * push + by / bl * (130 + 100 * p.slPow);
                m.tc = recallOnly ? .08 : .095;
                zoomHits++;
                burst(m.x, m.y, recallOnly ? '#bdf7ff' : '#8eefff', recallOnly ? 5 : 7, recallOnly ? 52 : 64);
                slammed = 1;
                if (!recallOnly) {
                  const bit = 1 << bi;
                  if (!(p.slHitMask & bit)) p.slHitMask |= bit;
                  const fullMask = (1 << Math.min(bots.length, 3)) - 1;
                  if (!slBurst && p.slHitMask === fullMask) {
                    slBurst = 1;
                    slBurstPow = Math.max(slBurstPow, p.slPow);
                    p.slLinkT = Math.max(p.slLinkT, (SLINGSHOT_LINK_MIN + .55 * SLINGSHOT_LINK_HOLD) * p.slScale);
                    p.slWave = Math.max(p.slWave, .95 * p.slScale);
                    p.slComboFx = Math.max(p.slComboFx, 1.2 * p.slScale);
                    g.msg = bots.length >= 3 ? 'triple crack' : 'duo crack';
                    g.msgT = .7;
                    beep(1240, .04, 'square', .024);
                    beep(820, .05, 'triangle', .017);
                  }
                }
                if (m.hp <= 0) {
                  killZombie(i, recallOnly ? '#bdf7ff' : '#8eefff', recallOnly ? 9 : 12, recallOnly ? 76 : 92, 1);
                  zoomKills++;
                  break;
                }
              }
            }
            if (slammed && m.hp <= 0) continue;
          }
          if (m.tc > 0) m.tc = Math.max(0, m.tc - dt);
          if (m.k === 4) {
            const phase = m.apPhase || 1;
            if (inPlayerStorm) {
              sf = Math.min(sf, .22);
              reactDot += (p.chDo * 3.5 + 38);
              if ((m.sc || 0) <= 0) { m.sc = .18; burst(m.x, m.y, '#8effdc', 8, 58); }
            } else {
              const floor = phase >= 3 ? .72 : phase === 2 ? .62 : .54;
              sf = Math.max(sf, floor);
            }
          }
          if (m.fb > 0 && (m.k !== 3 && m.k !== 4 && m.k !== 5 && m.k !== 9 && m.k !== 11)) sf = Math.max(sf, 1.08);
          if (m.fbSt > 0) {
            sf = Math.min(sf, isBossType(m.k) ? .78 : .56);
            m.ht = Math.max(m.ht, .1);
          }
          m.sl = inPad;
          if (inPad) {
            const dot = (p.cat && inAcidPad) ? p.chDo : 0;
            if (dot > 0) m.hp -= dot * dt;
            m.ht = Math.max(m.ht, .08);
            if (m.hp <= 0) { killZombie(i, '#f7d96b', 8, 60); continue; }
          }
          if (reactDot > 0) {
            m.hp -= reactDot * dt;
            m.ht = Math.max(m.ht, .11);
            if (m.hp <= 0) { killZombie(i, '#c8f3ff', 10, 76, 1); continue; }
          }
          if (m.ce > 0) m.ce = Math.max(0, m.ce - dt);
          m.vx *= Math.max(0, 1 - dt * 8);
          m.vy *= Math.max(0, 1 - dt * 8);
          m.ht = Math.max(0, m.ht - dt);
          m.x += (dx / ln * m.s * sf + m.vx) * dt;
          m.y += (dy / ln * m.s * sf + m.vy) * dt;
          if (pushOutsideSafe(m, 6)) {
            m.vx *= .4;
            m.vy *= .4;
          }
          const cdx = p.x - m.x, cdy = p.y - m.y, cln = Math.hypot(cdx, cdy) || 1;
          if (cln < m.r + p.r - 1) {
            if (p.zt > 0) {
              m.hp -= p.zDmg;
              m.ht = .12;
              m.vx += p.zx * 280;
              m.vy += p.zy * 280;
              zoomHits++;
              if (m.hp <= 0) {
                killZombie(i, '#8fffe5', 12, 90, 1);
                zoomKills++;
                continue;
              }
              contact += m.dmg * .35;
              continue;
            }
            if (m.k === 4 && m.apImpactCd <= 0 && !pSafeNow) {
              m.apImpactCd = .9;
              addApexStorm(clamp(p.x + rnd(-16, 16), 24, MAP_W - 24), clamp(p.y + rnd(-16, 16), 24, MAP_H - 24), 68 + (m.apPhase || 1) * 10, 2.2 + (m.apPhase || 1) * .35);
              burst(p.x, p.y, '#e1c6ff', 10, 84);
              trauma(.15);
            }
            let cDmg = m.k === 4 ? m.dmg * 1.2 : m.dmg;
            if (m.fb > 0) {
              const boss = m.k === 3 || m.k === 4 || m.k === 5 || m.k === 9 || m.k === 11;
              cDmg *= boss ? .8 : .35;
            }
            contact += cDmg;
          }
        }
        if (p.slRecallPulse) {
          p.slRecallPulse = 0;
          const rr = SLINGSHOT_RECALL_BURST_RADIUS * (.88 + .24 * Math.min(1, p.slPow)) * p.slScale;
          const rr2 = rr * rr;
          const dmgBase = p.zDmg * (.48 + .62 * Math.min(1, p.slPow)) * p.slScale;
          let recallHits = 0;
          for (let i = z.length - 1; i >= 0; i--) {
            const m = z[i], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
            if (d2 > rr2) continue;
            const d = Math.sqrt(d2) || 1, q = 1 - d / rr;
            m.hp -= dmgBase * (.58 + .42 * q);
            m.ht = Math.max(m.ht, .13);
            const push = 170 + 220 * q * (.7 + .3 * Math.min(1, p.slPow));
            m.vx += dx / d * push;
            m.vy += dy / d * push;
            recallHits++;
            zoomHits++;
            if (Math.random() < .26) burst(m.x, m.y, '#cdf9ff', 3, 34);
            if (m.hp <= 0) {
              killZombie(i, '#cdf9ff', 10, 78, 1);
              zoomKills++;
            }
          }
          p.slWave = Math.max(p.slWave, .78);
          p.slComboFx = Math.max(p.slComboFx, .48);
          burst(p.x, p.y, '#cdf9ff', 16, 104 + 66 * Math.min(1, p.slPow));
          if (recallHits > 0) {
            g.msg = 'recall burst';
            g.msgT = .55;
            hitStop(.035 + .015 * Math.min(1, p.slPow));
            trauma(.08 + .07 * Math.min(1, p.slPow));
            beep(900, .03, 'square', .018);
          }
        }
        if (slBurst) {
          const rr = SLINGSHOT_TRIPLE_BURST_RADIUS * (.9 + .35 * slBurstPow) * p.slScale;
          const rr2 = rr * rr;
          const dmgBase = p.zDmg * (.7 + 1.1 * slBurstPow) * p.slScale;
          for (let i = z.length - 1; i >= 0; i--) {
            const m = z[i], dx = m.x - p.x, dy = m.y - p.y, d2 = dx * dx + dy * dy;
            if (d2 > rr2) continue;
            const d = Math.sqrt(d2) || 1, q = 1 - d / rr;
            m.hp -= dmgBase * (.55 + .45 * q);
            m.ht = Math.max(m.ht, .14);
            const push = 220 + 280 * slBurstPow * q;
            m.vx += dx / d * push;
            m.vy += dy / d * push;
            zoomHits++;
            if (Math.random() < .32) burst(m.x, m.y, '#b8f6ff', 3, 40);
            if (m.hp <= 0) {
              killZombie(i, '#b8f6ff', 11, 86, 1);
              zoomKills++;
            }
          }
          hitStop(.06 + .03 * Math.min(1, slBurstPow));
          trauma(.2 + .14 * Math.min(1, slBurstPow));
          burst(p.x, p.y, '#b8f6ff', 20, 130 + 90 * slBurstPow);
        }
        if (zoomHits > 0) {
          hitStop(Math.min(.04, .012 * zoomHits));
          trauma(Math.min(.24, .04 * zoomHits));
          g.xpPulse = Math.min(.6, g.xpPulse + .06 * zoomHits);
          beep(260, .02, 'square', .016);
          if (zoomKills > 1) beep(310, .02, 'square', .013);
        }
        if (contact > 0) hitPlayer(contact * dt);

        // food pickups
        for (let i = food.length - 1; i >= 0; i--) {
          const f = food[i];
          const dx = p.x - f.x, dy = p.y - f.y, ln = Math.hypot(dx, dy) || 1;
          if (p.bot && bots.length) {
            if (f.bc) {
              const bi = (f.bc | 0) - 1;
              const bt = bi >= 0 && bi < bots.length ? bots[bi] : bots[0];
              const bs = botStats(bt.t | 0 || 1);
              const bdx = bt.x - f.x, bdy = bt.y - f.y, bln = Math.hypot(bdx, bdy) || 1;
              const sp = Math.min(bs.pull * 1.3, bln * 13);
              f.x += bdx / bln * sp * dt; f.y += bdy / bln * sp * dt;
            } else {
              let carryCap = 0;
              for (let bi = 0; bi < bots.length; bi++)carryCap += botStats(bots[bi].t | 0 || 1).carry;
              if (p.bCarry < carryCap && ln > p.magnet * 1.45) {
                for (let bi = 0; bi < bots.length; bi++) {
                  const bt = bots[bi];
                  if (bt.grabCd > 0) continue;
                  const bs = botStats(bt.t | 0 || 1);
                  const bdx = bt.x - f.x, bdy = bt.y - f.y, bln = Math.hypot(bdx, bdy) || 1;
                  if (bln < bs.fetch) {
                    f.x += bdx / bln * bs.pull * dt; f.y += bdy / bln * bs.pull * dt;
                    if (bln < 10) {
                      f.bc = bi + 1;
                      p.bCarry++;
                      bt.grabCd = bs.grab;
                      burst(f.x, f.y, '#9de6ff', 3, 24);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (ln < p.magnet) { f.x += dx / ln * 240 * dt; f.y += dy / ln * 240 * dt }
          if (ln < p.r + 8) {
            collectMint(i, f.bc ? 'bot' : 'player');
          }
        }

        if ((keys.gr || touchMove) && Math.random() < .04 && g.time > 2) {
          pushFood({ x: clamp(p.x + rnd(-20, 20), 12, MAP_W - 12), y: clamp(p.y + rnd(-20, 20), 12, MAP_H - 12), v: 4, m: 1, t: 0 });
        }

        // --- FIRST BOSS mint eating (runs AFTER player pickup so Scotty always has priority) ---
        if (g.bs) {
          for (let i = 0; i < z.length; i++) {
            const m = z[i];
            if (m.k !== 3 || m.b1Cd > 0) continue;
            // boss only eats mints that overlap its body
            for (let fi = food.length - 1; fi >= 0; fi--) {
              const f = food[fi], fdx = f.x - m.x, fdy = f.y - m.y, fd = Math.hypot(fdx, fdy);
              if (fd < m.r) {
                // skip if mint is also in Scotty's magnet range (player priority)
                const pdist = Math.hypot(f.x - p.x, f.y - p.y);
                if (pdist < p.magnet) continue;
                food.splice(fi, 1);
                m.b1Eat = (m.b1Eat || 0) + 1;
                m.b1Cd = BOSS1_EAT_CD;
                m.b1Pulse = .35;
                const e = m.b1Eat;
                // diminishing growth: each eat is slightly less effective
                const dim = 1 / (1 + e * .035);
                m.r = (m.b1BaseR) + e * BOSS1_GROW_R * dim;
                m.hp = Math.min(m.hp + BOSS1_GROW_HP * dim, m.b1Max + BOSS1_GROW_HP * dim);
                m.b1Max += BOSS1_GROW_HP * dim;
                m.dmg = (m.b1BaseDmg) + e * BOSS1_GROW_DMG * dim;
                m.s = (m.b1BaseS) + e * BOSS1_GROW_SPD * dim;
                burst(m.x, m.y, '#69f0c9', 6, m.r + 18);
                beep(120 + e * 6, .06, 'sawtooth', .018);
                if (e % 5 === 0) {
                  m.b1Roar = .6;
                  trauma(.14);
                  burst(m.x, m.y, '#a789ff', 14, m.r + 50);
                  beep(80, .12, 'sawtooth', .028);
                  g.msg = 'the dean grows stronger!'; g.msgT = 1.4;
                }
              }
            }
          }
        }
      }

      function cam() { return { x: clamp(p.x - W * .5, 0, MAP_W - W), y: clamp(p.y - H * .5, 0, MAP_H - H) } }

      function draw() {
        const sk = g.shake * g.shake;
        const sx = (Math.random() * 2 - 1) * 10 * sk;
        const sy = (Math.random() * 2 - 1) * 10 * sk;
        x.setTransform(DPR, 0, 0, DPR, sx, sy);
        const cm = cam();

        // bg
        const g1 = x.createLinearGradient(0, 0, 0, H); g1.addColorStop(0, '#263f60'); g1.addColorStop(.55, '#16273f'); g1.addColorStop(1, '#0b111a');
        x.fillStyle = g1; x.fillRect(0, 0, W, H);

        // grid doodle
        x.strokeStyle = 'rgba(63,96,132,.35)'; x.lineWidth = 1;
        const step = 56, ox = -(cm.x % step), oy = -(cm.y % step);
        for (let yy = oy; yy < H; yy += step) { x.beginPath(); x.moveTo(0, yy | 0); x.lineTo(W, yy | 0); x.stroke() }
        for (let xx = ox; xx < W; xx += step) { x.beginPath(); x.moveTo(xx | 0, 0); x.lineTo(xx | 0, H); x.stroke() }

        // middle mint zone tint
        const mx = MID_X - cm.x, my = MID_Y - cm.y;
        x.fillStyle = 'rgba(105,240,201,.07)'; x.beginPath(); x.arc(mx, my, 210, 0, Math.PI * 2); x.fill();

        // school zones
        const inBuild = safeBuildingAt(p.x, p.y, -8);
        for (let i = 0; i < SAFE_BUILDINGS.length; i++) {
          const s = SAFE_BUILDINGS[i], sx = s.x - cm.x, sy = s.y - cm.y;
          if (sx < -s.r - 30 || sy < -s.r - 30 || sx > W + s.r + 30 || sy > H + s.r + 30) continue;
          const done = s.id === 'home' ? 0 : g.sch[s.id] === 2;
          const active = s.id === 'home' ? !p.mkOn : (
            g.sch[s.id] === 1 ||
            (s.id === 'nsh' && (g.sch.nsh === 0 || (g.sch.nsh === 2 && g.sch.bak === 2 && g.labNsh > 0))) ||
            (s.id === 'mel' && ((g.sch.nsh === 2 && g.sch.mel === 0) || (g.sch.mel === 2 && g.sch.bak === 2 && g.labMel > 0))) ||
            (s.id === 'bak' && (g.sch.bak === 1 || (g.sch.mel === 2 && g.sch.bak === 0)))
          );
          x.globalAlpha = done ? .18 : active ? .14 : .08;
          x.fillStyle = s.c; x.beginPath(); x.arc(sx, sy, s.r, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .65;
          x.strokeStyle = done ? '#9effc8' : s.c; x.lineWidth = 2; x.beginPath(); x.arc(sx, sy, s.r, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = 1;
          x.fillStyle = '#dce8ff'; x.font = '600 12px Trebuchet MS,sans-serif'; x.fillText(s.n, sx - s.r + 10, sy - s.r - 8);
          const bw = s.id === 'home' ? 48 : 44, bh = 30, bx = sx - bw * .5, by = sy - bh * .5;
          x.fillStyle = 'rgba(18,25,37,.9)'; x.fillRect(bx, by, bw, bh);
          x.strokeStyle = 'rgba(165,190,220,.55)'; x.lineWidth = 1; x.strokeRect((bx + .5) | 0, (by + .5) | 0, bw - 1, bh - 1);
          x.fillStyle = 'rgba(248,234,164,.86)'; x.fillRect((bx + 6) | 0, (by + 6) | 0, 11, 8); x.fillRect((bx + bw - 17) | 0, (by + 6) | 0, 11, 8);
          x.fillStyle = 'rgba(44,56,72,.95)'; x.beginPath(); x.arc(bx + 11 + Math.sin(g.t * 2 + i), by + 11, 1.7, 0, Math.PI * 2); x.fill(); x.beginPath(); x.arc(bx + bw - 11 + Math.sin(g.t * 2 + i + 1), by + 11, 1.7, 0, Math.PI * 2); x.fill();
          if (g.start && !g.dead) {
            const wl = inBuild ? WHI : WHO;
            const wt = wl[((g.t * .45 + i * 2) | 0) % wl.length], wy = sy - s.r * .44, ww = wt.length * 4.6 + 12;
            x.fillStyle = 'rgba(8,12,20,.82)'; rr(sx - ww * .5, wy - 9, ww, 16, 7); x.fill();
            x.fillStyle = 'rgba(220,240,255,.9)'; x.font = '600 9px Trebuchet MS,sans-serif'; x.fillText(wt, sx - ww * .5 + 6, wy + 3);
          }
        }

        // food
        for (let i = 0; i < food.length; i++) {
          const f = food[i], sx = f.x - cm.x, sy = f.y - cm.y;
          if (sx < -10 || sy < -10 || sx > W + 10 || sy > H + 10) continue;
          x.fillStyle = '#69f0c9'; x.beginPath(); x.arc(sx, sy, 5, 0, Math.PI * 2); x.fill();
          x.fillStyle = '#ceffef'; x.fillRect((sx - 1) | 0, (sy - 1) | 0, 2, 2);
        }
        // territory puddles
        for (let i = 0; i < pudd.length; i++) {
          const pd = pudd[i], sx = pd.x - cm.x, sy = pd.y - cm.y;
          if (sx < -pd.r - 20 || sy < -pd.r - 20 || sx > W + pd.r + 20 || sy > H + pd.r + 20) continue;
          const q = pd.t / pd.d;
          x.globalAlpha = .24 + .22 * q;
          let pf = '#f4d96e', ps = '#fff0a9';
          if (p.cat) {
            if (pd.m === 1) { pf = '#53d93d'; ps = '#baff87'; }
            else if (pd.m === 2) { pf = '#42cdb9'; ps = '#a8f6ea'; }
            else if (pd.m === 3) { pf = '#597fd6'; ps = '#bdd4ff'; }
          }
          x.fillStyle = pf;
          x.beginPath(); x.arc(sx, sy, pd.r, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .34 + .28 * Math.sin((g.t + i) * 5) * q;
          x.strokeStyle = ps; x.lineWidth = 1.9;
          x.beginPath(); x.arc(sx, sy, pd.r * .68 + Math.sin((g.t + i) * 4) * 2, 0, Math.PI * 2); x.stroke();
          if (p.cat) {
            if (pd.m === 3) {
              x.globalAlpha = .1 + .08 * q;
              x.strokeStyle = 'rgba(175,205,255,.72)'; x.lineWidth = 1.25;
              x.beginPath(); x.arc(sx, sy, pd.r * 2.35 * (.97 + .03 * Math.sin(g.t * 2 + i)), 0, Math.PI * 2); x.stroke();
              x.globalAlpha = .08 + .07 * q;
              x.strokeStyle = 'rgba(140,174,255,.58)'; x.lineWidth = 1;
              x.beginPath(); x.arc(sx, sy, pd.r * 1.6 * (.96 + .04 * Math.sin(g.t * 2.7 + i * .8)), 0, Math.PI * 2); x.stroke();
            }
            x.globalAlpha = .18 + .24 * q;
            if (pd.m === 1) x.fillStyle = '#dbff8f';
            else if (pd.m === 2) x.fillStyle = '#d8fff7';
            else if (pd.m === 3) x.fillStyle = '#e1ebff';
            else x.fillStyle = '#f1ffb3';
            x.beginPath(); x.arc(sx + Math.sin(g.t * 4 + i) * pd.r * .22, sy - pd.r * .16, 2.4 + Math.sin(g.t * 7 + i) * .7, 0, Math.PI * 2); x.fill();
            x.beginPath(); x.arc(sx - pd.r * .18, sy + Math.sin(g.t * 3 + i * .7) * pd.r * .14, 1.9 + Math.sin(g.t * 8 + i * .4) * .5, 0, Math.PI * 2); x.fill();
            x.beginPath(); x.arc(sx + pd.r * .12, sy + pd.r * .2, 1.6 + Math.sin(g.t * 6 + i * .5) * .4, 0, Math.PI * 2); x.fill();
          }
          x.globalAlpha = 1;
        }
        // fused reaction puddles
        for (let i = 0; i < react.length; i++) {
          const rc = react[i], sx = rc.x - cm.x, sy = rc.y - cm.y;
          if (sx < -rc.r - 40 || sy < -rc.r - 40 || sx > W + rc.r + 40 || sy > H + rc.r + 40) continue;
          const q = rc.t / rc.d, pulse = .86 + .12 * Math.sin(g.t * 5 + i), rr = rc.r * pulse;
          let fill = '#95f0b8', stroke = '#d6ffea', inner = '#6ae9b4';
          if (rc.k === 2) { fill = '#7cf6e7'; stroke = '#d8fff7'; inner = '#a0fff0'; }
          else if (rc.k === 3) { fill = '#c5f690'; stroke = '#efffd0'; inner = '#d9ffab'; }
          else if (rc.k === 4) { fill = '#bde9ff'; stroke = '#f0fbff'; inner = '#d4f2ff'; }
          else if (rc.k === 5) { fill = '#b89edf'; stroke = '#d8c4f0'; inner = '#c4a8e8'; }
          x.globalAlpha = .14 + .16 * q;
          x.fillStyle = fill;
          x.beginPath(); x.arc(sx, sy, rr, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .28 + .24 * q;
          x.strokeStyle = stroke; x.lineWidth = 2;
          x.beginPath(); x.arc(sx, sy, rr * .78, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = .2 + .2 * q;
          x.strokeStyle = inner; x.lineWidth = 1.4;
          x.beginPath(); x.arc(sx, sy, rr * (1.08 + .05 * Math.sin(g.t * 7 + i)), 0, Math.PI * 2); x.stroke();
          if (rc.k === 4) {
            for (let n = 0; n < 3; n++) {
              const a = g.t * 5.6 + n * 2.1, px = sx + Math.cos(a) * rr * .62, py = sy + Math.sin(a) * rr * .62;
              x.globalAlpha = .5 + .3 * q;
              x.fillStyle = '#f2fcff';
              x.beginPath(); x.arc(px, py, 2.3, 0, Math.PI * 2); x.fill();
            }
          }
          if (rc.k === 5) {
            for (let n = 0; n < 4; n++) {
              const a = g.t * (-4.2) + n * 1.57, px = sx + Math.cos(a) * rr * .55, py = sy + Math.sin(a) * rr * .55;
              x.globalAlpha = .35 + .25 * q;
              x.fillStyle = '#e0c8ff';
              x.beginPath(); x.arc(px, py, 2, 0, Math.PI * 2); x.fill();
            }
            x.globalAlpha = .08 + .1 * q;
            x.strokeStyle = '#9b7ccc'; x.lineWidth = 1.8;
            x.beginPath(); x.arc(sx, sy, rr * (.5 + .08 * Math.sin(g.t * 9 + i)), 0, Math.PI * 2); x.stroke();
          }
          x.globalAlpha = 1;
        }
        // psych combo fields
        for (let i = 0; i < psyFx.length; i++) {
          const q = psyFx[i], qq = clamp(q.t / Math.max(.001, q.d), 0, 1);
          if (q.k === 3) {
            const sx = q.x - cm.x, sy = q.y - cm.y, rr = q.r * (.92 + .08 * Math.sin(g.t * 4 + i));
            x.globalAlpha = .12 + .16 * qq;
            x.fillStyle = '#9af5c8';
            x.beginPath(); x.arc(sx, sy, rr, 0, Math.PI * 2); x.fill();
            x.globalAlpha = .34 + .24 * qq;
            x.strokeStyle = '#d7ffe9'; x.lineWidth = 2;
            x.beginPath(); x.arc(sx, sy, rr * .72, 0, Math.PI * 2); x.stroke();
            x.globalAlpha = 1;
            continue;
          }
          const ax = q.x - q.dx * q.len - cm.x, ay = q.y - q.dy * q.len - cm.y;
          const bx = q.x + q.dx * q.len - cm.x, by = q.y + q.dy * q.len - cm.y;
          x.globalAlpha = .1 + .16 * qq;
          x.strokeStyle = q.k === 2 ? '#bedfff' : '#a9d9ff';
          x.lineWidth = q.w * (q.k === 2 ? 1.7 : 1.45);
          x.beginPath(); x.moveTo(ax, ay); x.lineTo(bx, by); x.stroke();
          x.globalAlpha = .38 + .24 * qq;
          x.strokeStyle = q.k === 2 ? '#e4f3ff' : '#d1ecff';
          x.lineWidth = 2;
          x.beginPath(); x.moveTo(ax, ay); x.lineTo(bx, by); x.stroke();
          if (q.k === 2) {
            const pulse = .5 + .5 * Math.sin((1 - qq) * Math.PI * 8);
            const cx = ax + (bx - ax) * (.2 + .6 * pulse), cy = ay + (by - ay) * (.2 + .6 * pulse);
            x.globalAlpha = .6 + .24 * qq;
            x.fillStyle = '#eef8ff';
            x.beginPath(); x.arc(cx, cy, 3.2, 0, Math.PI * 2); x.fill();
          }
          x.globalAlpha = 1;
        }

        // zombies
        for (let i = 0; i < z.length; i++) {
          const m = z[i], sx = m.x - cm.x, sy = m.y - cm.y;
          if (sx < -40 || sy < -40 || sx > W + 40 || sy > H + 40) continue;
          const panic = (m.fb || 0) > 0;
          const mc = panic ? '#8bcfff' : (m.k === 12 ? '#884488' : m.k === 11 ? '#aa22aa' : m.k === 10 ? '#661122' : m.k === 9 ? '#bb1122' : m.k === 8 ? '#3dba5a' : m.k === 7 ? '#8899aa' : m.k === 6 ? '#d95530' : m.k === 5 ? '#cc7a2e' : m.k === 4 ? '#713ce8' : m.k === 3 ? '#a789ff' : m.k === 2 ? '#665a78' : m.k === 1 ? '#5687a1' : (m.sl ? '#70805a' : '#4b667f'));
          // predator cloak: near-invisible when cloaked
          if (m.k === 9 && (m.prCloak || 0) > 0) {
            const cq = clamp((m.prCloak || 0) / 1.5, 0, 1);
            x.globalAlpha = .06 + .08 * Math.sin(g.t * 12 + i);
            x.fillStyle = '#bb1122'; x.beginPath(); x.arc(sx, sy, m.r, 0, Math.PI * 2); x.fill();
            // shimmer distortion
            x.globalAlpha = .04 + .03 * Math.sin(g.t * 20 + i * 3);
            x.strokeStyle = '#ff4444'; x.lineWidth = 1;
            x.beginPath(); x.arc(sx + Math.sin(g.t * 8) * 4, sy + Math.cos(g.t * 7) * 4, m.r + 6, 0, Math.PI * 2); x.stroke();
            x.globalAlpha = 1;
          } else if (m.k === 10) {
            // shadow clone: semi-transparent + flickery
            const clQ = clamp((m.cloneLife || 0) / 2, 0, 1);
            x.globalAlpha = .3 + .2 * clQ + .1 * Math.sin(g.t * 14 + i);
            x.fillStyle = mc; x.beginPath(); x.arc(sx, sy, m.r, 0, Math.PI * 2); x.fill();
            x.fillStyle = '#ff3344'; x.fillRect((sx - 3) | 0, (sy - 2) | 0, 2, 2); x.fillRect((sx + 1) | 0, (sy - 2) | 0, 2, 2);
            x.globalAlpha = 1;
          } else {
            x.fillStyle = m.ht > 0 ? '#9db4d1' : mc; x.beginPath(); x.arc(sx, sy, m.r, 0, Math.PI * 2); x.fill();
          }
          if (m.k !== 9 || (m.prCloak || 0) <= 0) if (m.k !== 10) { x.fillStyle = '#f0627c'; x.fillRect((sx - 4) | 0, (sy - 2) | 0, 3, 3); x.fillRect((sx + 1) | 0, (sy - 2) | 0, 3, 3); }
          if (panic) {
            const pq = clamp((m.fb || 0) / Math.max(.001, p.fbFear), 0, 1);
            x.globalAlpha = .14 + .2 * pq;
            x.strokeStyle = '#c5ebff';
            x.lineWidth = 1.6;
            x.beginPath(); x.arc(sx, sy, m.r + 4 + Math.sin(g.t * 12 + i) * 1.6, 0, Math.PI * 2); x.stroke();
            x.globalAlpha = 1;
          }
          if ((m.psJ || 0) > 0 || (m.psF || 0) > 0 || (m.psD || 0) > 0) {
            let cx = sx - 8;
            if ((m.psJ || 0) > 0) { x.fillStyle = '#9ed9ff'; x.beginPath(); x.arc(cx, sy - m.r - 8, 2.1, 0, Math.PI * 2); x.fill(); cx += 8; }
            if ((m.psF || 0) > 0) { x.fillStyle = '#9fe9ff'; x.beginPath(); x.arc(cx, sy - m.r - 8, 2.1, 0, Math.PI * 2); x.fill(); cx += 8; }
            if ((m.psD || 0) > 0) { x.fillStyle = '#c8d4ff'; x.beginPath(); x.arc(cx, sy - m.r - 8, 2.1, 0, Math.PI * 2); x.fill(); }
          }
          // --- NEW ENEMY TYPE VISUALS ---
          if (m.k === 5) {
            // mini-boss: orange ring + charge trail
            const mbHp = clamp(m.hp / ((m.mbMax || m.hp) || 1), 0, 1);
            x.globalAlpha = .3 + .15 * Math.sin(g.t * 6 + i);
            x.strokeStyle = '#ffa64d'; x.lineWidth = 2.2;
            x.beginPath(); x.arc(sx, sy, m.r + 7 + Math.sin(g.t * 5) * 2, 0, Math.PI * 2); x.stroke();
            if ((m.mbChargeT || 0) > 0) {
              x.globalAlpha = .25;
              x.fillStyle = '#ffa64d';
              x.beginPath(); x.arc(sx - (m.mbDx || 0) * 22, sy - (m.mbDy || 0) * 22, m.r * .7, 0, Math.PI * 2); x.fill();
            }
            // HP bar
            const bw5 = m.r * 2.2, bx5 = sx - bw5 * .5, by5 = sy - m.r - 12;
            x.globalAlpha = .85;
            x.fillStyle = 'rgba(10,14,22,.9)'; x.fillRect(bx5 - 1, by5 - 1, bw5 + 2, 5);
            x.fillStyle = '#664420'; x.fillRect(bx5, by5, bw5, 3);
            x.fillStyle = mbHp > .5 ? '#ffa64d' : '#ff6633'; x.fillRect(bx5, by5, bw5 * mbHp, 3);
            x.globalAlpha = 1;
          }
          if (m.k === 6) {
            // exploder: pulsing red-orange glow
            const pulse6 = .5 + .5 * Math.sin(g.t * 8 + i);
            x.globalAlpha = .12 + .10 * pulse6;
            x.fillStyle = '#ff4422';
            x.beginPath(); x.arc(sx, sy, m.r + 6 + pulse6 * 4, 0, Math.PI * 2); x.fill();
            x.globalAlpha = .4;
            x.fillStyle = '#ffaa44';
            x.beginPath(); x.arc(sx, sy, 2.5, 0, Math.PI * 2); x.fill();
            x.globalAlpha = 1;
          }
          if (m.k === 7) {
            // shielded: front-facing shield arc
            const toP = Math.atan2(p.y - m.y, p.x - m.x);
            x.globalAlpha = .22 + .08 * Math.sin(g.t * 4 + i);
            x.strokeStyle = '#aabbcc'; x.lineWidth = 3;
            x.beginPath(); x.arc(sx, sy, m.r + 5, toP - .8, toP + .8); x.stroke();
            x.globalAlpha = 1;
          }
          if (m.k === 8) {
            // healer: green cross + heal aura
            x.globalAlpha = .6;
            x.fillStyle = '#7fff7f';
            x.fillRect((sx - 1.5) | 0, (sy - 5) | 0, 3, 10);
            x.fillRect((sx - 5) | 0, (sy - 1.5) | 0, 10, 3);
            if ((m.healCd || 0) < .4) {
              x.globalAlpha = .10 + .08 * (1 - (m.healCd || 0) / .4);
              x.strokeStyle = '#7fff7f'; x.lineWidth = 1.2;
              x.beginPath(); x.arc(sx, sy, 120 * (1 - (m.healCd || 0) / .4), 0, Math.PI * 2); x.stroke();
            }
            x.globalAlpha = 1;
          }
          if (m.k === 9 && (m.prCloak || 0) <= 0) {
            // predator visible: menacing red glow, eyes, HP bar
            const prHpR = clamp(m.hp / ((m.prMax || m.hp) || 1), 0, 1);
            const prRage = prHpR <= .5 ? 1 : 0;
            // outer aura
            const prPulse = .5 + .5 * Math.sin(g.t * 4 + i);
            x.globalAlpha = .12 + .08 * prPulse + .06 * prRage;
            x.fillStyle = prRage ? '#ff1111' : '#bb2233';
            x.beginPath(); x.arc(sx, sy, m.r + 16 + prPulse * 5, 0, Math.PI * 2); x.fill();
            // menacing ring
            x.globalAlpha = .35 + .15 * Math.sin(g.t * 6);
            x.strokeStyle = prRage ? '#ff3333' : '#cc2244'; x.lineWidth = 2.5;
            x.beginPath(); x.arc(sx, sy, m.r + 10 + Math.sin(g.t * 5) * 3, 0, Math.PI * 2); x.stroke();
            // red glowing eyes
            x.globalAlpha = .9;
            x.fillStyle = '#ff2222';
            x.beginPath(); x.arc(sx - 5, sy - 3, 2.5 + prRage * .5, 0, Math.PI * 2); x.fill();
            x.beginPath(); x.arc(sx + 5, sy - 3, 2.5 + prRage * .5, 0, Math.PI * 2); x.fill();
            // lunge trail
            if ((m.prLunge || 0) > 0) {
              x.globalAlpha = .2;
              x.fillStyle = '#ff2222';
              x.beginPath(); x.arc(sx - (m.prLungeDx || 0) * 30, sy - (m.prLungeDy || 0) * 30, m.r * .8, 0, Math.PI * 2); x.fill();
              x.beginPath(); x.arc(sx - (m.prLungeDx || 0) * 55, sy - (m.prLungeDy || 0) * 55, m.r * .5, 0, Math.PI * 2); x.fill();
            }
            // HP bar
            const pw = Math.max(50, m.r * 2.6), ph = 6, px2 = sx - pw * .5, py2 = sy - m.r - 18;
            x.globalAlpha = .88;
            x.fillStyle = 'rgba(10,6,6,.92)'; x.fillRect(px2 - 2, py2 - 2, pw + 4, ph + 4);
            x.fillStyle = '#3a1015'; x.fillRect(px2, py2, pw, ph);
            const fg9 = x.createLinearGradient(px2, 0, px2 + pw, 0);
            fg9.addColorStop(0, prRage ? '#ff2222' : '#cc2244');
            fg9.addColorStop(1, prRage ? '#ff6644' : '#ee4466');
            x.fillStyle = fg9; x.fillRect(px2, py2, pw * prHpR, ph);
            x.globalAlpha = 1;
          }
          if (m.k === 11) {
            // mother boss: purple aura, scream ring, wave pulse, HP bar
            const moHpR = clamp(m.hp / ((m.moMax || m.hp) || 1), 0, 1);
            const moRage = (m.moRage || 0);
            const moPulse = .5 + .5 * Math.sin(g.t * 3.5 + i);
            // outer aura
            x.globalAlpha = .10 + .06 * moPulse + .05 * moRage;
            x.fillStyle = moRage > 1 ? '#dd22dd' : '#aa33aa';
            x.beginPath(); x.arc(sx, sy, m.r + 22 + moPulse * 6 + moRage * 8, 0, Math.PI * 2); x.fill();
            // pulsing ring
            x.globalAlpha = .3 + .15 * Math.sin(g.t * 5);
            x.strokeStyle = moRage > 1 ? '#ff44ff' : '#cc44cc'; x.lineWidth = 3 + moRage;
            x.beginPath(); x.arc(sx, sy, m.r + 12 + Math.sin(g.t * 4.5) * 3, 0, Math.PI * 2); x.stroke();
            // scream shockwave
            if ((m.moScreamT || 0) > 0) {
              const sq = clamp((m.moScreamT || 0) / 1.6, 0, 1);
              x.globalAlpha = .15 * sq;
              x.strokeStyle = '#ff66ff'; x.lineWidth = 4;
              x.beginPath(); x.arc(sx, sy, (320 + moRage * 60) * (1 - sq * .3), 0, Math.PI * 2); x.stroke();
            }
            // wave pulse ring
            if ((m.moWaveT || 0) > 0) {
              const wq = (m.moWaveT || 0) / .6;
              x.globalAlpha = .2 * wq;
              x.fillStyle = '#ee55ee';
              x.beginPath(); x.arc(sx, sy, (180 + moRage * 50) * (1 - wq * .4), 0, Math.PI * 2); x.fill();
            }
            // eyes
            x.globalAlpha = .9;
            x.fillStyle = '#ff44ff';
            x.beginPath(); x.arc(sx - 8, sy - 4, 3 + moRage * .5, 0, Math.PI * 2); x.fill();
            x.beginPath(); x.arc(sx + 8, sy - 4, 3 + moRage * .5, 0, Math.PI * 2); x.fill();
            x.fillStyle = '#ffaaff';
            x.beginPath(); x.arc(sx, sy + 6, 2, 0, Math.PI * 2); x.fill();
            // HP bar
            const mw = Math.max(60, m.r * 2.8), mh = 7, mx2 = sx - mw * .5, my2 = sy - m.r - 20;
            x.globalAlpha = .9;
            x.fillStyle = 'rgba(12,4,12,.92)'; x.fillRect(mx2 - 2, my2 - 2, mw + 4, mh + 4);
            x.fillStyle = '#2a0e2a'; x.fillRect(mx2, my2, mw, mh);
            const fgM = x.createLinearGradient(mx2, 0, mx2 + mw, 0);
            if (moRage > 1) { fgM.addColorStop(0, '#ff22ff'); fgM.addColorStop(1, '#ff77ff'); }
            else if (moRage > 0) { fgM.addColorStop(0, '#cc33cc'); fgM.addColorStop(1, '#ee55ee'); }
            else { fgM.addColorStop(0, '#993399'); fgM.addColorStop(1, '#cc55cc'); }
            x.fillStyle = fgM; x.fillRect(mx2, my2, mw * moHpR, mh);
            x.globalAlpha = 1;
          }
          if (m.k === 3) {
            // first boss visuals: glow + eat count
            const eats = m.b1Eat || 0;
            const hpR1 = clamp(m.hp / ((m.b1Max || m.hp) || 1), 0, 1);
            const pulseFx = (m.b1Pulse || 0) > .01 ? (m.b1Pulse / .35) : 0;
            const roarFx = (m.b1Roar || 0) > .01 ? (m.b1Roar / .6) : 0;
            // inner glow grows with eats
            const eatFrac = Math.min(1, eats / 20);
            const glowR = m.r + 10 + eats * 2.2 + Math.sin(g.t * 4) * 3;
            x.globalAlpha = .08 + .08 * eatFrac + .14 * pulseFx;
            x.fillStyle = eats > 15 ? '#ff8f8f' : eats > 8 ? '#ffd58f' : '#a789ff';
            x.beginPath(); x.arc(sx, sy, glowR, 0, Math.PI * 2); x.fill();
            // animated ring
            const ringHue = eats > 15 ? '#ff6b6b' : eats > 8 ? '#ffaa44' : '#c8a0ff';
            x.globalAlpha = .28 + .12 * Math.sin(g.t * 5 + i) + .08 * roarFx;
            x.strokeStyle = ringHue; x.lineWidth = 2.2 + eats * .08;
            x.beginPath(); x.arc(sx, sy, m.r + 8 + Math.sin(g.t * 5.5 + i) * 2.5, 0, Math.PI * 2); x.stroke();
            // roar shockwave
            if (roarFx > .01) {
              x.globalAlpha = .22 * roarFx;
              x.strokeStyle = '#c8a0ff'; x.lineWidth = 3;
              x.beginPath(); x.arc(sx, sy, m.r + 20 + (1 - roarFx) * 50, 0, Math.PI * 2); x.stroke();
            }
            // eat absorption particles orbiting
            if (eats > 0) {
              for (let n = 0; n < Math.min(eats, 8); n++) {
                const oa = g.t * (3.2 + n * .4) + n * (.78 + eats * .04), od = m.r + 8 + n * 2.5 + Math.sin(g.t * 6 + n) * 3;
                const ox = sx + Math.cos(oa) * od, oy = sy + Math.sin(oa) * od;
                x.globalAlpha = .35 + .2 * Math.sin(g.t * 8 + n);
                x.fillStyle = '#69f0c9';
                x.beginPath(); x.arc(ox, oy, 2.2 + eats * .06, 0, Math.PI * 2); x.fill();
              }
            }
            // eat-pulse flash
            if (pulseFx > .01) {
              x.globalAlpha = .3 * pulseFx;
              x.fillStyle = '#69f0c9';
              x.beginPath(); x.arc(sx, sy, m.r + 8 + (1 - pulseFx) * 24, 0, Math.PI * 2); x.fill();
            }
            // boss HP bar above head
            const bhpW = Math.max(44, m.r * 2.2), bhpH = 5;
            const bhpX = sx - bhpW * .5, bhpY = sy - m.r - 16;
            x.globalAlpha = .85;
            x.fillStyle = 'rgba(10,14,22,.9)'; x.fillRect(bhpX - 2, bhpY - 2, bhpW + 4, bhpH + 4);
            x.fillStyle = '#3a2255'; x.fillRect(bhpX, bhpY, bhpW, bhpH);
            x.fillStyle = hpR1 > .5 ? '#a789ff' : hpR1 > .25 ? '#d88fff' : '#ff6b9a';
            x.fillRect(bhpX, bhpY, bhpW * hpR1, bhpH);
            // eat count indicator
            if (eats > 0) {
              x.fillStyle = '#69f0c9'; x.font = '700 9px Trebuchet MS,sans-serif';
              x.fillText('\u00d7' + eats, bhpX + bhpW + 5, bhpY + 5);
            }
            x.globalAlpha = 1;
          }
          if (m.k === 4) {
            const hpR = clamp(m.hp / ((m.apMax || m.hp) || 1), 0, 1);
            const ringCol = hpR > .66 ? '#bfa1ff' : hpR > .33 ? '#d8b4ff' : '#ffb6f2';
            const vsp = Math.hypot(m.vx || 0, m.vy || 0);
            if (vsp > 220) {
              const txv = (m.vx || 0) / (vsp || 1), tyv = (m.vy || 0) / (vsp || 1);
              x.globalAlpha = .14 + .06 * Math.sin(g.t * 20 + i);
              x.fillStyle = 'rgba(165,126,242,.7)';
              x.beginPath();
              x.ellipse(sx - txv * (18 + vsp * .02), sy - tyv * (18 + vsp * .02), m.r * .7, m.r * .44, Math.atan2(tyv, txv), 0, Math.PI * 2);
              x.fill();
            }
            x.globalAlpha = .25 + .12 * Math.sin(g.t * 8 + i);
            x.strokeStyle = ringCol;
            x.lineWidth = 2;
            x.beginPath();
            x.arc(sx, sy, m.r + 10 + Math.sin(g.t * 6 + i) * 2, 0, Math.PI * 2);
            x.stroke();
            if (m.apTele > 0 && m.apAimX !== undefined) {
              const tq = 1 - clamp(m.apTele / (m.apTeleD || .001), 0, 1);
              const tx2 = m.apAimX - cm.x, ty2 = m.apAimY - cm.y;
              x.globalAlpha = .22 + .5 * tq;
              x.strokeStyle = '#f2d6ff';
              x.lineWidth = 2.2 + tq * 1.8;
              x.setLineDash([7, 6]);
              x.lineDashOffset = -g.t * 90;
              x.beginPath();
              x.moveTo(sx, sy);
              x.lineTo(tx2, ty2);
              x.stroke();
              x.setLineDash([]);
              x.beginPath();
              x.arc(tx2, ty2, 26 + tq * 26, 0, Math.PI * 2);
              x.stroke();
              x.globalAlpha = .12 + .3 * tq;
              x.fillStyle = 'rgba(234,203,255,.85)';
              x.beginPath();
              x.arc(tx2, ty2, 18 + tq * 22, 0, Math.PI * 2);
              x.fill();
              x.fillStyle = 'rgba(248,232,255,.75)';
              x.beginPath();
              x.arc(tx2, ty2, 3.2, 0, Math.PI * 2);
              x.fill();
            }
            // damage shield glow
            if (m.apShieldT > 0) {
              const sq = clamp(m.apShieldT / 1.8, 0, 1);
              x.globalAlpha = .12 + .22 * sq;
              x.fillStyle = 'rgba(200,182,255,.8)';
              x.beginPath(); x.arc(sx, sy, m.r + 16 + Math.sin(g.t * 14) * 3, 0, Math.PI * 2); x.fill();
              x.globalAlpha = .35 + .4 * sq;
              x.strokeStyle = 'rgba(220,200,255,.9)';
              x.lineWidth = 2.5 + sq * 2;
              x.beginPath(); x.arc(sx, sy, m.r + 14 + Math.sin(g.t * 10) * 2, 0, Math.PI * 2); x.stroke();
            }
            // slam warning ring (shows when slam is nearly ready)
            if ((m.apSlamCd || 0) < .8 && (m.apSlamCd || 0) > 0) {
              const slamQ = 1 - clamp((m.apSlamCd || 0) / .8, 0, 1);
              x.globalAlpha = .08 + .18 * slamQ;
              x.strokeStyle = '#ff8bd9';
              x.lineWidth = 1.5 + slamQ * 2;
              x.setLineDash([6, 4]);
              x.lineDashOffset = -g.t * 60;
              const slamR = 120 + ((m.apPhase || 1)) * 28;
              x.beginPath(); x.arc(sx, sy, slamR, 0, Math.PI * 2); x.stroke();
              x.setLineDash([]);
            }
            // omega regen particles
            if ((m.apPhase || 1) >= 3) {
              if (Math.random() < .12) {
                const ra = Math.random() * Math.PI * 2, rd = m.r * .6;
                x.globalAlpha = .25 + .15 * Math.sin(g.t * 12 + i);
                x.fillStyle = '#d8b4ff';
                x.beginPath(); x.arc(sx + Math.cos(ra) * rd, sy + Math.sin(ra) * rd, 1.8, 0, Math.PI * 2); x.fill();
              }
            }
            x.globalAlpha = 1;
          }
        }

        // bullets
        for (let i = 0; i < b.length; i++) {
          const q = b[i], sx = q.x - cm.x, sy = q.y - cm.y;
          if (q.pulse) {
            const rr = q.r || 8;
            x.fillStyle = 'rgba(157,230,255,.2)';
            x.beginPath(); x.arc(sx, sy, rr * 1.4, 0, Math.PI * 2); x.fill();
            x.strokeStyle = q.c || '#9de6ff'; x.lineWidth = 2;
            x.beginPath(); x.arc(sx, sy, rr, 0, Math.PI * 2); x.stroke();
            x.fillStyle = 'rgba(224,250,255,.88)';
            x.beginPath(); x.arc(sx, sy, rr * .34, 0, Math.PI * 2); x.fill();
          } else {
            x.fillStyle = q.c || '#ffd56d';
            x.fillRect((sx - 2) | 0, (sy - 2) | 0, 4, 4);
          }
        }

        if (decoy.on || decoy.pop > 0) {
          const sx = decoy.x - cm.x, sy = decoy.y - cm.y;
          const q = decoy.on ? clamp(decoy.t / Math.max(.001, decoy.d), 0, 1) : 0;
          const pop = decoy.pop > 0 ? clamp(decoy.pop / .55, 0, 1) : 0;
          const rr = 18 + Math.sin(g.t * 8) * 1.4 + pop * 16;
          x.globalAlpha = .14 + .18 * (q + pop);
          x.fillStyle = '#9fe9ff';
          x.beginPath(); x.arc(sx, sy, rr + 8, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .55 + .25 * (q + pop);
          x.strokeStyle = '#d9f7ff'; x.lineWidth = 2;
          x.beginPath(); x.arc(sx, sy, rr, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = 1;
          x.fillStyle = 'rgba(220,246,255,.85)';
          x.fillRect((sx - 5) | 0, (sy - 7) | 0, 3, 3);
          x.fillRect((sx + 2) | 0, (sy - 7) | 0, 3, 3);
        }

        // player
        const psx = p.x - cm.x + p.rx, psy = p.y - cm.y + p.ry;
        const spr = Math.abs(p.vx) >= Math.abs(p.vy) ? (p.face > 0 ? imgs.e : imgs.w) : (p.vy < 0 ? (p.face > 0 ? imgs.ne : imgs.nw) : (p.face > 0 ? imgs.se : imgs.sw));
        x.fillStyle = 'rgba(0,0,0,.35)'; x.beginPath(); x.ellipse(psx, psy + 14, 17, 6, 0, 0, Math.PI * 2); x.fill();
        if (spr && spr.complete) x.drawImage(spr, psx - 22, psy - 18, 44, 30); else { x.fillStyle = '#0b0f14'; x.beginPath(); x.arc(psx, psy, 12, 0, Math.PI * 2); x.fill(); x.fillStyle = '#ef4f6c'; x.fillRect((psx + 3) | 0, (psy - 6) | 0, 7, 3) }
        if (p.bHealFx > 0) {
          const q = Math.min(1, p.bHealFx / .7), ring = 24 + Math.sin(g.t * 18) * 2;
          x.globalAlpha = .18 + .26 * q;
          x.fillStyle = '#79f2ad';
          x.beginPath(); x.arc(psx, psy, ring + 9 * q, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .55 + .35 * q;
          x.strokeStyle = '#bfffd6'; x.lineWidth = 2.2;
          x.beginPath(); x.arc(psx, psy, ring, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = 1;
        }
        if (p.fbFx > 0) {
          const q = clamp(p.fbFx / .55, 0, 1), rr = 42 + (1 - q) * Math.max(88, p.fbR * .78);
          const fillCol = p.fbMode === 3 ? 'rgba(198,183,255,.96)' : (p.fbMode === 2 ? 'rgba(150,236,255,.96)' : 'rgba(126,225,255,.96)');
          const strokeA = p.fbMode === 3 ? 'rgba(239,231,255,.98)' : (p.fbMode === 2 ? 'rgba(208,247,255,.98)' : 'rgba(219,247,255,.98)');
          const strokeB = p.fbMode === 3 ? 'rgba(203,183,255,.92)' : (p.fbMode === 2 ? 'rgba(176,236,255,.9)' : 'rgba(160,233,255,.92)');
          x.globalAlpha = .08 + .18 * q;
          x.fillStyle = fillCol;
          x.beginPath(); x.arc(psx, psy, rr * 1.08, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .56 + .34 * q;
          x.strokeStyle = strokeA;
          x.lineWidth = 2.4 + q * 1.6;
          x.beginPath(); x.arc(psx, psy, rr, 0, Math.PI * 2); x.stroke();
          x.strokeStyle = strokeB;
          x.lineWidth = 1.8 + q * 1.2;
          x.beginPath(); x.arc(psx, psy, rr * .64, 0, Math.PI * 2); x.stroke();
          if (p.fbMode === 1) {
            x.strokeStyle = 'rgba(209,247,255,.95)';
            x.lineWidth = 1.3 + q * .9;
            for (let k = 0; k < 7; k++) {
              const a = g.t * 10 + k * (Math.PI * 2 / 7);
              const r1 = rr * .34, r2 = rr * (.92 + .05 * Math.sin(g.t * 6 + k));
              x.beginPath();
              x.moveTo(psx + Math.cos(a) * r1, psy + Math.sin(a) * r1);
              x.lineTo(psx + Math.cos(a) * r2, psy + Math.sin(a) * r2);
              x.stroke();
            }
          } else if (p.fbMode === 3) {
            x.strokeStyle = 'rgba(247,238,255,.94)';
            x.lineWidth = 1.4 + q * .8;
            for (let k = 0; k < 6; k++) {
              const a = Math.PI / 6 + k * (Math.PI / 3);
              const r1 = rr * .22, r2 = rr * .86;
              x.beginPath();
              x.moveTo(psx + Math.cos(a) * r1, psy + Math.sin(a) * r1);
              x.lineTo(psx + Math.cos(a) * r2, psy + Math.sin(a) * r2);
              x.stroke();
            }
            x.beginPath();
            for (let k = 0; k < 6; k++) {
              const a = Math.PI / 6 + k * (Math.PI / 3), vx = psx + Math.cos(a) * rr * .86, vy = psy + Math.sin(a) * rr * .86;
              if (k === 0) x.moveTo(vx, vy);
              else x.lineTo(vx, vy);
            }
            x.closePath();
            x.stroke();
          }
          x.globalAlpha = 1;
        }
        if (p.bot && bots.length) {
          for (let bi = 0; bi < bots.length; bi++) {
            const bs = botStats(bots[bi].t | 0 || 1);
            const body = bs.body, ring = bs.ring;
            const bt = bots[bi], bx = bt.x - cm.x, by = bt.y - cm.y;
            x.fillStyle = 'rgba(0,0,0,.25)'; x.beginPath(); x.ellipse(bx, by + 8, 11, 4, 0, 0, Math.PI * 2); x.fill();
            x.fillStyle = body; x.beginPath(); x.arc(bx, by, 9, 0, Math.PI * 2); x.fill();
            x.fillStyle = '#16314a'; x.fillRect((bx - 3) | 0, (by - 2) | 0, 2, 2); x.fillRect((bx + 1) | 0, (by - 2) | 0, 2, 2);
            x.strokeStyle = ring; x.lineWidth = 1.2; x.beginPath(); x.arc(bx, by, 12 + Math.sin(g.t * 9 + bi) * 1.5, 0, Math.PI * 2); x.stroke();
            if (bs.auraR > 0) {
              x.strokeStyle = 'rgba(255,231,176,.42)'; x.lineWidth = 1.5;
              x.beginPath(); x.arc(bx, by, bs.auraR * (.84 + .08 * Math.sin(g.t * 4 + bi * .7)), 0, Math.PI * 2); x.stroke();
            }
          }
          if ((p.zt > 0 || p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) && bots.length >= 2) {
            const linkQ = clamp(p.slLinkT / SLINGSHOT_LINK_HOLD, 0, 1);
            const q = Math.max(p.triFx, p.slCharge, p.slFocus, p.slPow * ((p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) ? 1 : .35), linkQ * .85, p.slComboFx * .55);
            const ropeRest = Math.max(SLINGSHOT_ROPE_DEFAULT, (p.slRopeRest || SLINGSHOT_LINK_REST));
            const ropeTight = 1 - clamp((ropeRest - SLINGSHOT_ROPE_DEFAULT) / (SLINGSHOT_ROPE_START - SLINGSHOT_ROPE_DEFAULT), 0, 1);
            const dx = p.zt > 0 ? p.zx : (p.slT > 0 || p.slRecallT > 0 ? p.slDx : p.gx), dy = p.zt > 0 ? p.zy : (p.slT > 0 || p.slRecallT > 0 ? p.slDy : p.gy);
            const ph = g.t * 4.6;
            for (let bi = 0; bi < Math.min(3, bots.length); bi++) {
              const bt = bots[bi], bx = bt.x - cm.x, by = bt.y - cm.y;
              const bend = (bi - 1) * (12 + (9 + 6 * (1 - ropeTight)) * q);
              const cx = (psx + bx) * .5 + (-dy) * bend;
              const cy = (psy + by) * .5 + (dx) * bend;
              x.strokeStyle = 'rgba(150,238,255,' + (0.28 + .42 * q + .08 * ropeTight) + ')';
              x.lineWidth = 1.8 + q * 1.6;
              x.beginPath(); x.moveTo(psx, psy); x.quadraticCurveTo(cx, cy, bx, by); x.stroke();
              x.strokeStyle = 'rgba(223,252,255,' + (0.2 + .48 * q + .06 * ropeTight) + ')';
              x.lineWidth = .9 + q * .9;
              x.beginPath(); x.moveTo(psx, psy); x.quadraticCurveTo(cx, cy, bx, by); x.stroke();
              const u = (ph + bi * .27) % 1;
              const su = 1 - u;
              const sx2 = su * su * psx + 2 * su * u * cx + u * u * bx;
              const sy2 = su * su * psy + 2 * su * u * cy + u * u * by;
              x.fillStyle = 'rgba(219,250,255,' + (0.5 + .45 * q + .04 * ropeTight) + ')';
              x.beginPath(); x.arc(sx2, sy2, 1.9 + q * 1.1, 0, Math.PI * 2); x.fill();
              if (p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) {
                const svx = (bt.slx || 0) + p.slDx * (28 + 44 * ropeTight), svy = (bt.sly || 0) + p.slDy * (28 + 44 * ropeTight), sl = Math.hypot(svx, svy) || 1;
                const tx2 = bx - svx / sl * (18 + 10 * q), ty2 = by - svy / sl * (18 + 10 * q);
                x.strokeStyle = 'rgba(167,244,255,' + (0.22 + .44 * q + .14 * ropeTight) + ')';
                x.lineWidth = 2.2 + q * .9;
                x.beginPath(); x.moveTo(tx2, ty2); x.lineTo(bx, by); x.stroke();
              }
            }
            if (p.zt > 0 && p.slFocus > 0) {
              const fq = Math.min(1, p.slFocus);
              const rr = 30 + fq * 9 + Math.sin(g.t * 20) * 1.1;
              x.strokeStyle = p.slPerfect ? 'rgba(255,233,160,.95)' : 'rgba(196,239,255,' + (0.35 + .45 * fq) + ')';
              x.lineWidth = 1.4 + fq * 1.6;
              x.beginPath(); x.arc(psx, psy, rr, -Math.PI * .5, -Math.PI * .5 + Math.PI * 2 * fq); x.stroke();
              if (p.slPerfect) {
                x.fillStyle = 'rgba(255,240,190,.96)';
                x.font = '700 10px Trebuchet MS,sans-serif';
                x.fillText('PERFECT', psx - 22, psy - 28);
              }
            }
          }
          if (p.bCarry > 0) {
            const bx = bots[0].x - cm.x, by = bots[0].y - cm.y;
            x.fillStyle = 'rgba(6,10,16,.84)';
            x.beginPath(); x.arc(bx + 10, by - 10, 8, 0, Math.PI * 2); x.fill();
            x.fillStyle = '#dfffff'; x.font = '700 10px Trebuchet MS,sans-serif';
            x.fillText('' + p.bCarry, bx + 7, by - 7);
          }
        }
        if (p.mkS > 0 && p.zt <= 0) {
          const dir = p.face > 0 ? -1 : 1;
          const q = clamp(p.mkS / .32, 0, 1);
          const sx2 = psx + dir * 13, sy2 = psy + 8;
          const ex2 = sx2 + dir * (11 + Math.sin(g.t * 36) * 2.2), ey2 = sy2 + 7 + Math.sin(g.t * 22) * 1.1;
          x.strokeStyle = 'rgba(248,220,112,' + (0.38 + q * .45) + ')';
          x.lineWidth = 2;
          x.beginPath();
          x.moveTo(sx2, sy2);
          x.quadraticCurveTo((sx2 + ex2) * .5, sy2 + 2, ex2, ey2);
          x.stroke();
          x.fillStyle = 'rgba(250,214,103,.72)';
          x.beginPath(); x.arc(ex2 + dir * 2, ey2 + 2, 2.1, 0, Math.PI * 2); x.fill();
          x.fillStyle = 'rgba(244,205,93,.38)';
          x.beginPath(); x.ellipse(ex2 + dir * 5, ey2 + 7, 5.2, 2.7, 0, 0, Math.PI * 2); x.fill();
        }
        if ((p.zc > 0 || p.zcd > 0) && p.zt <= 0) {
          const q = p.zcd > 0 ? 0 : Math.min(1, p.zc / p.zLoad), cd = q <= 0 ? Math.max(0, 1 - p.zcd / p.zCool) : 0;
          const rr = 18 + q * 8 + Math.sin(g.t * 22) * 1.2;
          x.strokeStyle = p.zr ? '#8fffe5' : '#ffd56d';
          x.lineWidth = 2 + q * 1.8;
          x.beginPath(); x.arc(psx, psy, rr, -Math.PI * .5, -Math.PI * .5 + Math.PI * 2 * q); x.stroke();
          if (p.zcd > 0) {
            x.strokeStyle = 'rgba(158,200,255,.7)';
            x.lineWidth = 2;
            x.beginPath(); x.arc(psx, psy, 16, -Math.PI * .5, -Math.PI * .5 + Math.PI * 2 * cd); x.stroke();
          }
        }
        if (p.zt > 0 || p.slT > 0 || p.slRecallT > 0 || p.slLinkT > 0) {
          const q = p.zt > 0 ? p.zt / 2 : Math.max(p.slPow * .55, clamp(p.slLinkT / SLINGSHOT_LINK_HOLD, 0, 1) * .46);
          const dx = p.zt > 0 ? p.zx : (p.slT > 0 || p.slRecallT > 0 ? p.slDx : p.gx), dy = p.zt > 0 ? p.zy : (p.slT > 0 || p.slRecallT > 0 ? p.slDy : p.gy);
          x.strokeStyle = 'rgba(143,255,229,.7)';
          x.lineWidth = 2.5;
          x.beginPath(); x.arc(psx, psy, 20 + Math.sin(g.t * 30) * 2 + q * 4, 0, Math.PI * 2); x.stroke();
          x.fillStyle = 'rgba(143,255,229,.16)';
          x.beginPath(); x.ellipse(psx - dx * 10, psy - dy * 7, 20, 10, Math.atan2(dy, dx), 0, Math.PI * 2); x.fill();
          if (p.zt > 0) {
            const spd = Math.hypot(p.vx, p.vy), lLen = clamp(spd * .04, 6, 22);
            const nx = -dy, ny = dx;
            x.strokeStyle = 'rgba(200,255,240,.45)';
            x.lineWidth = 1.5;
            for (let li = 0; li < 4; li++) {
              const off = (li - 1.5) * 9, ox = nx * off, oy = ny * off;
              const sx = psx - dx * 18 + ox, sy = psy - dy * 14 + oy;
              x.beginPath(); x.moveTo(sx, sy); x.lineTo(sx - dx * lLen, sy - dy * lLen); x.stroke();
            }
          }
        }
        if (p.slWave > 0) {
          const q = p.slWave, rr = 30 + (1 - q) * 88;
          x.globalAlpha = .06 + .16 * q;
          x.fillStyle = 'rgba(142,238,255,.95)';
          x.beginPath(); x.arc(psx, psy, rr * 1.08, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .74 * q;
          x.strokeStyle = 'rgba(214,250,255,.96)';
          x.lineWidth = 2 + q * 2.4;
          x.beginPath(); x.arc(psx, psy, rr, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = 1;
        }
        if (p.slComboFx > 0) {
          const q = Math.min(1, p.slComboFx), rr = 42 + (1 - q) * 58;
          x.globalAlpha = .07 + .2 * q;
          x.fillStyle = 'rgba(185,244,255,.95)';
          x.beginPath(); x.arc(psx, psy, rr * 1.1, 0, Math.PI * 2); x.fill();
          x.globalAlpha = .2 + .45 * q;
          x.strokeStyle = 'rgba(229,251,255,.96)';
          x.lineWidth = 1.8 + q * 1.5;
          x.beginPath(); x.arc(psx, psy, rr, 0, Math.PI * 2); x.stroke();
          x.globalAlpha = 1;
        }
        if (p.flash > 0) {
          x.globalAlpha = p.flash / .07;
          x.fillStyle = '#ffe598';
          x.beginPath();
          x.moveTo(psx + p.gx * 16, psy + p.gy * 8);
          x.lineTo(psx + p.gx * 24 - p.gy * 5, psy + p.gy * 24 + p.gx * 4);
          x.lineTo(psx + p.gx * 24 + p.gy * 5, psy + p.gy * 24 - p.gx * 4);
          x.closePath();
          x.fill();
          x.globalAlpha = 1;
        }

        // particles
        for (let i = 0; i < fx.length; i++) {
          const f = fx[i], sx = f.x - cm.x, sy = f.y - cm.y;
          if (sx < -8 || sy < -8 || sx > W + 8 || sy > H + 8) continue;
          x.globalAlpha = Math.max(0, Math.min(1, f.t * 2.4));
          x.fillStyle = f.c;
          x.fillRect((sx) | 0, (sy) | 0, 3, 3);
        }
        x.globalAlpha = 1;

        // HUD
        const ab = 44, abGap = 8, abX = W - 18 - ab, zY = 14, tY = 14 + ab + abGap, rY = tY + ab + abGap;
        const hudCompact = W < 420;
        const hudH = 104;
        let hpY = 62, xpY = 74;
        const barsW = Math.max(96, W - 190);
        const hudBottom = 10 + hudH;
        x.fillStyle = 'rgba(7,10,16,.76)'; x.fillRect(10, 10, W - 20, hudH);
        x.fillStyle = '#eef4ff'; x.font = '700 17px Trebuchet MS,sans-serif'; x.fillText('SCOTTY', 20, 32);

        // pause button (top-right corner)
        if (g.start && !g.dead) {
          const pbW = 28, pbH = 28, pbX = W - pbW - 14, pbY = 14;
          g.pauseBtnX = pbX; g.pauseBtnY = pbY; g.pauseBtnW = pbW; g.pauseBtnH = pbH;
          x.fillStyle = 'rgba(28,42,64,.85)'; x.fillRect(pbX, pbY, pbW, pbH);
          x.strokeStyle = 'rgba(140,170,200,.7)'; x.lineWidth = 1.2; x.strokeRect(pbX + .5, pbY + .5, pbW - 1, pbH - 1);
          x.fillStyle = '#9ec8ff';
          if (g.paused) {
            // play triangle
            x.beginPath();
            x.moveTo(pbX + pbW * .35, pbY + pbH * .25);
            x.lineTo(pbX + pbW * .35, pbY + pbH * .75);
            x.lineTo(pbX + pbW * .7, pbY + pbH * .5);
            x.closePath();
            x.fill();
          } else {
            // pause bars
            x.fillRect(pbX + pbW * .3, pbY + pbH * .25, pbW * .15, pbH * .5);
            x.fillRect(pbX + pbW * .55, pbY + pbH * .25, pbW * .15, pbH * .5);
          }
        }

        if (hudCompact) {
          const statsY = 52;
          const statRight = abX - 8;
          x.font = '600 12px Trebuchet MS,sans-serif';
          x.fillStyle = '#9ec8ff'; x.fillText('Time ' + g.time.toFixed(1) + 's', 20, statsY);
          x.fillStyle = '#ffd56d'; x.fillText(g.bd2 ? g.kills + '/' + MOTHER_TRIGGER : 'Kills ' + g.kills, 118, statsY);
          if (g.endWave > 0) { x.fillStyle = '#ff9a7a'; x.fillText('W' + g.endWave, 210, statsY); }
          x.textAlign = 'right';
          x.fillStyle = '#dce8ff'; x.fillText('Best ' + g.best, statRight, statsY);
          x.textAlign = 'left';
          hpY = 62; xpY = 74;
        } else {
          x.font = '600 14px Trebuchet MS,sans-serif';
          x.fillStyle = '#9ec8ff'; x.fillText('Time ' + g.time.toFixed(1) + 's', 20, 54);
          x.fillStyle = '#ffd56d'; x.fillText(g.bd2 ? g.kills + '/' + MOTHER_TRIGGER : 'Kills ' + g.kills, 150, 54);
          if (g.endWave > 0) { x.fillStyle = '#ff9a7a'; x.fillText('Wave ' + g.endWave, 280, 54); }
          x.textAlign = 'right';
          x.fillStyle = '#dce8ff'; x.fillText('Best ' + g.best, W - 24, 54);
          x.textAlign = 'left';
        }

        // hp
        x.fillStyle = '#2a3346'; x.fillRect(20, hpY, barsW, 10);
        x.fillStyle = '#ef4f6c'; x.fillRect(20, hpY, barsW * (p.hp / p.maxHp), 10);
        // xp
        x.fillStyle = '#24374d'; x.fillRect(20, xpY, barsW, 8);
        x.fillStyle = '#69f0c9'; x.fillRect(20, xpY, barsW * (g.xp / g.nextXp), 8);
        let mothBoss = 0;
        for (let i = 0; i < z.length; i++)if (z[i].k === 11) { mothBoss = z[i]; break; }
        let predBoss = 0;
        for (let i = 0; i < z.length; i++)if (z[i].k === 9) { predBoss = z[i]; break; }
        let miniBoss = 0;
        for (let i = 0; i < z.length; i++)if (z[i].k === 5) { miniBoss = z[i]; break; }
        let boss1 = 0;
        for (let i = 0; i < z.length; i++)if (z[i].k === 3) { boss1 = z[i]; break; }
        let apex = 0;
        for (let i = 0; i < z.length; i++)if (z[i].k === 4) { apex = z[i]; break; }
        let objectiveY = hudBottom + 4;
        if (mothBoss && g.moth) {
          const moHpR = clamp(mothBoss.hp / ((mothBoss.moMax || mothBoss.hp) || 1), 0, 1);
          const moPhase = moHpR > .6 ? 'AWAKENED' : moHpR > .25 ? 'FURIOUS' : 'BERSERK';
          const bw = clamp(W * .62, 260, 660), bh = 14, bx = (W - bw) * .5, by = objectiveY + 2;
          x.fillStyle = 'rgba(14,4,14,.92)';
          rr(bx - 10, by - 20, bw + 20, 42, 11);
          x.fill();
          x.fillStyle = 'rgba(50,10,50,.95)'; x.fillRect(bx, by, bw, bh);
          const fgMo = x.createLinearGradient(bx, 0, bx + bw, 0);
          if (moHpR > .6) { fgMo.addColorStop(0, '#993399'); fgMo.addColorStop(1, '#cc55cc'); }
          else if (moHpR > .25) { fgMo.addColorStop(0, '#cc33cc'); fgMo.addColorStop(1, '#ee55ee'); }
          else { fgMo.addColorStop(0, '#ff22ff'); fgMo.addColorStop(1, '#ff77ff'); }
          x.fillStyle = fgMo; x.fillRect(bx, by, bw * moHpR, bh);
          x.strokeStyle = 'rgba(255,100,255,.5)'; x.lineWidth = 1.2;
          x.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
          x.fillStyle = moHpR > .25 ? '#ffaaff' : '#ff66ff';
          x.font = '700 12px Trebuchet MS,sans-serif';
          x.textAlign = 'center';
          x.fillText('THE MOTHER // ' + moPhase, bx + bw * .5, by - 7);
          x.textAlign = 'left';
          objectiveY += 38;
        }
        if (predBoss && g.pred) {
          const prHpR = clamp(predBoss.hp / ((predBoss.prMax || predBoss.hp) || 1), 0, 1);
          const prPhase = prHpR > .5 ? 'STALKING' : 'ENRAGED';
          const cloaked = (predBoss.prCloak || 0) > 0;
          const bw = clamp(W * .6, 240, 640), bh = 13, bx = (W - bw) * .5, by = objectiveY + 2;
          x.fillStyle = 'rgba(14,4,4,.92)';
          rr(bx - 10, by - 20, bw + 20, 40, 11);
          x.fill();
          x.fillStyle = 'rgba(60,10,15,.95)'; x.fillRect(bx, by, bw, bh);
          const fgp = x.createLinearGradient(bx, 0, bx + bw, 0);
          if (prHpR > .5) { fgp.addColorStop(0, '#bb1122'); fgp.addColorStop(1, '#ee3344'); }
          else { fgp.addColorStop(0, '#ff2222'); fgp.addColorStop(1, '#ff6644'); }
          x.fillStyle = fgp; x.fillRect(bx, by, bw * prHpR, bh);
          x.strokeStyle = 'rgba(255,80,80,.5)'; x.lineWidth = 1.2;
          x.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
          x.fillStyle = prHpR > .5 ? '#ffaaaa' : '#ff6666';
          x.font = '700 12px Trebuchet MS,sans-serif';
          x.textAlign = 'center';
          x.fillText('THE PREDATOR // ' + prPhase + (cloaked ? ' [CLOAKED]' : ''), bx + bw * .5, by - 7);
          x.textAlign = 'left';
          objectiveY += 36;
        }
        if (miniBoss && g.mb) {
          const mbHpR = clamp(miniBoss.hp / ((miniBoss.mbMax || miniBoss.hp) || 1), 0, 1);
          const bw = clamp(W * .48, 180, 500), bh = 9, bx = (W - bw) * .5, by = objectiveY + 2;
          x.fillStyle = 'rgba(10,14,22,.88)';
          rr(bx - 10, by - 16, bw + 20, 32, 11);
          x.fill();
          x.fillStyle = 'rgba(50,36,18,.95)'; x.fillRect(bx, by, bw, bh);
          const fgm = x.createLinearGradient(bx, 0, bx + bw, 0);
          fgm.addColorStop(0, '#cc7a2e'); fgm.addColorStop(1, '#ffa64d');
          x.fillStyle = fgm;
          x.fillRect(bx, by, bw * mbHpR, bh);
          x.strokeStyle = 'rgba(200,180,140,.55)'; x.lineWidth = 1.2;
          x.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
          x.fillStyle = '#ffe0a0';
          x.font = '700 10px Trebuchet MS,sans-serif';
          x.textAlign = 'center';
          x.fillText('THE PROVOST', bx + bw * .5, by - 5);
          x.textAlign = 'left';
          objectiveY += 28;
        }
        if (boss1 && g.bs) {
          const hpR1 = clamp(boss1.hp / ((boss1.b1Max || boss1.hp) || 1), 0, 1);
          const eats = boss1.b1Eat || 0;
          const title = eats > 20 ? 'THE DEAN // BLOATED' : eats > 12 ? 'THE DEAN // GORGED' : eats > 5 ? 'THE DEAN // HUNGRY' : 'THE DEAN';
          const bw = clamp(W * .54, 200, 560), bh = 11, bx = (W - bw) * .5, by = objectiveY + 2;
          x.fillStyle = 'rgba(10,14,22,.88)';
          rr(bx - 10, by - 18, bw + 20, 36, 11);
          x.fill();
          x.fillStyle = 'rgba(40,28,62,.95)'; x.fillRect(bx, by, bw, bh);
          const fg1 = x.createLinearGradient(bx, 0, bx + bw, 0);
          if (eats > 20) { fg1.addColorStop(0, '#ff3333'); fg1.addColorStop(1, '#ff7755'); }
          else if (eats > 12) { fg1.addColorStop(0, '#ff5656'); fg1.addColorStop(1, '#ff9a7a'); }
          else if (eats > 5) { fg1.addColorStop(0, '#ffaa44'); fg1.addColorStop(1, '#ffd58f'); }
          else { fg1.addColorStop(0, '#9a7dff'); fg1.addColorStop(1, '#c8a0ff'); }
          x.fillStyle = fg1;
          x.fillRect(bx, by, bw * hpR1, bh);
          x.strokeStyle = 'rgba(200,190,240,.55)'; x.lineWidth = 1.2;
          x.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
          x.fillStyle = eats > 20 ? '#ffaaaa' : eats > 12 ? '#ffc4c4' : eats > 5 ? '#ffe0b3' : '#e4d8ff';
          x.font = '700 11px Trebuchet MS,sans-serif';
          x.textAlign = 'center';
          x.fillText(title + (eats > 0 ? ' [' + eats + ' mints]' : ''), bx + bw * .5, by - 7);
          x.textAlign = 'left';
          objectiveY += 32;
        }
        if (apex) {
          const hpR = clamp(apex.hp / ((apex.apMax || apex.hp) || 1), 0, 1);
          const phase = (apex.apPhase || 1);
          const phaseName = phase === 1 ? 'ALPHA' : phase === 2 ? 'RAGE' : 'OMEGA';
          const bw = clamp(W * .58, 220, 620), bh = 12, bx = (W - bw) * .5, by = objectiveY + 2;
          x.fillStyle = 'rgba(10,14,22,.88)';
          rr(bx - 10, by - 18, bw + 20, 38, 11);
          x.fill();
          const bg = x.createLinearGradient(0, by, 0, by + bh);
          bg.addColorStop(0, 'rgba(54,71,103,.95)');
          bg.addColorStop(1, 'rgba(30,40,63,.95)');
          x.fillStyle = bg;
          x.fillRect(bx, by, bw, bh);
          const fg = x.createLinearGradient(bx, 0, bx + bw, 0);
          if (phase === 1) { fg.addColorStop(0, '#9a7dff'); fg.addColorStop(1, '#c8b6ff'); }
          else if (phase === 2) { fg.addColorStop(0, '#d28cff'); fg.addColorStop(1, '#ffbfd8'); }
          else { fg.addColorStop(0, '#ff8bd9'); fg.addColorStop(1, '#ffc3f1'); }
          x.fillStyle = fg;
          x.fillRect(bx, by, bw * hpR, bh);
          x.strokeStyle = 'rgba(220,234,255,.65)';
          x.lineWidth = 1.2;
          x.strokeRect(bx + .5, by + .5, bw - 1, bh - 1);
          x.fillStyle = '#f4ecff';
          x.font = '700 11px Trebuchet MS,sans-serif';
          x.textAlign = 'center';
          x.fillText('APEX DEAN // ' + phaseName, bx + bw * .5, by - 7);
          x.textAlign = 'left';
          objectiveY += 34;
        }
        const ot = objectiveText();
        x.fillStyle = 'rgba(8,12,19,.62)';
        x.fillRect(14, objectiveY, W - 28, 26);
        x.fillStyle = '#d7ffe8';
        x.font = '600 12px Trebuchet MS,sans-serif';
        x.fillText(ot, 22, objectiveY + 17);

        // --- direction arrow pointing toward next objective building ---
        if (g.start && !g.dead) {
          let navTarget = 0;
          if (!p.mkOn) { navTarget = school('home'); }
          else if (g.sch.nsh === 0) { navTarget = school('nsh'); }
          else if (g.sch.nsh === 1) { navTarget = school('nsh'); }
          else if (g.sch.mel === 0) { navTarget = school('mel'); }
          else if (g.sch.mel === 1) { navTarget = school('mel'); }
          else if (g.sch.bak === 0) { navTarget = school('bak'); }
          else if (g.sch.bak === 1) { navTarget = school('bak'); }
          else if (g.labNsh > 0) { navTarget = school('nsh'); }
          else if (g.labMel > 0) { navTarget = school('mel'); }
          else if (g.labBak > 0) { navTarget = school('bak'); }
          else if (g.sch.nsh === 2 && g.sch.mel === 2 && g.sch.bak === 2 && !g.mb && !g.bs && !g.bd && !g.bs2 && !g.bd2) { navTarget = evacNavTarget(); }
          if (navTarget) {
            const tx = navTarget.x - cm.x, ty = navTarget.y - cm.y;
            const onScreen = tx > -navTarget.r && tx < W + navTarget.r && ty > -navTarget.r && ty < H + navTarget.r;
            if (!onScreen) {
              // draw edge-of-screen arrow
              const dx = navTarget.x - p.x, dy = navTarget.y - p.y;
              const ang = Math.atan2(dy, dx);
              const edgePad = 28;
              const cx = W * .5, cy = H * .5;
              // project to screen edge
              let ax = cx + Math.cos(ang) * 400, ay = cy + Math.sin(ang) * 400;
              // clamp to viewport edges with padding
              if (ax < edgePad) { const t2 = (edgePad - cx) / (ax - cx); ay = cy + (ay - cy) * t2; ax = edgePad; }
              else if (ax > W - edgePad) { const t2 = (W - edgePad - cx) / (ax - cx); ay = cy + (ay - cy) * t2; ax = W - edgePad; }
              if (ay < edgePad) { const t2 = (edgePad - cy) / (ay - cy); ax = cx + (ax - cx) * t2; ay = edgePad; }
              else if (ay > H - edgePad) { const t2 = (H - edgePad - cy) / (ay - cy); ax = cx + (ax - cx) * t2; ay = H - edgePad; }
              const dist = Math.hypot(dx, dy);
              const pulse = .6 + .4 * Math.sin(g.t * 3.6);
              const arrowSize = 9 + 2 * pulse;
              const col = navTarget.c;
              // outer glow
              x.globalAlpha = .18 * pulse;
              x.fillStyle = col;
              x.beginPath(); x.arc(ax, ay, arrowSize + 6, 0, Math.PI * 2); x.fill();
              // arrow triangle
              x.globalAlpha = .65 + .25 * pulse;
              x.fillStyle = col;
              x.beginPath();
              x.moveTo(ax + Math.cos(ang) * arrowSize, ay + Math.sin(ang) * arrowSize);
              x.lineTo(ax + Math.cos(ang + 2.5) * arrowSize * .7, ay + Math.sin(ang + 2.5) * arrowSize * .7);
              x.lineTo(ax + Math.cos(ang - 2.5) * arrowSize * .7, ay + Math.sin(ang - 2.5) * arrowSize * .7);
              x.closePath(); x.fill();
              // distance label
              x.globalAlpha = .7;
              x.fillStyle = '#dce8ff'; x.font = '600 9px Trebuchet MS,sans-serif';
              x.textAlign = 'center';
              x.fillText(navTarget.n, ax, ay - arrowSize - 4);
              const dm = dist < 1000 ? (dist | 0) + '' : ((dist / 1000).toFixed(1) + 'k');
              x.fillText(dm, ax, ay + arrowSize + 11);
              x.textAlign = 'left';
              x.globalAlpha = 1;
            }
          }
        }

        if (p.bot && bots.length >= 2) {
          const slY = objectiveY + 30;
          const bw2 = W - 44;
          const triReady = p.zt > 0 && p.slT <= 0 && p.slRecallT <= 0;
          const prog = triReady ? clamp(p.slCharge, 0, 1) : (p.slT > 0 ? clamp(p.slT / SLINGSHOT_DASH_MAX, 0, 1) : (p.slRecallT > 0 ? clamp(p.slRecallT / SLINGSHOT_RECALL_TIME, 0, 1) : (p.slLinkT > 0 ? clamp(p.slLinkT / SLINGSHOT_LINK_HOLD, 0, 1) : 0)));
          const slTag = bots.length >= 3 ? 'triple' : 'duo';
          const label = triReady ? slTag + ' buddy: rope windup' : (p.slT > 0 ? slTag + ' buddy: blade throw' : (p.slRecallT > 0 ? slTag + ' buddy: blade recall' : (p.slLinkT > 0 ? slTag + ' buddy: ropes tightening' : slTag + ' buddy: zoomies to arm')));
          x.fillStyle = 'rgba(8,12,19,.64)';
          x.fillRect(14, slY, W - 28, 22);
          x.fillStyle = 'rgba(48,72,98,.9)';
          x.fillRect(22, slY + 8, bw2, 8);
          x.fillStyle = p.slRecallT > 0 ? '#c9f7ff' : p.slT > 0 ? '#8eefff' : p.slLinkT > 0 ? '#a8f4ff' : '#9fdfff';
          x.fillRect(22, slY + 8, bw2 * prog, 8);
          x.fillStyle = '#d5f2ff';
          x.font = '600 11px Trebuchet MS,sans-serif';
          x.fillText(label, 22, slY + 16);
          objectiveY += 26;
        }

        if (g.start && !g.dead) {
          const drawAb = (by, col, prog, active, sec, kind) => {
            x.fillStyle = 'rgba(8,12,19,.92)'; x.fillRect(abX, by, ab, ab);
            x.strokeStyle = active ? col : 'rgba(129,157,187,.7)'; x.lineWidth = 2; x.strokeRect(abX + .5, by + .5, ab - 1, ab - 1);
            x.strokeStyle = 'rgba(72,88,109,.85)'; x.lineWidth = 3;
            x.beginPath(); x.arc(abX + ab * .5, by + ab * .5, ab * .34, 0, Math.PI * 2); x.stroke();
            x.strokeStyle = col;
            x.beginPath(); x.arc(abX + ab * .5, by + ab * .5, ab * .34, -Math.PI * .5, -Math.PI * .5 + Math.PI * 2 * clamp(prog, 0, 1)); x.stroke();
            x.fillStyle = col;
            if (kind < 1) {
              x.beginPath();
              x.moveTo(abX + ab * .49, by + ab * .19);
              x.lineTo(abX + ab * .35, by + ab * .53);
              x.lineTo(abX + ab * .49, by + ab * .53);
              x.lineTo(abX + ab * .39, by + ab * .82);
              x.lineTo(abX + ab * .67, by + ab * .41);
              x.lineTo(abX + ab * .51, by + ab * .41);
              x.closePath(); x.fill();
            } else if (kind < 2) {
              x.beginPath(); x.arc(abX + ab * .5, by + ab * .44, ab * .1, 0, Math.PI * 2); x.fill();
              x.beginPath();
              x.moveTo(abX + ab * .5, by + ab * .2);
              x.bezierCurveTo(abX + ab * .69, by + ab * .45, abX + ab * .64, by + ab * .67, abX + ab * .5, by + ab * .78);
              x.bezierCurveTo(abX + ab * .36, by + ab * .67, abX + ab * .31, by + ab * .45, abX + ab * .5, by + ab * .2);
              x.fill();
            } else if (kind < 3) {
              x.lineWidth = 2;
              x.beginPath(); x.arc(abX + ab * .5, by + ab * .5, ab * .12, 0, Math.PI * 2); x.stroke();
              x.beginPath(); x.arc(abX + ab * .5, by + ab * .5, ab * .22, 0, Math.PI * 2); x.stroke();
            } else if (kind < 4) {
              x.lineWidth = 1.8;
              x.beginPath(); x.ellipse(abX + ab * .5, by + ab * .5, ab * .22, ab * .15, 0, 0, Math.PI * 2); x.stroke();
              x.beginPath(); x.arc(abX + ab * .5, by + ab * .5, ab * .06, 0, Math.PI * 2); x.fill();
            } else {
              x.lineWidth = 1.8;
              for (let k = 0; k < 3; k++) {
                const a = k * Math.PI / 3;
                x.beginPath();
                x.moveTo(abX + ab * .5 + Math.cos(a) * ab * .07, by + ab * .5 + Math.sin(a) * ab * .07);
                x.lineTo(abX + ab * .5 + Math.cos(a) * ab * .27, by + ab * .5 + Math.sin(a) * ab * .27);
                x.stroke();
                x.beginPath();
                x.moveTo(abX + ab * .5 - Math.cos(a) * ab * .07, by + ab * .5 - Math.sin(a) * ab * .07);
                x.lineTo(abX + ab * .5 - Math.cos(a) * ab * .27, by + ab * .5 - Math.sin(a) * ab * .27);
                x.stroke();
              }
            }
            if (sec > 0) {
              x.fillStyle = '#dce8ff'; x.font = '700 10px Trebuchet MS,sans-serif';
              x.fillText(sec.toFixed(1) + 's', abX + 8, by + ab - 6);
            } else if (active) {
              x.fillStyle = 'rgba(255,255,255,.8)'; x.beginPath(); x.arc(abX + ab - 8, by + 8, 3, 0, Math.PI * 2); x.fill();
            }
          };
          const zp = p.zcd > 0 ? 1 - p.zcd / p.zCool : (p.zr ? 1 : p.zc / p.zLoad);
          drawAb(zY, '#8fffe5', zp, p.zt > 0, p.zcd > 0 ? p.zcd : 0, 0);
          const tp = p.mkOn ? (p.mkT > 0 ? 1 - p.mkT / p.mkI : 1) : 0;
          drawAb(tY, p.cat ? chemColor() : '#f4d96e', tp, p.mkS > 0, p.mkOn && p.mkT > 0 ? p.mkT : 0, 1);
          const bp = p.fb ? (p.fbT > 0 ? 1 - p.fbT / p.fbI : 1) : 0;
          const fbCol = p.fbMode === 3 ? '#ccb8ff' : (p.fbMode === 2 ? '#95ebff' : '#7edfff');
          const psychKind = p.fbMode === 3 ? 4 : (p.fbMode === 2 ? 3 : 2);
          if (p.fb) drawAb(rY, fbCol, bp, p.fbFx > 0, p.fbT > 0 ? p.fbT : 0, psychKind);
          if (p.cat) {
            x.fillStyle = 'rgba(7,10,16,.75)';
            x.fillRect(abX - 56, tY + 12, 50, 20);
            x.fillStyle = '#dce8ff'; x.font = '600 10px Trebuchet MS,sans-serif';
            x.fillText(chemLabel(), abX - 50, tY + 25);
          }
          if (p.fb) {
            x.fillStyle = 'rgba(7,10,16,.75)';
            x.fillRect(abX - 72, rY + 12, 66, 20);
            x.fillStyle = '#dce8ff'; x.font = '600 10px Trebuchet MS,sans-serif';
            x.fillText(psychHudTag(p.fbMode), abX - 66, rY + 25);
          }
        }

        if (g.msgT > 0) {
          x.fillStyle = 'rgba(8,12,19,.74)'; x.fillRect(14, objectiveY + 30, W - 28, 28);
          x.fillStyle = '#d7ffe8'; x.font = '600 13px Trebuchet MS,sans-serif'; x.fillText(g.msg, 22, objectiveY + 49);
        }
        if (g.bossDownT > 0) {
          const q = clamp(g.bossDownT / 2.4, 0, 1);
          const pop = .96 + .08 * Math.sin(g.t * 18) * q;
          const cx = W * .5, cy = H * .52;
          x.fillStyle = 'rgba(7,10,16,' + (0.2 + 0.26 * q) + ')';
          x.fillRect(0, 0, W, H);
          x.save();
          x.translate(cx, cy); x.scale(pop, pop); x.translate(-cx, -cy);
          x.textAlign = 'center';
          x.fillStyle = 'rgba(255,227,143,' + (0.44 + 0.4 * q) + ')';
          x.font = (W < 520 ? '700 30px' : '700 40px') + ' Trebuchet MS,sans-serif';
          const bdt = g.won ? 'CAMPUS SECURED' : g.moth ? 'THE MOTHER HAS AWAKENED' : g.predDead && !g.bs2 && !g.bd2 ? 'PREDATOR DOWN' : g.bd && !g.bd2 ? 'THE DEAN IS DOWN' : g.mbd && !g.bd ? 'THE PROVOST IS DOWN' : g.bd2 ? 'APEX DOWN \u2014 ENDLESS MODE' : 'BOSS DOWN';
          x.fillText(bdt, cx, cy - 8);
          x.fillStyle = 'rgba(209,231,255,' + (0.58 + 0.32 * q) + ')';
          x.font = (W < 520 ? '600 13px' : '600 15px') + ' Trebuchet MS,sans-serif';
          const bds = g.won ? g.kills + ' kills - ' + g.time.toFixed(1) + 's - scotty saved campus!' : (g.bd2 && !g.moth ? 'restore campus flow: ' + g.kills + '/' + MOTHER_TRIGGER + ' threats' : g.bd ? 'something big is approaching...' : 'keep going...');
          x.fillText(bds, cx, cy + 20);
          x.restore();
          x.textAlign = 'left';
        }
        if (g.start && !g.dead && !g.lvup && !g.pz && joy.show > .01) {
          const kx = joy.x + joy.tx, ky = joy.y + joy.ty;
          x.fillStyle = 'rgba(7,11,17,' + (.42 * joy.show) + ')';
          x.beginPath(); x.arc(joy.x, joy.y, joy.r + 8, 0, Math.PI * 2); x.fill();
          x.strokeStyle = 'rgba(158,200,255,' + (.45 * joy.show) + ')'; x.lineWidth = 2;
          x.beginPath(); x.arc(joy.x, joy.y, joy.r, 0, Math.PI * 2); x.stroke();
          x.fillStyle = 'rgba(105,240,201,' + ((touchMove ? .65 : .42) * joy.show) + ')';
          x.beginPath(); x.arc(kx, ky, joy.kr, 0, Math.PI * 2); x.fill();
          x.strokeStyle = 'rgba(220,248,255,' + (.65 * joy.show) + ')'; x.lineWidth = 1.5;
          x.beginPath(); x.arc(kx, ky, joy.kr, 0, Math.PI * 2); x.stroke();
        }

        if (!g.start) {
          const ix = 20, iy = H * .16, iw = W - 40, ih = H * .68, tx = ix + 16;
          x.fillStyle = 'rgba(6,9,14,.86)'; x.fillRect(ix, iy, iw, ih);
          x.fillStyle = '#fff'; x.font = '700 30px Trebuchet MS,sans-serif'; x.fillText('Project: Zoomies', tx, iy + 42);
          x.fillStyle = '#9ec8ff'; x.font = '600 15px Trebuchet MS,sans-serif'; x.fillText('what the dog doing?', tx, iy + 64);
          x.fillStyle = '#d8e6ff'; x.font = '600 14px Trebuchet MS,sans-serif';
          drawWrap('Goop swallowed CMU paths. People are trapped inside buildings. Scotty is the only one fast enough to move across campus.', tx, iy + 98, iw - 32, 18, 5);
          x.fillStyle = '#9ec8ff'; x.font = '600 13px Trebuchet MS,sans-serif';
          drawWrap('Collaborate with school labs (NSH, Mellon, Baker) to keep evacuation routes open and push back the goop across campus in escalating phases.', tx, iy + 200, iw - 32, 17, 3);
          x.fillStyle = '#dce8ff'; x.font = '600 12px Trebuchet MS,sans-serif';
          drawWrap('Controls: drag to move. Remove finger to charge Zoomies, then move to dash. Catalyst and psych abilities auto-trigger from threat patterns. Buildings are temporary shelters, not permanent safety.', tx, iy + 250, iw - 32, 16, 4);
          x.fillStyle = '#69f0c9'; x.font = '700 23px Trebuchet MS,sans-serif'; x.fillText('tap start', tx, iy + ih - 22);
        }

        if (g.lvup && !g.dead) {
          x.fillStyle = 'rgba(6,10,15,.16)'; x.fillRect(0, 0, W, H);
          const ly = getChoiceLayout(), bx = ly.bx, by = ly.by, bw = ly.bw, bh = ly.bh, rects = ly.rects, mobile = ly.mobile;
          x.fillStyle = 'rgba(17,29,45,.95)'; rr(bx, by, bw, bh, 16); x.fill();
          x.strokeStyle = 'rgba(90,125,163,.8)'; x.lineWidth = 1.2; rr(bx + .5, by + .5, bw - 1, bh - 1, 16); x.stroke();
          x.fillStyle = '#ecf3ff'; x.font = (mobile ? '700 18px' : '700 20px') + ' Trebuchet MS,sans-serif'; x.fillText('SKILL BOOK', bx + 14, by + 24);
          x.fillStyle = '#9ec8ff'; x.font = '600 12px Trebuchet MS,sans-serif'; x.fillText('choose', bx + 14, by + 39);

          for (let i = 0; i < 3; i++) {
            const u = g.choices[i], r = rects[i];
            const a = clamp((g.cardT - i * .07) / .28, 0, 1), sc = .9 + .1 * eob(a);
            const ox = r.x + r.w * .5, oy = r.y + r.h * .5;
            x.save();
            x.translate(ox, oy); x.scale(sc, sc); x.translate(-ox, -oy);
            const cardBg = u && u.bg ? u.bg : 'rgba(27,44,66,.96)';
            const cardSt = u && u.st ? u.st : 'rgba(116,150,186,.85)';
            const cardTx = u && u.tx ? u.tx : '#eef5ff';
            const cardSub = u && u.sub ? u.sub : '#a9c3e2';
            x.fillStyle = cardBg; rr(r.x, r.y, r.w, r.h, 10); x.fill();
            x.strokeStyle = cardSt; x.lineWidth = 1.2; rr(r.x + .5, r.y + .5, r.w - 1, r.h - 1, 10); x.stroke();
            if (u) {
              const icon = upIcon(u.n);
              const head = icon + ' ' + u.n;
              let fs = mobile ? 16 : 17;
              for (; fs > 12; fs--) {
                x.font = '700 ' + fs + 'px Trebuchet MS,sans-serif';
                if (x.measureText(head).width <= r.w - 22) break;
              }
              x.fillStyle = cardTx; x.fillText(head, r.x + 12, r.y + 30);
              x.fillStyle = cardSub; x.font = '600 12px Trebuchet MS,sans-serif';
              drawWrap(u.d, r.x + 12, r.y + 48, r.w - 24, 14, 2);
            }
            x.restore();
          }
          x.fillStyle = '#95bce8'; x.font = '600 12px Trebuchet MS,sans-serif';
          x.fillText('tap 1/2/3', bx + 14, by + bh - 12);
        }
        if (g.pz && !g.dead && !g.lvup && g.start) {
          const l = puzzleLayout(), pz = g.pz;
          x.fillStyle = 'rgba(5,9,14,.5)'; x.fillRect(0, 0, W, H);
          x.fillStyle = 'rgba(16,24,37,.96)'; rr(l.bx, l.by, l.bw, l.bh, 14); x.fill();
          x.strokeStyle = 'rgba(106,145,185,.85)'; x.lineWidth = 1.2; rr(l.bx + .5, l.by + .5, l.bw - 1, l.bh - 1, 14); x.stroke();
          x.fillStyle = '#ecf3ff'; x.font = '700 19px Trebuchet MS,sans-serif';
          x.fillText(pz.id === 'nsh' ? 'NSH lab' : pz.id === 'mel' ? 'Mellon lab' : 'Baker lab', l.bx + 14, l.by + 27);
          if (pz.id === 'nsh') {
            x.fillStyle = '#dce8ff'; x.font = '600 12px Trebuchet MS,sans-serif'; x.fillText('order', l.bx + 14, l.by + 66);
            for (let i = 0; i < pz.seq.length; i++) {
              const cx = l.bx + 24 + i * 34, cy = l.by + 86, done = i < pz.step;
              x.fillStyle = done ? '#8cffc2' : '#79d7ff'; x.beginPath(); x.arc(cx, cy, 12, 0, Math.PI * 2); x.fill();
              x.fillStyle = '#12243a'; x.font = '700 11px Trebuchet MS,sans-serif'; x.fillText((pz.seq[i] + 1) + '', cx - 3, cy + 4);
            }
          } else if (pz.id === 'mel') {
            const cols = ['#8fd3ff', '#ffd58f', '#ff9fb7'];
            x.fillStyle = '#dce8ff'; x.font = '600 12px Trebuchet MS,sans-serif'; x.fillText('mix', l.bx + 14, l.by + 66);
            for (let i = 0; i < pz.seq.length; i++) {
              const cx = l.bx + 24 + i * 30, cy = l.by + 86, done = i < pz.step;
              x.fillStyle = cols[pz.seq[i]]; x.beginPath(); x.arc(cx, cy, 10, 0, Math.PI * 2); x.fill();
              if (done) { x.strokeStyle = '#8cffc2'; x.lineWidth = 2; x.beginPath(); x.arc(cx, cy, 12, 0, Math.PI * 2); x.stroke(); }
            }
          } else {
            x.fillStyle = '#dce8ff'; x.font = '600 12px Trebuchet MS,sans-serif';
            x.fillText('calm waves ' + pz.hit + '/' + pz.need + '  misses ' + pz.miss + '/' + pz.maxMiss, l.bx + 14, l.by + 66);
            const act = l.btn[pz.lane];
            const q = clamp(pz.wT / Math.max(.001, pz.wMax), 0, 1);
            const rr = 16 + (1 - q) * 30;
            const ax = act.x + act.w * .5, ay = act.y + act.h * .5;
            x.globalAlpha = .16 + .24 * (1 - q);
            x.fillStyle = '#9ec8ff';
            x.beginPath(); x.arc(ax, ay, rr * 1.06, 0, Math.PI * 2); x.fill();
            x.globalAlpha = .8;
            x.strokeStyle = '#d4ecff';
            x.lineWidth = 2.2;
            x.beginPath(); x.arc(ax, ay, rr, 0, Math.PI * 2); x.stroke();
            x.globalAlpha = 1;
          }
          for (let i = 0; i < 3; i++) {
            const bt = l.btn[i];
            x.fillStyle = pz.id === 'nsh' ? 'rgba(37,87,129,.96)' : pz.id === 'mel' ? ['#3c6588', '#9a6f3f', '#8e4f64'][i] : (i === pz.lane ? 'rgba(67,112,152,.98)' : 'rgba(33,59,86,.94)');
            rr(bt.x, bt.y, bt.w, bt.h, 10); x.fill();
            x.strokeStyle = 'rgba(196,223,255,.72)'; x.lineWidth = 1.1; rr(bt.x + .5, bt.y + .5, bt.w - 1, bt.h - 1, 10); x.stroke();
            x.fillStyle = '#eef5ff'; x.font = '700 13px Trebuchet MS,sans-serif';
            x.fillText(pz.id === 'nsh' ? 'terminal ' + (i + 1) : pz.id === 'mel' ? ['blue', 'amber', 'rose'][i] : ['north wing', 'atrium', 'garden'][i], bt.x + 9, bt.y + 28);
          }
          x.fillStyle = '#9ec8ff'; x.font = '600 11px Trebuchet MS,sans-serif';
          x.fillText('tap 1/2/3', l.bx + 14, l.by + l.bh - 10);
        }

        if (g.dead) {
          let cardX = 24, cardY = H * .2, cardW = W - 48, cardH = Math.min(H * .62, 430);
          if (cardY + cardH > H - 14) { cardY = 14; cardH = H - 28 }
          x.fillStyle = 'rgba(5,8,13,.88)'; x.fillRect(cardX, cardY, cardW, cardH);

          const small = W < 420 || H < 760;
          const rowStep = small ? 14 : 16;
          const btnW = Math.min(210, W - 90), btnH = 34, btnX = (W - btnW) * .5, btnY = cardY + cardH - btnH - 12;
          g.lbBtnX = btnX; g.lbBtnY = btnY; g.lbBtnW = btnW; g.lbBtnH = btnH;

          let y = cardY + 44;
          x.fillStyle = '#ff8298'; x.font = (small ? '700 29px' : '700 33px') + ' Trebuchet MS,sans-serif';
          x.fillText('GAME OVER', cardX + Math.max(10, (cardW - 196) * .5), y);

          y += 30;
          x.fillStyle = '#dce8ff'; x.font = '600 20px Trebuchet MS,sans-serif';
          x.fillText('Kills ' + g.kills, cardX + Math.max(12, (cardW - 86) * .5), y);

          y += 26;
          x.fillText('Best ' + g.best, cardX + Math.max(12, (cardW - 74) * .5), y);

          if (g.endWave > 0) {
            y += 26;
            x.fillStyle = '#ff9a7a';
            x.fillText('Wave ' + g.endWave, cardX + Math.max(12, (cardW - 74) * .5), y);
          }

          y += 26;
          x.fillStyle = '#9ec8ff'; x.font = '600 13px Trebuchet MS,sans-serif';
          x.fillText('Top ' + LB_PREVIEW_LIMIT + ' global', cardX + 16, y);

          y += 18;
          x.font = '600 12px Trebuchet MS,sans-serif';
          if (g.lbTop.length) {
            for (let i = 0; i < g.lbTop.length && i < LB_PREVIEW_LIMIT; i++) {
              const row = g.lbTop[i];
              const yy = y + i * rowStep;
              const leftTxt = (i + 1) + '. ' + fitText(row.name, Math.max(40, cardW - 170));
              x.fillStyle = '#dce8ff'; x.textAlign = 'left'; x.fillText(leftTxt, cardX + 16, yy);
              x.fillStyle = '#bdd8ff'; x.textAlign = 'right'; x.fillText(row.kills + ' / ' + Number(row.time_seconds).toFixed(1) + 's', cardX + cardW - 16, yy);
            }
            x.textAlign = 'left';
          } else {
            x.fillStyle = '#dce8ff';
            x.fillText(g.lbTopErr || 'loading leaderboard...', cardX + 16, y);
          }

          const rankY = y + rowStep * LB_PREVIEW_LIMIT + 6;
          x.fillStyle = '#9de6ff'; x.font = '600 12px Trebuchet MS,sans-serif';
          x.fillText(fitText(g.lbRankText || g.lbRankErr || 'checking your rank...', cardW - 32), cardX + 16, rankY);

          const retryY = Math.min(btnY - 8, rankY + 24);
          x.fillStyle = '#69f0c9'; x.font = (small ? '700 18px' : '700 20px') + ' Trebuchet MS,sans-serif';
          x.fillText('tap retry (anywhere)', cardX + 16, retryY);

          x.fillStyle = 'rgba(19,38,58,.95)'; rr(btnX, btnY, btnW, btnH, 10); x.fill();
          x.strokeStyle = 'rgba(130,190,255,.9)'; x.lineWidth = 1.4; rr(btnX + .5, btnY + .5, btnW - 1, btnH - 1, 10); x.stroke();
          x.fillStyle = '#9de6ff'; x.font = '700 15px Trebuchet MS,sans-serif'; x.textAlign = 'center';
          x.fillText('open leaderboard', btnX + btnW * .5, btnY + 22);
          x.textAlign = 'left';
        }

        // pause overlay
        if (g.paused && g.start && !g.dead) {
          x.fillStyle = 'rgba(5,8,13,.75)'; x.fillRect(0, 0, W, H);
          const px = W * .5, py = H * .4;
          x.fillStyle = '#9ec8ff'; x.font = '700 42px Trebuchet MS,sans-serif'; x.textAlign = 'center';
          x.fillText('PAUSED', px, py);
          x.fillStyle = '#dce8ff'; x.font = '600 16px Trebuchet MS,sans-serif';
          x.fillText('press ESC or click pause button to resume', px, py + 40);
          x.textAlign = 'left';
        }
      }

      function frame(ts) { if (!last) last = ts; let dt = (ts - last) * .001; last = ts; dt = Math.max(0, Math.min(.034, dt)); update(dt); draw(); requestAnimationFrame(frame) }

      function maybeStart() { if (!audio) audio = new (window.AudioContext || window.webkitAudioContext)(); if (!g.start) { g.start = 1; reset(1); beep(430, .05, 'triangle', .02) } }

      function toCanvasCoords(cx, cy) {
        const rect = c.getBoundingClientRect();
        const scaleX = rect.width ? W / rect.width : 1;
        const scaleY = rect.height ? H / rect.height : 1;
        return { x: (cx - rect.left) * scaleX, y: (cy - rect.top) * scaleY };
      }

      function pointerDown(e) {
        if (touchId >= 0 && touchId !== e.pointerId) return;
        touchId = e.pointerId; c.setPointerCapture(touchId);
        maybeStart();
        const { x: cx, y: cy } = toCanvasCoords(e.clientX, e.clientY);
        // pause button click
        if (g.start && !g.dead && cx >= g.pauseBtnX && cx <= g.pauseBtnX + g.pauseBtnW && cy >= g.pauseBtnY && cy <= g.pauseBtnY + g.pauseBtnH) {
          togglePause(); return;
        }
        // unpause by clicking anywhere when paused
        if (g.paused && g.start && !g.dead) { togglePause(); return; }
        if (g.dead) {
          const inLb = cx >= g.lbBtnX && cx <= g.lbBtnX + g.lbBtnW && cy >= g.lbBtnY && cy <= g.lbBtnY + g.lbBtnH;
          if (inLb) { openLeaderboardPage(); return }
          reset(1); beep(360, .05, 'triangle', .02); return
        }
        if (g.lvup) { pickByPos(cx, cy); return }
        if (g.pz) {
          const l = puzzleLayout();
          for (let i = 0; i < 3; i++) {
            const bt = l.btn[i];
            if (cx >= bt.x && cx <= bt.x + bt.w && cy >= bt.y && cy <= bt.y + bt.h) { puzzleInput(i); return }
          }
          return;
        }
        if (e.pointerType === 'mouse') return;
        touchMove = 1; joyStart(cx, cy); joySet(cx, cy);
      }
      function pointerMove(e) {
        if (touchId !== e.pointerId || !g.start || g.dead || g.lvup) return;
        if (!touchMove) return;
        const { x: cx, y: cy } = toCanvasCoords(e.clientX, e.clientY);
        joySet(cx, cy);
      }
      function pointerUp(e) { if (touchId !== e.pointerId) return; touchMove = 0; joyReset(); if (c.hasPointerCapture(touchId)) c.releasePointerCapture(touchId); touchId = -1 }

      function pickByPos(sx, sy) {
        if (!g.lvup) return;
        const rects = getChoiceLayout().rects;
        for (let i = 0; i < rects.length; i++) {
          const r = rects[i];
          if (sx >= r.x && sx <= r.x + r.w && sy >= r.y && sy <= r.y + r.h) { takeChoice(i); break }
        }
      }

      function keyDown(e) {
        const k = e.code;
        if (k === 'Space' || k === 'ArrowUp' || k === 'ArrowDown' || k === 'ArrowLeft' || k === 'ArrowRight') e.preventDefault();
        if (k === 'Escape' && g.start && !g.dead) { togglePause(); return; }
        if (k === 'Space' || k === 'Enter') maybeStart();
        if (g.paused) return;
        if (g.dead && k === 'KeyL') { openLeaderboardPage(); return }
        if (g.dead && (k === 'Space' || k === 'Enter' || k === 'KeyR')) { reset(1); beep(360, .05, 'triangle', .02); return }
        if (g.lvup) { if (k === 'Digit1') takeChoice(0); else if (k === 'Digit2') takeChoice(1); else if (k === 'Digit3') takeChoice(2); return }
        if (g.pz) {
          if (k === 'Digit1') puzzleInput(0);
          else if (k === 'Digit2') puzzleInput(1);
          else if (k === 'Digit3') puzzleInput(2);
          return;
        }
        if (!g.start || g.dead) return;
        if (k === 'KeyA' || k === 'ArrowLeft') keys.l = 1;
        else if (k === 'KeyD' || k === 'ArrowRight') keys.r = 1;
        else if (k === 'KeyW' || k === 'ArrowUp') keys.u = 1;
        else if (k === 'KeyS' || k === 'ArrowDown') keys.d = 1;
        else if (k === 'KeyE' || k === 'ShiftLeft' || k === 'ShiftRight') keys.gr = 1;
      }

      function keyUp(e) {
        const k = e.code;
        if (k === 'KeyA' || k === 'ArrowLeft') keys.l = 0;
        else if (k === 'KeyD' || k === 'ArrowRight') keys.r = 0;
        else if (k === 'KeyW' || k === 'ArrowUp') keys.u = 0;
        else if (k === 'KeyS' || k === 'ArrowDown') keys.d = 0;
        else if (k === 'KeyE' || k === 'ShiftLeft' || k === 'ShiftRight') keys.gr = 0;
      }

      addEventListener('resize', resize);
      addEventListener('keydown', keyDown);
      addEventListener('keyup', keyUp);
      c.addEventListener('pointerdown', pointerDown, { passive: 1 });
      c.addEventListener('pointermove', pointerMove, { passive: 1 });
      c.addEventListener('pointerup', pointerUp, { passive: 1 });
      c.addEventListener('pointercancel', pointerUp, { passive: 1 });

      resize();
      reset(1);
      requestAnimationFrame(frame);
    })();
  </script>
</body>

</html>
